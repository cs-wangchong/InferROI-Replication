code,valid intentions,gpt intentions
"public int eta(int[] counts, boolean reload) {
        double revYesRate;
        double revTime;
        double lrnYesRate;
        double lrnTime;
        if (reload || mEtaCache[0] == -1) {
            Cursor cur = null;
            try {
                cur = mCol
                        .getDb()
                        .getDatabase()
                        .rawQuery(
                                ""SELECT avg(CASE WHEN ease > 1 THEN 1.0 ELSE 0.0 END), avg(time) FROM revlog WHERE type = 1 AND id > ""
                                        + ((mCol.getSched().getDayCutoff() - (7 * 86400)) * 1000), null);
                if (!cur.moveToFirst()) {
                    return -1;
                }
                revYesRate = cur.getDouble(0);
                revTime = cur.getDouble(1);
                cur = mCol
                        .getDb()
                        .getDatabase()
                        .rawQuery(
                                ""SELECT avg(CASE WHEN ease = 3 THEN 1.0 ELSE 0.0 END), avg(time) FROM revlog WHERE type != 1 AND id > ""
                                        + ((mCol.getSched().getDayCutoff() - (7 * 86400)) * 1000), null);
                if (!cur.moveToFirst()) {
                    return -1;
                }
                lrnYesRate = cur.getDouble(0);
                lrnTime = cur.getDouble(1);
            } finally {
                if (cur != null && !cur.isClosed()) {
                    cur.close();
                }
            }
            mEtaCache[0] = revYesRate;
            mEtaCache[1] = revTime;
            mEtaCache[2] = lrnYesRate;
            mEtaCache[3] = lrnTime;
        } else {
            revYesRate = mEtaCache[0];
            revTime = mEtaCache[1];
            lrnYesRate = mEtaCache[2];
            lrnTime = mEtaCache[3];
        }
        // rev cards
        double eta = revTime * counts[2];
        // lrn cards
        double factor = Math.min(1 / (1 - lrnYesRate), 10);
        double lrnAnswers = (counts[0] + counts[1] + counts[2] * (1 - revYesRate)) * factor;
        eta += lrnAnswers * lrnTime;
        return (int) (eta / 60000);
    }","[('9', 'acquire', 'cur'), ('20', 'acquire', 'cur'), ('32', 'check', 'cur'), ('33', 'release', 'cur')]","[(9, 'acquire', 'cur', 'Cursor'), (20, 'acquire', 'cur', 'Cursor'), (32, 'check', 'cur', 'Cursor'), (33, 'release', 'cur', 'Cursor')]"
"public int eta(int[] counts, boolean reload) {
        double revYesRate;
        double revTime;
        double lrnYesRate;
        double lrnTime;
        if (reload || mEtaCache[0] == -1) {
            Cursor cur = null;
            try {
                cur = mCol
                        .getDb()
                        .getDatabase()
                        .rawQuery(
                                ""SELECT avg(CASE WHEN ease > 1 THEN 1.0 ELSE 0.0 END), avg(time) FROM revlog WHERE type = 1 AND id > ""
                                        + ((mCol.getSched().getDayCutoff() - (7 * 86400)) * 1000), null);
                if (!cur.moveToFirst()) {
                    return -1;
                }
                revYesRate = cur.getDouble(0);
                revTime = cur.getDouble(1);

                if (cur != null && !cur.isClosed()) {
                    cur.close();
                }

                cur = mCol
                        .getDb()
                        .getDatabase()
                        .rawQuery(
                                ""SELECT avg(CASE WHEN ease = 3 THEN 1.0 ELSE 0.0 END), avg(time) FROM revlog WHERE type != 1 AND id > ""
                                        + ((mCol.getSched().getDayCutoff() - (7 * 86400)) * 1000), null);
                if (!cur.moveToFirst()) {
                    return -1;
                }
                lrnYesRate = cur.getDouble(0);
                lrnTime = cur.getDouble(1);
            } finally {
                if (cur != null && !cur.isClosed()) {
                    cur.close();
                }
            }
            mEtaCache[0] = revYesRate;
            mEtaCache[1] = revTime;
            mEtaCache[2] = lrnYesRate;
            mEtaCache[3] = lrnTime;
        } else {
            revYesRate = mEtaCache[0];
            revTime = mEtaCache[1];
            lrnYesRate = mEtaCache[2];
            lrnTime = mEtaCache[3];
        }
        // rev cards
        double eta = revTime * counts[2];
        // lrn cards
        double factor = Math.min(1 / (1 - lrnYesRate), 10);
        double lrnAnswers = (counts[0] + counts[1] + counts[2] * (1 - revYesRate)) * factor;
        eta += lrnAnswers * lrnTime;
        return (int) (eta / 60000);
    }","[('9', 'acquire', 'cur'), ('21', 'check', 'cur'), ('22', 'release', 'cur'), ('25', 'acquire', 'cur'), ('37', 'check', 'cur'), ('38', 'release', 'cur')]","[(9, 'acquire', 'cur', 'Cursor'), (21, 'check', 'cur', 'Cursor'), (22, 'release', 'cur', 'Cursor'), (25, 'acquire', 'cur', 'Cursor'), (37, 'check', 'cur', 'Cursor'), (38, 'release', 'cur', 'Cursor')]"
"public boolean hasKey(String key) {
        return getDB().getDatabase().rawQuery(""SELECT 1 FROM deckVars WHERE key = '"" + key + ""'"", null).moveToNext();
    }","[('2', 'acquire', 'cursor')]",[]
"public boolean hasKey(String key) {
        Cursor cur = null;
        try {
            cur = getDB().getDatabase().rawQuery(""SELECT 1 FROM deckVars WHERE key = '"" + key + ""'"", null);
            return cur.moveToNext();
        } finally {
            if (cur != null) {
                cur.close();
            }	
        }
    }","[('4', 'acquire', 'Cursor'), ('7', 'check', 'Cursor'), ('8', 'release', 'Cursor')]","[(4, 'acquire', 'cur', 'Cursor'), (7, 'check', 'cur', 'Cursor'), (8, 'release', 'cur', 'Cursor')]"
"private static SQLiteDatabase upgradeDB(SQLiteDatabase mMetaDb, int databaseVersion) {
        Timber.i(""MetaDB:: Upgrading Internal Database.."");
        // if (mMetaDb.getVersion() == 0) {
        Timber.i(""MetaDB:: Applying changes for version: 0"");
        if (mMetaDb.getVersion() < 4) {
            mMetaDb.execSQL(""DROP TABLE IF EXISTS languages;"");
            mMetaDb.execSQL(""DROP TABLE IF EXISTS customDictionary;"");
            mMetaDb.execSQL(""DROP TABLE IF EXISTS whiteboardState;"");
        }
        // Create tables if not exist
        mMetaDb.execSQL(""CREATE TABLE IF NOT EXISTS languages ("" + "" _id INTEGER PRIMARY KEY AUTOINCREMENT, ""
                + ""did INTEGER NOT NULL, ord INTEGER, "" + ""qa INTEGER, "" + ""language TEXT)"");
        mMetaDb.execSQL(""CREATE TABLE IF NOT EXISTS whiteboardState ("" + ""_id INTEGER PRIMARY KEY AUTOINCREMENT, ""
                + ""did INTEGER NOT NULL, "" + ""state INTEGER)"");
        mMetaDb.execSQL(""CREATE TABLE IF NOT EXISTS customDictionary ("" + ""_id INTEGER PRIMARY KEY AUTOINCREMENT, ""
                + ""did INTEGER NOT NULL, "" + ""dictionary INTEGER)"");
        mMetaDb.execSQL(""CREATE TABLE IF NOT EXISTS smallWidgetStatus ("" + ""id INTEGER PRIMARY KEY AUTOINCREMENT, ""
                + ""due INTEGER NOT NULL, eta INTEGER NOT NULL)"");
        // Use pragma to get info about widgetStatus.
        Cursor c = mMetaDb.rawQuery(""PRAGMA table_info(widgetStatus)"", null);
        int columnNumber = c.getCount();
        if (columnNumber > 0) {
            if (columnNumber < 7) {
                mMetaDb.execSQL(""ALTER TABLE widgetStatus "" + ""ADD COLUMN eta INTEGER NOT NULL DEFAULT '0'"");
                mMetaDb.execSQL(""ALTER TABLE widgetStatus "" + ""ADD COLUMN time INTEGER NOT NULL DEFAULT '0'"");
            }
        } else {
            mMetaDb.execSQL(""CREATE TABLE IF NOT EXISTS widgetStatus ("" + ""deckId INTEGER NOT NULL PRIMARY KEY, ""
                    + ""deckName TEXT NOT NULL, "" + ""newCards INTEGER NOT NULL, "" + ""lrnCards INTEGER NOT NULL, ""
                    + ""dueCards INTEGER NOT NULL, "" + ""progress INTEGER NOT NULL, "" + ""eta INTEGER NOT NULL)"");
        }
        mMetaDb.setVersion(databaseVersion);
        Timber.i(""MetaDB:: Upgrading Internal Database finished. New version: %d"", databaseVersion);
        return mMetaDb;
    }",[],"[(1, 'acquire', 'mMetaDb', 'SQLiteDatabase'), (20, 'acquire', 'c', 'Cursor')]"
"private static SQLiteDatabase upgradeDB(SQLiteDatabase mMetaDb, int databaseVersion) {
        Timber.i(""MetaDB:: Upgrading Internal Database.."");
        // if (mMetaDb.getVersion() == 0) {
        Timber.i(""MetaDB:: Applying changes for version: 0"");

        if (mMetaDb.getVersion() < 4) {
            mMetaDb.execSQL(""DROP TABLE IF EXISTS languages;"");
            mMetaDb.execSQL(""DROP TABLE IF EXISTS customDictionary;"");
            mMetaDb.execSQL(""DROP TABLE IF EXISTS whiteboardState;"");
        }

        // Create tables if not exist
        mMetaDb.execSQL(""CREATE TABLE IF NOT EXISTS languages ("" + "" _id INTEGER PRIMARY KEY AUTOINCREMENT, ""
                + ""did INTEGER NOT NULL, ord INTEGER, "" + ""qa INTEGER, "" + ""language TEXT)"");
        mMetaDb.execSQL(""CREATE TABLE IF NOT EXISTS whiteboardState ("" + ""_id INTEGER PRIMARY KEY AUTOINCREMENT, ""
                + ""did INTEGER NOT NULL, "" + ""state INTEGER)"");
        mMetaDb.execSQL(""CREATE TABLE IF NOT EXISTS customDictionary ("" + ""_id INTEGER PRIMARY KEY AUTOINCREMENT, ""
                + ""did INTEGER NOT NULL, "" + ""dictionary INTEGER)"");
        mMetaDb.execSQL(""CREATE TABLE IF NOT EXISTS smallWidgetStatus ("" + ""id INTEGER PRIMARY KEY AUTOINCREMENT, ""
                + ""due INTEGER NOT NULL, eta INTEGER NOT NULL)"");
        // Use pragma to get info about widgetStatus.
        Cursor c = null;
        try {
             c = mMetaDb.rawQuery(""PRAGMA table_info(widgetStatus)"", null);
            int columnNumber = c.getCount();
            if (columnNumber > 0) {
                if (columnNumber < 7) {
                    mMetaDb.execSQL(""ALTER TABLE widgetStatus "" + ""ADD COLUMN eta INTEGER NOT NULL DEFAULT '0'"");
                    mMetaDb.execSQL(""ALTER TABLE widgetStatus "" + ""ADD COLUMN time INTEGER NOT NULL DEFAULT '0'"");
                }
            } else {
                mMetaDb.execSQL(""CREATE TABLE IF NOT EXISTS widgetStatus ("" + ""deckId INTEGER NOT NULL PRIMARY KEY, ""
                        + ""deckName TEXT NOT NULL, "" + ""newCards INTEGER NOT NULL, "" + ""lrnCards INTEGER NOT NULL, ""
                        + ""dueCards INTEGER NOT NULL, "" + ""progress INTEGER NOT NULL, "" + ""eta INTEGER NOT NULL)"");
            }
            mMetaDb.setVersion(databaseVersion);
            Timber.i(""MetaDB:: Upgrading Internal Database finished. New version: %d"", databaseVersion);
            return mMetaDb;
        } finally {
            if (c != null) {
                c.close();
            }
        }
    }",[],"[(1, 'acquire', 'mMetaDb', 'SQLiteDatabase'), (24, 'acquire', 'c', 'Cursor'), (40, 'check', 'c', 'Cursor'), (41, 'release', 'c', 'Cursor')]"
"private void addWords(Cursor cursor) {
    	int newCount = 0;
    	long newHash = 0;
    	//first checking if something has changed
    	if (cursor.moveToFirst()) {
            while (!cursor.isAfterLast()) {
                String name = cursor.getString(INDEX_NAME);
                if(name != null){
                    newHash += name.hashCode();
                    newCount++;
                }
                cursor.moveToNext();
            }
    	}
    	
    	if (newCount == mContactsCount  && newHash == mContactsHash )
    	{
    	    return;
    	}
    		if (AnySoftKeyboardConfiguration.DEBUG) Log.d(TAG, ""Contacts will be reloaded since count or hash changed. New count ""+newCount+"" was(""+mContactsCount+""), new hash ""+newHash+"" (was ""+mContactsHash+"")."");
    		mContactsCount = newCount;
    		mContactsHash = newHash;
    		
    		clearDictionary();
            int loadedContacts = 0;
            final int maxWordLength = MAX_WORD_LENGTH;
            if (cursor.moveToFirst()) {
                while (!cursor.isAfterLast()) {
                    String name = cursor.getString(INDEX_NAME);

                    if (name != null) {
                        int len = name.length();

                        // TODO: Better tokenization for non-Latin writing systems
                        for (int i = 0; i < len; i++) {
                            if (Character.isLetter(name.charAt(i))) {
                                int j;
                                for (j = i + 1; j < len; j++) {
                                    char c = name.charAt(j);

                                    if (!(c == '-' || c == '\'' ||
                                          Character.isLetter(c))) {
                                        break;
                                    }
                                }

                                String word = name.substring(i, j);
                                i = j - 1;

                                // Safeguard against adding really long words. Stack
                                // may overflow due to recursion
                                // Also don't add single letter words, possibly confuses
                                // capitalization of i.
                                final int wordLen = word.length();
                                if (wordLen < maxWordLength && wordLen > 1) {
                                	if (AnySoftKeyboardConfiguration.DEBUG)
                                		Log.d(TAG, ""Contact '""+word+""' will be added to contacts dictionary."");
                                	loadedContacts++;
                                    super.addWord(word, 128);
                                }
                            }
                        }
                    }

                    cursor.moveToNext();
                }
            }
            
            Log.i(TAG, ""Loaded ""+loadedContacts+"" contacts"");
    	
        
        cursor.close();
    }","[('72', 'release', 'cursor')]","[(72, 'release', 'cursor', 'Cursor')]"
"private void addWords(Cursor cursor) {
    	int newCount = 0;
    	long newHash = 0;
    	//first checking if something has changed
    	if (cursor.moveToFirst()) {
            while (!cursor.isAfterLast()) {
                String name = cursor.getString(INDEX_NAME);
                if(name != null){
                    newHash += name.hashCode();
                    newCount++;
                }
                cursor.moveToNext();
            }
    	}
    	
    	if (newCount == mContactsCount  && newHash == mContactsHash )
    	{
    	    cursor.close();
    	    return;
    	    
    	}
    		if (AnySoftKeyboardConfiguration.DEBUG) Log.d(TAG, ""Contacts will be reloaded since count or hash changed. New count ""+newCount+"" was(""+mContactsCount+""), new hash ""+newHash+"" (was ""+mContactsHash+"")."");
    		mContactsCount = newCount;
    		mContactsHash = newHash;
    		
    		clearDictionary();
            int loadedContacts = 0;
            final int maxWordLength = MAX_WORD_LENGTH;
            if (cursor.moveToFirst()) {
                while (!cursor.isAfterLast()) {
                    String name = cursor.getString(INDEX_NAME);

                    if (name != null) {
                        int len = name.length();

                        // TODO: Better tokenization for non-Latin writing systems
                        for (int i = 0; i < len; i++) {
                            if (Character.isLetter(name.charAt(i))) {
                                int j;
                                for (j = i + 1; j < len; j++) {
                                    char c = name.charAt(j);

                                    if (!(c == '-' || c == '\'' ||
                                          Character.isLetter(c))) {
                                        break;
                                    }
                                }

                                String word = name.substring(i, j);
                                i = j - 1;

                                // Safeguard against adding really long words. Stack
                                // may overflow due to recursion
                                // Also don't add single letter words, possibly confuses
                                // capitalization of i.
                                final int wordLen = word.length();
                                if (wordLen < maxWordLength && wordLen > 1) {
                                	if (AnySoftKeyboardConfiguration.DEBUG)
                                		Log.d(TAG, ""Contact '""+word+""' will be added to contacts dictionary."");
                                	loadedContacts++;
                                    super.addWord(word, 128);
                                }
                            }
                        }
                    }

                    cursor.moveToNext();
                }
            }
            
            Log.i(TAG, ""Loaded ""+loadedContacts+"" contacts"");
    	
        
        cursor.close();
    }","[('16', 'check', 'cursor'), ('18', 'release', 'cursor'), ('74', 'release', 'cursor')]","[(18, 'release', 'cursor', 'Cursor'), (74, 'release', 'cursor', 'Cursor')]"
"@Override
      protected String[] doInBackground(Void... params) {
       try
       {
        Cursor langsCursor = getContentResolver().query(UserDictionary.Words.CONTENT_URI, 
          new String[]{UserDictionary.Words.LOCALE},
          null, null, null);
        if (langsCursor == null) throw new NullPointerException(""No device-wide user dictionary"");
        langsCursor.moveToFirst();
        ArrayList<String> langs = new ArrayList<String>();
        while(!langsCursor.isAfterLast())
        {
         String locale = langsCursor.getString(0);
         langsCursor.moveToNext();
         if (TextUtils.isEmpty(locale)) continue;
         if (langs.contains(locale)) continue;
         langs.add(locale);
        }

        return langs.toArray(new String[langs.size()]);
       }
       catch(Exception e)
       {
        //TODO: Use ASK fallback
        e.printStackTrace();
       }

       return new String[]{""en""};
      }","[('4', 'acquire', 'langsCursor'), ('7', 'check', 'langsCursor')]","[(4, 'acquire', 'langsCursor', 'Cursor'), (7, 'check', 'langsCursor', 'Cursor')]"
"@Override
    		protected String[] doInBackground(Void... params) {
    			try
    			{
    				Cursor langsCursor = getContentResolver().query(UserDictionary.Words.CONTENT_URI, 
    						new String[]{UserDictionary.Words.LOCALE},
    						null, null, null);
    				if (langsCursor == null) throw new NullPointerException(""No device-wide user dictionary"");
    				langsCursor.moveToFirst();
    				ArrayList<String> langs = new ArrayList<String>();
    				while(!langsCursor.isAfterLast())
    				{
    					String locale = langsCursor.getString(0);
    					langsCursor.moveToNext();
    					if (TextUtils.isEmpty(locale)) continue;
    					if (langs.contains(locale)) continue;
    					Log.d(TAG, ""Adding locale ""+locale+"" to editor."");
    					langs.add(locale);
    				}
    				
    				langsCursor.close();
    				//now to add all layouts locales
    				ArrayList<KeyboardAddOnAndBuilder> keyboards = KeyboardFactory.getAllAvailableKeyboards(getApplicationContext());
    				for(KeyboardAddOnAndBuilder kbd : keyboards)
    				{
    					String locale = kbd.getKeyboardLocale();
    					if (TextUtils.isEmpty(locale)) continue;
    					if (langs.contains(locale)) continue;
    					Log.d(TAG, ""Adding locale ""+locale+"" to editor."");
    					langs.add(locale);
    				}
    				return langs.toArray(new String[langs.size()]);
    			}
    			catch(Exception e)
    			{
    				//TODO: Use ASK fallback
    				e.printStackTrace();
    			}
    			
    			return new String[]{};
    		}","[('4', 'acquire', 'langsCursor'), ('7', 'check', 'langsCursor'), ('20', 'release', 'langsCursor')]","[(4, 'acquire', 'langsCursor', 'Cursor'), (7, 'check', 'langsCursor', 'Cursor'), (20, 'release', 'langsCursor', 'Cursor')]"
"private void indexCachedResources(Map<String, Long> fileModified, Map<String, SQLiteTileSource> rs) {
				Cursor cursor = sqliteDb.rawQuery(""SELECT filename, date_modified, left, right, top, bottom FROM TILE_SOURCES"", 
						new String[0]);
				if(cursor.moveToFirst()) {
					do {
						String filename = cursor.getString(0);
						long lastModified = cursor.getLong(1);
						Long read = fileModified.get(filename);
						if(rs.containsKey(filename) && read != null && lastModified == read) {
							int left = cursor.getInt(2);
							int right = cursor.getInt(3);
							int top = cursor.getInt(4);
							float bottom = cursor.getInt(5);
							indexedResources.insert(filename, new QuadRect(left, top, right, bottom));
							fileModified.remove(filename);
						}
						
					} while(cursor.moveToNext());
					cursor.close();
				}
			}","[('2', 'acquire', 'Cursor'), ('19', 'release', 'Cursor')]","[(2, 'acquire', 'cursor', 'Cursor'), (19, 'release', 'cursor', 'Cursor')]"
"private void indexCachedResources(Map<String, Long> fileModified, Map<String, SQLiteTileSource> rs) {
				Cursor cursor = sqliteDb.rawQuery(""SELECT filename, date_modified, left, right, top, bottom FROM TILE_SOURCES"", 
						new String[0]);
				if(cursor.moveToFirst()) {
					do {
						String filename = cursor.getString(0);
						long lastModified = cursor.getLong(1);
						Long read = fileModified.get(filename);
						if(rs.containsKey(filename) && read != null && lastModified == read) {
							int left = cursor.getInt(2);
							int right = cursor.getInt(3);
							int top = cursor.getInt(4);
							float bottom = cursor.getInt(5);
							indexedResources.insert(filename, new QuadRect(left, top, right, bottom));
							fileModified.remove(filename);
						}
						
					} while(cursor.moveToNext());
				}
				cursor.close();
			}","[('2', 'acquire', 'Cursor'), ('20', 'release', 'Cursor')]","[(2, 'acquire', 'cursor', 'Cursor'), (20, 'release', 'cursor', 'Cursor')]"
"	public static Conversation getConversation(final Context context,
			final int threadId, final boolean forceUpdate) {
		synchronized (CACHE) {
			Conversation ret = CACHE.get(threadId);
			if (ret == null || ret.getAddress() == null || forceUpdate) {
				Cursor cursor = context.getContentResolver().query(
						ConversationProvider.CONTENT_URI,
						ConversationProvider.PROJECTION,
						ConversationProvider.PROJECTION[// .
								ConversationProvider.INDEX_THREADID]
								+ "" = "" + threadId, null, null);
				if (cursor != null && cursor.moveToFirst()) {
					return getConversation(context, cursor, true);
				} else {
					Log.e(TAG, ""did not found conversation: "" + threadId);
				}
			}
			return ret;
		}
	}
","[('6', 'acquire', 'Cursor'), ('12', 'check', 'cursor')]","[(6, 'acquire', 'cursor', 'Cursor'), (12, 'check', 'cursor', 'Cursor')]"
"	public static Conversation getConversation(final Context context,
			final Cursor cursor, final boolean sync) {
		synchronized (CACHE) {
			Conversation ret = CACHE.get(cursor
					.getInt(ConversationProvider.INDEX_THREADID));
			if (ret == null) {
				ret = new Conversation(context, cursor, sync);
				CACHE.put(ret.getThreadId(), ret);
				Log.d(TAG, ""cachesize: "" + CACHE.size());
				while (CACHE.size() > CAHCESIZE) {
					Integer i = CACHE.keySet().iterator().next();
					Log.d(TAG, ""rm con. from cache: "" + i);
					Conversation cc = CACHE.remove(i);
					if (cc == null) {
						Log.w(TAG, ""CACHE might be inconsistent!"");
						break;
					}
				}
			} else {
				ret.update(context, cursor, sync);
			}
			return ret;
		}
	}
",[],"[(6, 'check', 'ret', 'Conversation'), (14, 'check', 'cc', 'Conversation')]"
"static boolean nameExists(String email) {
    Cursor cursor = DATABASE.query(TABLE_NAME, null, EMAIL_COLUMN + ""= ?"",
        new String[] {email}, null, null, null);
    if (cursor != null && cursor.getCount() > 0) {
      return true;
    } else {
      return false;
    }
  }","[('2', 'acquire', 'Cursor'), ('4', 'check', 'Cursor')]","[(2, 'acquire', 'cursor', 'Cursor'), (4, 'check', 'cursor', 'Cursor')]"
"  static boolean nameExists(String email) {
    Cursor cursor = getAccount(email);
    try {
      return !cursorIsEmpty(cursor);
    } finally {
      tryCloseCursor(cursor);
    }
  }
","[('2', 'acquire', 'Cursor'), ('6', 'release', 'Cursor')]","[(2, 'acquire', 'cursor', 'Cursor'), (6, 'release', 'cursor', 'Cursor')]"
"static String getSecret(String email) {
    Cursor cursor = DATABASE.query(TABLE_NAME, null, EMAIL_COLUMN + ""= ?"",
        new String[] {email}, null, null, null);
    if (cursor != null && cursor.getCount() > 0) {
      cursor.moveToFirst();
      return cursor.getString(cursor.getColumnIndex(SECRET_COLUMN));
    } 
    return null;   
  }","[('2', 'acquire', 'Cursor'), ('4', 'check', 'Cursor')]","[(2, 'acquire', 'cursor', 'Cursor')]"
"  static String getSecret(String email) {
    Cursor cursor = getAccount(email);
    try {
      if (!cursorIsEmpty(cursor)) {
        cursor.moveToFirst();
        return cursor.getString(cursor.getColumnIndex(SECRET_COLUMN));
      }
    } finally {
      tryCloseCursor(cursor);
    }
    return null;   
  }
","[('2', 'acquire', 'Cursor'), ('4', 'check', 'Cursor'), ('9', 'release', 'Cursor')]","[(2, 'acquire', 'cursor', 'Cursor'), (4, 'check', 'cursor', 'Cursor'), (9, 'release', 'cursor', 'Cursor')]"
"static Integer getCounter(String email) {
    Cursor cursor = DATABASE.query(TABLE_NAME, null, EMAIL_COLUMN + ""= ?"", 
        new String[] {email}, null, null, null);
    if (cursor != null && cursor.getCount() > 0) {
      cursor.moveToFirst();
      return cursor.getInt(cursor.getColumnIndex(COUNTER_COLUMN));
    } 
    return null;   
  }","[('2', 'acquire', 'Cursor'), ('4', 'check', 'Cursor')]","[(2, 'acquire', 'cursor', 'Cursor'), (4, 'check', 'cursor', 'Cursor')]"
"  static Integer getCounter(String email) {
    Cursor cursor = getAccount(email);
    try {
      if (!cursorIsEmpty(cursor)) {
        cursor.moveToFirst();
        return cursor.getInt(cursor.getColumnIndex(COUNTER_COLUMN));
      } 
    } finally {
      tryCloseCursor(cursor);
    }
    return null;   
  }
","[('2', 'acquire', 'Cursor'), ('4', 'check', 'Cursor'), ('9', 'release', 'Cursor')]","[(2, 'acquire', 'cursor', 'Cursor'), (4, 'check', 'cursor', 'Cursor'), (9, 'release', 'cursor', 'Cursor')]"
"static OtpType getType(String email) {
    Cursor cursor = DATABASE.query(TABLE_NAME, null, EMAIL_COLUMN + ""= ?"", 
        new String[] {email}, null, null, null);
    if (cursor != null && cursor.getCount() > 0) {
      cursor.moveToFirst();
      Integer value = cursor.getInt(cursor.getColumnIndex(TYPE_COLUMN));
      return OtpType.getEnum(value);
    } 
    return null;   
  }","[('2', 'acquire', 'Cursor'), ('4', 'check', 'Cursor')]","[(2, 'acquire', 'cursor', 'Cursor'), (4, 'check', 'cursor', 'Cursor')]"
"  static OtpType getType(String email) {
    Cursor cursor = getAccount(email);
    try {
      if (!cursorIsEmpty(cursor)) {
        cursor.moveToFirst();
        Integer value = cursor.getInt(cursor.getColumnIndex(TYPE_COLUMN));
        return OtpType.getEnum(value);
      } 
    } finally {
      tryCloseCursor(cursor);
    }
    return null;   
  }
","[('2', 'acquire', 'Cursor'), ('4', 'check', 'Cursor'), ('10', 'release', 'Cursor')]","[(2, 'acquire', 'cursor', 'Cursor'), (4, 'check', 'cursor', 'Cursor'), (10, 'release', 'cursor', 'Cursor')]"
"protected void refreshUserList() {
    
    // If the users have changed, let the (potentially running) widget know it needs to be
    // updated
    Intent intent = new Intent(AuthenticatorWidget.WidgetReceiver.APPWIDGET_UPDATE);
    intent.setClass(this, AuthenticatorWidget.WidgetReceiver.class);
    sendBroadcast(intent);
    
    Cursor cursor = AccountDb.getNames();
    int index = cursor.getColumnIndex(AccountDb.EMAIL_COLUMN);
    if (cursor.requery() && cursor.getCount() > 0) {
      if (mUsers.length != cursor.getCount()) {
        mUsers = new PinInfo[cursor.getCount()];
      }
      for (int i = 0; i < cursor.getCount(); i++) {
        cursor.moveToPosition(i);
        String user = cursor.getString(index);
        Log.i(TAG, ""onResume user: "" + user);
        computeAndDisplayPin(user, i, false);
      }

      mUserAdapter = new PinListAdapter(this, mUsers);
      mUserList.setAdapter(mUserAdapter); // force refresh of display

      if (mUserList.getVisibility() != View.VISIBLE) {
        mEnterPinTextView.setText(R.string.enter_pin);
        mEnterPinTextView.setVisibility(View.VISIBLE);
        mUserList.setVisibility(View.VISIBLE);
        registerForContextMenu(mUserList);
      }

    } else {
      // If the user started up this app but there is no secret key yet,
      // then tell the user to visit a web page to get the secret key.
      mUsers = new PinInfo[0]; // clear any existing user PIN state 
      tellUserToGetSecretKey();
    }
  }","[('9', 'acquire', 'Cursor')]","[(9, 'acquire', 'cursor', 'Cursor')]"
"  protected void refreshUserList() {
    refreshUserList(false);
  }
",[],[]
"public static Account accountFromDb(Context context, String accountId, boolean loadTransactions) {
  DBAdapter db = new DBAdapter(context);
  db.open();
  Cursor c = db.getAccount(accountId);
  if (c == null || c.isClosed() || (c.isBeforeFirst() && c.isAfterLast())) {
   db.close();
   return null;
  }
  Account account = new Account(c.getString(c.getColumnIndex(""name"")),
                                      new BigDecimal(c.getString(c.getColumnIndex(""balance""))),
                                      c.getString(c.getColumnIndex(""id"")).split(""_"")[1],
                                      c.getLong(c.getColumnIndex(""bankid"")),
                                      c.getInt(c.getColumnIndex(""acctype"")));
        account.setHidden(c.getInt(c.getColumnIndex(""hidden"")) == 1 ? true : false);
        account.setNotify(c.getInt(c.getColumnIndex(""notify"")) == 1 ? true : false);
        account.setCurrency(c.getString(c.getColumnIndex(""currency"")));
  c.close();
  if (loadTransactions) {
   ArrayList<Transaction> transactions = new ArrayList<Transaction>();
   //""transdate"", ""btransaction"", ""amount""}   
   c = db.fetchTransactions(accountId);
   if (!(c == null || c.isClosed() || (c.isBeforeFirst() && c.isAfterLast()))) {
    while (!c.isLast() && !c.isAfterLast()) {
     c.moveToNext();
     transactions.add(new Transaction(c.getString(c.getColumnIndex(""transdate"")),
                                     c.getString(c.getColumnIndex(""btransaction"")),
                                     new BigDecimal(c.getString(c.getColumnIndex(""amount""))),
                                     c.getString(c.getColumnIndex(""currency""))));
    }
   }
   account.setTransactions(transactions);
  }
  
  db.close();
  return account;
 }","[('3', 'acquire', 'db'), ('4', 'acquire', 'c'), ('5', 'check', 'c'), ('6', 'release', 'db'), ('17', 'release', 'c'), ('21', 'acquire', 'c'), ('22', 'check', 'c'), ('34', 'release', 'db')]","[(2, 'acquire', 'db', 'DBAdapter'), (4, 'acquire', 'c', 'Cursor'), (5, 'check', 'c', 'Cursor'), (6, 'release', 'db', 'DBAdapter'), (17, 'release', 'c', 'Cursor'), (22, 'check', 'c', 'Cursor'), (34, 'release', 'db', 'DBAdapter')]"
"public static Account accountFromDb(Context context, String accountId, boolean loadTransactions) {
		DBAdapter db = new DBAdapter(context);
		db.open();
		Cursor c = db.getAccount(accountId);
		if (c == null || c.isClosed() || (c.isBeforeFirst() && c.isAfterLast())) {
			db.close();
			return null;
		}

		Account account = new Account(c.getString(c.getColumnIndex(""name"")),
                                      new BigDecimal(c.getString(c.getColumnIndex(""balance""))),
                                      c.getString(c.getColumnIndex(""id"")).split(""_"")[1],
                                      c.getLong(c.getColumnIndex(""bankid"")),
                                      c.getInt(c.getColumnIndex(""acctype"")));
        account.setHidden(c.getInt(c.getColumnIndex(""hidden"")) == 1 ? true : false);
        account.setNotify(c.getInt(c.getColumnIndex(""notify"")) == 1 ? true : false);
        account.setCurrency(c.getString(c.getColumnIndex(""currency"")));
		c.close();
		if (loadTransactions) {
			ArrayList<Transaction> transactions = new ArrayList<Transaction>();
			//""transdate"", ""btransaction"", ""amount""}			
			c = db.fetchTransactions(accountId);
			if (!(c == null || c.isClosed() || (c.isBeforeFirst() && c.isAfterLast()))) {
				while (!c.isLast() && !c.isAfterLast()) {
					c.moveToNext();
					transactions.add(new Transaction(c.getString(c.getColumnIndex(""transdate"")),
                                     c.getString(c.getColumnIndex(""btransaction"")),
                                     new BigDecimal(c.getString(c.getColumnIndex(""amount""))),
                                     c.getString(c.getColumnIndex(""currency""))));
				}
				c.close();
			}
			account.setTransactions(transactions);
		}
		
		db.close();
		return account;
	}","[('3', 'acquire', 'db'), ('4', 'acquire', 'c'), ('5', 'check', 'c'), ('6', 'release', 'db'), ('18', 'release', 'c'), ('22', 'acquire', 'c'), ('23', 'check', 'c'), ('31', 'release', 'c'), ('36', 'release', 'db')]","[(2, 'acquire', 'db', 'DBAdapter'), (3, 'acquire', 'db', 'DBAdapter'), (4, 'acquire', 'c', 'Cursor'), (5, 'check', 'c', 'Cursor'), (6, 'release', 'db', 'DBAdapter'), (18, 'release', 'c', 'Cursor'), (22, 'acquire', 'c', 'Cursor'), (23, 'check', 'c', 'Cursor'), (31, 'release', 'c', 'Cursor'), (36, 'release', 'db', 'DBAdapter')]"
"private void deleteAllTracks() {
		Cursor cursor = getContentResolver().query(TrackContentProvider.CONTENT_URI_TRACK, null, null, null, Schema.COL_START_DATE + "" asc"");

		// Stop any currently active tracks
		if (currentTrackId != -1) {
			stopActiveTrack();
		}

		if (cursor.moveToFirst()) {
			int id_col = cursor.getColumnIndex(""_id"");
			do {
				deleteTrack(cursor.getLong(id_col));
			} while (cursor.moveToNext());
		}
	}","[('2', 'acquire', 'Cursor')]","[(2, 'acquire', 'cursor', 'Cursor')]"
"private void deleteAllTracks() {
		Cursor cursor = getContentResolver().query(TrackContentProvider.CONTENT_URI_TRACK, null, null, null, Schema.COL_START_DATE + "" asc"");

		// Stop any currently active tracks
		if (currentTrackId != -1) {
			stopActiveTrack();
		}

		if (cursor.moveToFirst()) {
			int id_col = cursor.getColumnIndex(""_id"");
			do {
				deleteTrack(cursor.getLong(id_col));
			} while (cursor.moveToNext());
		}
		cursor.close();
	}","[('2', 'acquire', 'Cursor'), ('15', 'release', 'Cursor')]","[(2, 'acquire', 'cursor', 'Cursor'), (15, 'release', 'cursor', 'Cursor')]"
"	@SuppressWarnings(""deprecation"")
	private void manageNewStoragePath(SQLiteDatabase db){
		Log.d(TAG,""manageNewStoragePath"");
		
		// we'll need this FilenameFitler to clean up our track directory
		FilenameFilter gpxFilenameFilter = new FilenameFilter() {
			@Override
			public boolean accept(File dir, String filename) {
				if(filename.toLowerCase().endsWith("".gpx""))
					return true;
				return false;
			}
		};
		
		// query all tracks
		String[] columns = new String[]{Schema.COL_ID, Schema.COL_DIR};
		Cursor cursor = db.query(Schema.TBL_TRACK, columns, null, null, null, null, null);
		
		// if we have a valid cursor and can write to the sdcard, we'll go on and try to copy the files
		if(cursor != null && cursor.moveToFirst()){
			Log.d(TAG, ""manageNewStoragePath (found "" + cursor.getCount() + "" tracks to be processed)"");
			do{
				long trackId = cursor.getLong(cursor.getColumnIndex(Schema.COL_ID));
				Log.d(TAG,""manageNewStoragePath ("" + trackId + "")"");
				String oldDirName = cursor.getString(cursor.getColumnIndex(Schema.COL_DIR));
				File newDir = DataHelper.getTrackDirectory(trackId);
				File oldDir = new File(oldDirName);
				if(oldDir.exists() && oldDir.canRead()){
					
					// if our new directory doesn't exist, we'll create it
					if(!newDir.exists())
						newDir.mkdirs();
					
					if(newDir.exists() && newDir.canWrite()){
						Log.d(TAG,""manageNewStoragePath ("" + trackId + ""): copy directory"");
						// we'll first copy all files to our new storage area... we'll clean up later
						FileSystemUtils.copyDirectoryContents(newDir, oldDir);
						
						// cleaning up new storage area
						// find gpx files we accidentally copied to our new storage area and delete them 
						for(File gpxFile:newDir.listFiles(gpxFilenameFilter)){
							Log.d(TAG,""manageNewStoragePath ("" + trackId + ""): deleting gpx file [""+gpxFile+""]"");
							gpxFile.delete();
						}
					}else{
						Log.e(TAG, ""manageNewStoragePath ("" + trackId + ""): directory [""+newDir+""] is not writable or could not be created"");
					}
					
				}
			}while(cursor.moveToNext());
		}
		
		ContentValues vals = new ContentValues();
		vals.putNull(Schema.COL_DIR);
		db.update(Schema.TBL_TRACK, vals, null, null);
	}
","[('16', 'acquire', 'cursor'), ('16', 'check', 'cursor')]","[(16, 'acquire', 'cursor', 'Cursor'), (19, 'check', 'cursor', 'Cursor'), (25, 'acquire', 'newDir', 'File'), (26, 'acquire', 'oldDir', 'File'), (27, 'check', 'oldDir', 'File'), (30, 'check', 'newDir', 'File'), (33, 'check', 'newDir', 'File'), (40, 'acquire', 'gpxFile', 'gpxFile'), (42, 'release', 'gpxFile', 'gpxFile'), (54, 'release', 'db', 'SQLiteDatabase')]"
"	@SuppressWarnings(""deprecation"")
	private void manageNewStoragePath(SQLiteDatabase db){
		Log.d(TAG,""manageNewStoragePath"");
		
		// we'll need this FilenameFitler to clean up our track directory
		FilenameFilter gpxFilenameFilter = new FilenameFilter() {
			@Override
			public boolean accept(File dir, String filename) {
				if(filename.toLowerCase().endsWith("".gpx""))
					return true;
				return false;
			}
		};
		
		// query all tracks
		String[] columns = new String[]{Schema.COL_ID, Schema.COL_DIR};
		Cursor cursor = db.query(Schema.TBL_TRACK, columns, null, null, null, null, null);
		
		// if we have a valid cursor and can write to the sdcard, we'll go on and try to copy the files
		if(cursor != null && cursor.moveToFirst()){
			Log.d(TAG, ""manageNewStoragePath (found "" + cursor.getCount() + "" tracks to be processed)"");
			do{
				long trackId = cursor.getLong(cursor.getColumnIndex(Schema.COL_ID));
				Log.d(TAG,""manageNewStoragePath ("" + trackId + "")"");
				String oldDirName = cursor.getString(cursor.getColumnIndex(Schema.COL_DIR));
				File newDir = DataHelper.getTrackDirectory(trackId);
				File oldDir = new File(oldDirName);
				if(oldDir.exists() && oldDir.canRead()){
					
					// if our new directory doesn't exist, we'll create it
					if(!newDir.exists())
						newDir.mkdirs();
					
					if(newDir.exists() && newDir.canWrite()){
						Log.d(TAG,""manageNewStoragePath ("" + trackId + ""): copy directory"");
						// we'll first copy all files to our new storage area... we'll clean up later
						FileSystemUtils.copyDirectoryContents(newDir, oldDir);
						
						// cleaning up new storage area
						// find gpx files we accidentally copied to our new storage area and delete them 
						for(File gpxFile:newDir.listFiles(gpxFilenameFilter)){
							Log.d(TAG,""manageNewStoragePath ("" + trackId + ""): deleting gpx file [""+gpxFile+""]"");
							gpxFile.delete();
						}
					}else{
						Log.e(TAG, ""manageNewStoragePath ("" + trackId + ""): directory [""+newDir+""] is not writable or could not be created"");
					}
					
				}
			}while(cursor.moveToNext());
			
			cursor.close();
		}
		
		ContentValues vals = new ContentValues();
		vals.putNull(Schema.COL_DIR);
		db.update(Schema.TBL_TRACK, vals, null, null);
	}
","[('16', 'acquire', 'cursor'), ('19', 'check', 'cursor'), ('51', 'release', 'cursor')]","[(16, 'acquire', 'cursor', 'Cursor'), (19, 'check', 'cursor', 'Cursor'), (25, 'acquire', 'newDir', 'File'), (26, 'acquire', 'oldDir', 'File'), (27, 'check', 'oldDir', 'File'), (30, 'check', 'newDir', 'File'), (33, 'check', 'newDir', 'File'), (40, 'acquire', 'gpxFile', 'gpxFile'), (42, 'release', 'gpxFile', 'gpxFile'), (51, 'release', 'cursor', 'Cursor')]"
"private void readExtraInformation(){
    if(!extraInformationRead){
        Cursor startCursor = cr.query(TrackContentProvider.trackStartUri(trackId), null, null, null, null);
        if(startCursor.moveToFirst()){
            startDate = startCursor.getLong(startCursor.getColumnIndex(Schema.COL_TIMESTAMP));
            startLat = startCursor.getFloat(startCursor.getColumnIndex(Schema.COL_LATITUDE));
            startLong = startCursor.getFloat(startCursor.getColumnIndex(Schema.COL_LONGITUDE));
        }
        Cursor endCursor = cr.query(TrackContentProvider.trackEndUri(trackId), null, null, null, null);
        if(endCursor.moveToFirst()){
            endDate = endCursor.getLong(endCursor.getColumnIndex(Schema.COL_TIMESTAMP));
            endLat = endCursor.getFloat(endCursor.getColumnIndex(Schema.COL_LATITUDE));
            endLong = endCursor.getFloat(endCursor.getColumnIndex(Schema.COL_LONGITUDE));
        }
        extraInformationRead = true;
    }
}","[('3', 'acquire', 'startCursor'), ('9', 'acquire', 'endCursor')]","[(3, 'acquire', 'startCursor', 'Cursor'), (9, 'acquire', 'endCursor', 'Cursor')]"
"	private void readExtraInformation(){
		if(!extraInformationRead){
			Cursor startCursor = cr.query(TrackContentProvider.trackStartUri(trackId), null, null, null, null);
			if(startCursor.moveToFirst()){
				startDate = startCursor.getLong(startCursor.getColumnIndex(Schema.COL_TIMESTAMP));
				startLat = startCursor.getFloat(startCursor.getColumnIndex(Schema.COL_LATITUDE));
				startLong = startCursor.getFloat(startCursor.getColumnIndex(Schema.COL_LONGITUDE));
			}
			startCursor.close();
			
			Cursor endCursor = cr.query(TrackContentProvider.trackEndUri(trackId), null, null, null, null);
			if(endCursor.moveToFirst()){
				endDate = endCursor.getLong(endCursor.getColumnIndex(Schema.COL_TIMESTAMP));
				endLat = endCursor.getFloat(endCursor.getColumnIndex(Schema.COL_LATITUDE));
				endLong = endCursor.getFloat(endCursor.getColumnIndex(Schema.COL_LONGITUDE));
			}
			endCursor.close();
			
			extraInformationRead = true;
		}
	}
","[('3', 'acquire', 'startCursor'), ('9', 'release', 'startCursor'), ('11', 'acquire', 'endCursor'), ('17', 'release', 'endCursor')]","[(3, 'acquire', 'startCursor', 'Cursor'), (9, 'release', 'startCursor', 'Cursor'), (11, 'acquire', 'endCursor', 'Cursor'), (17, 'release', 'endCursor', 'Cursor')]"
"private void readExtraInformation(){
  if(!extraInformationRead){
   Cursor startCursor = cr.query(TrackContentProvider.trackStartUri(trackId), null, null, null, null);
   if(startCursor.moveToFirst()){
    startDate = startCursor.getLong(startCursor.getColumnIndex(Schema.COL_TIMESTAMP));
    startLat = startCursor.getFloat(startCursor.getColumnIndex(Schema.COL_LATITUDE));
    startLong = startCursor.getFloat(startCursor.getColumnIndex(Schema.COL_LONGITUDE));
   }
   Cursor endCursor = cr.query(TrackContentProvider.trackEndUri(trackId), null, null, null, null);
   if(endCursor.moveToFirst()){
    endDate = endCursor.getLong(endCursor.getColumnIndex(Schema.COL_TIMESTAMP));
    endLat = endCursor.getFloat(endCursor.getColumnIndex(Schema.COL_LATITUDE));
    endLong = endCursor.getFloat(endCursor.getColumnIndex(Schema.COL_LONGITUDE));
   }

   extraInformationRead = true;
  }
 }
 ","[('3', 'acquire', 'startCursor'), ('9', 'acquire', 'endCursor')]","[(3, 'acquire', 'startCursor', 'Cursor'), (9, 'acquire', 'endCursor', 'Cursor')]"
"	private void readExtraInformation(){
		if(!extraInformationRead){
			Cursor startCursor = cr.query(TrackContentProvider.trackStartUri(trackId), null, null, null, null);
			if(startCursor.moveToFirst()){
				startDate = startCursor.getLong(startCursor.getColumnIndex(Schema.COL_TIMESTAMP));
				startLat = startCursor.getFloat(startCursor.getColumnIndex(Schema.COL_LATITUDE));
				startLong = startCursor.getFloat(startCursor.getColumnIndex(Schema.COL_LONGITUDE));
			}
			startCursor.close();
			
			Cursor endCursor = cr.query(TrackContentProvider.trackEndUri(trackId), null, null, null, null);
			if(endCursor.moveToFirst()){
				endDate = endCursor.getLong(endCursor.getColumnIndex(Schema.COL_TIMESTAMP));
				endLat = endCursor.getFloat(endCursor.getColumnIndex(Schema.COL_LATITUDE));
				endLong = endCursor.getFloat(endCursor.getColumnIndex(Schema.COL_LONGITUDE));
			}
			endCursor.close();
			
			extraInformationRead = true;
		}
	}
","[('3', 'acquire', 'startCursor'), ('9', 'release', 'startCursor'), ('11', 'acquire', 'endCursor'), ('17', 'release', 'endCursor')]","[(3, 'acquire', 'startCursor', 'Cursor'), (9, 'release', 'startCursor', 'Cursor'), (11, 'acquire', 'endCursor', 'Cursor'), (17, 'release', 'endCursor', 'Cursor')]"
"    public void reloadNotes() {
        swapCursor(mQuery.execute());
    }
",[],[]
"    public void reloadNotes() {
        changeCursor(mQuery.execute());
    }
",[],[]
"@Override
    public Cursor swapCursor(Cursor newCursor) {
        if (newCursor == null) {
            mCursorDataCount = 0;
            return super.swapCursor(newCursor);
        }
        
        mCursorDataCount = newCursor.getCount();

        // to mimic the infinite the notification's infinite scroll ui 
        // (with a progress spinner on the bottom of the list), we'll need to add
        // extra cells in the gridview:
        // - spacer cells as fillers to place the progress spinner on the first cell (_id < 0)
        // - progress spinner cell (_id = Integer.MIN_VALUE)

        // use a matrix cursor to create the extra rows
        MatrixCursor matrixCursor = new MatrixCursor(new String[] { ""_id"" });

        // add spacer cells
        int columnCount = getColumnCount(mContext);
        int remainder = newCursor.getCount() % columnCount;
        if (remainder > 0) {
            int spaceCount = columnCount - remainder; 
            for (int i = 0; i < spaceCount; i++ ) {
                int id = i - spaceCount;
                matrixCursor.addRow(new Object[] {id + """"});
            }
        }

        // add progress spinner cell
        matrixCursor.addRow(new Object[] { Integer.MIN_VALUE });
        
        // use a merge cursor to place merge the extra rows at the bottom of the newly swapped cursor
        MergeCursor mergeCursor = new MergeCursor(new Cursor[] { newCursor, matrixCursor });
        return super.swapCursor(mergeCursor);
    }","[('2', 'check', 'newCursor'), ('4', 'release', 'newCursor'), ('4', 'acquire', 'newCursor'), ('16', 'acquire', 'matrixCursor'), ('33', 'acquire', 'mergeCursor'), ('34', 'acquire', 'mergeCursor'), ('34', 'release', 'mergeCursor')]","[(2, 'check', 'newCursor', 'Cursor')]"
"@Override
    public void changeCursor(Cursor newCursor) {
        if (newCursor == null) {
            mCursorDataCount = 0;
            super.changeCursor(newCursor);
            return;
        }

        mCursorDataCount = newCursor.getCount();
        // to mimic the infinite the notification's infinite scroll ui 
        // (with a progress spinner on the bottom of the list), we'll need to add
        // extra cells in the gridview:
        // - spacer cells as fillers to place the progress spinner on the first cell (_id < 0)
        // - progress spinner cell (_id = Integer.MIN_VALUE)
        // use a matrix cursor to create the extra rows
        MatrixCursor matrixCursor = new MatrixCursor(new String[] { ""_id"" });
        // add spacer cells
        int columnCount = getColumnCount(mContext);
        int remainder = newCursor.getCount() % columnCount;
        if (remainder > 0) {
            int spaceCount = columnCount - remainder; 
            for (int i = 0; i < spaceCount; i++ ) {
                int id = i - spaceCount;
                matrixCursor.addRow(new Object[] {id + """"});
            }
        }
        // add progress spinner cell
        matrixCursor.addRow(new Object[] { Integer.MIN_VALUE });

        // use a merge cursor to place merge the extra rows at the bottom of the newly swapped cursor
        MergeCursor mergeCursor = new MergeCursor(new Cursor[] { newCursor, matrixCursor });
        super.changeCursor(mergeCursor);
    }","[('2', 'check', 'newCursor'), ('4', 'release', 'newCursor'), ('15', 'acquire', 'matrixCursor'), ('30', 'acquire', 'mergeCursor'), ('31', 'release', 'mergeCursor')]","[(2, 'check', 'newCursor', 'Cursor')]"
"    public void setFilter(Filter filter) {
        mFilter = filter;
        Cursor cursor = filterItems(mFilter);

        if (cursor != null) {
            mGridAdapter.swapCursor(cursor);
            mResultView.setVisibility(View.GONE);
        } else {
            if (filter != Filter.CUSTOM_DATE) {
                mResultView.setVisibility(View.VISIBLE);
                mResultView.setText(getResources().getString(R.string.empty_fields));
            }
        }

    }
","[('3', 'acquire', 'Cursor'), ('5', 'check', 'Cursor'), ('6', 'acquire', 'Cursor'), ('6', 'release', 'Cursor')]","[(3, 'acquire', 'cursor', 'Cursor'), (5, 'check', 'cursor', 'Cursor')]"
"    public void setFilter(Filter filter) {
        mFilter = filter;
        Cursor cursor = filterItems(mFilter);

        if (cursor != null) {
            mGridAdapter.changeCursor(cursor);
            mResultView.setVisibility(View.GONE);
        } else {
            if (filter != Filter.CUSTOM_DATE) {
                mResultView.setVisibility(View.VISIBLE);
                mResultView.setText(getResources().getString(R.string.empty_fields));
            }
        }

    }
","[('3', 'acquire', 'Cursor'), ('5', 'check', 'Cursor'), ('6', 'release', 'Cursor')]","[(3, 'acquire', 'cursor', 'Cursor'), (5, 'check', 'cursor', 'Cursor')]"
"public void setDateFilter() {
        Blog blog = WordPress.getCurrentBlog();

        if (blog == null)
            return;

        String blogId = String.valueOf(blog.getBlogId());

        GregorianCalendar startDate = new GregorianCalendar(mStartYear, mStartMonth, mStartDay);
        GregorianCalendar endDate = new GregorianCalendar(mEndYear, mEndMonth, mEndDay);

        long one_day = 24 * 60 * 60 * 1000;
        Cursor cursor = WordPress.wpDB.getMediaFilesForBlog(blogId, startDate.getTimeInMillis(), endDate.getTimeInMillis() + one_day);
        mGridAdapter.swapCursor(cursor);

        if (cursor != null && cursor.moveToFirst()) {
            mResultView.setVisibility(View.VISIBLE);

            SimpleDateFormat fmt = new SimpleDateFormat(""dd-MMM-yyyy"");
            fmt.setCalendar(startDate);
            String formattedStart = fmt.format(startDate.getTime());
            String formattedEnd = fmt.format(endDate.getTime());

            mResultView.setText(""Displaying media from "" + formattedStart + "" to "" + formattedEnd);
        } else {

            mResultView.setVisibility(View.VISIBLE);
            mResultView.setText(getResources().getString(R.string.empty_fields));

        }
    }","[('13', 'acquire', 'cursor'), ('16', 'check', 'cursor')]","[(4, 'check', 'blog', 'Blog'), (13, 'acquire', 'cursor', 'Cursor')]"
"public void setDateFilter() {
        Blog blog = WordPress.getCurrentBlog();

        if (blog == null)
            return;

        String blogId = String.valueOf(blog.getBlogId());

        GregorianCalendar startDate = new GregorianCalendar(mStartYear, mStartMonth, mStartDay);
        GregorianCalendar endDate = new GregorianCalendar(mEndYear, mEndMonth, mEndDay);

        long one_day = 24 * 60 * 60 * 1000;
        Cursor cursor = WordPress.wpDB.getMediaFilesForBlog(blogId, startDate.getTimeInMillis(), endDate.getTimeInMillis() + one_day);
        mGridAdapter.changeCursor(cursor);

        if (cursor != null && cursor.moveToFirst()) {
            mResultView.setVisibility(View.VISIBLE);

            SimpleDateFormat fmt = new SimpleDateFormat(""dd-MMM-yyyy"");
            fmt.setCalendar(startDate);
            String formattedStart = fmt.format(startDate.getTime());
            String formattedEnd = fmt.format(endDate.getTime());

            mResultView.setText(""Displaying media from "" + formattedStart + "" to "" + formattedEnd);
        } else {

            mResultView.setVisibility(View.VISIBLE);
            mResultView.setText(getResources().getString(R.string.empty_fields));

        }
    }","[('13', 'acquire', 'cursor'), ('16', 'check', 'cursor')]","[(4, 'check', 'blog', 'Blog'), (13, 'acquire', 'cursor', 'Cursor')]"
"public void reset() {
        mCheckedItems.clear();
        mGridView.setSelection(0);
        mGridView.requestFocusFromTouch();
        mGridView.setSelection(0);
        mGridAdapter.swapCursor(null);

        resetSpinnerAdapter();
        
        
        mHasRetrievedAllMedia = false;
    }","[('6', 'acquire', 'cursor')]",[]
"public void reset() {
        mCheckedItems.clear();
        mGridView.setSelection(0);
        mGridView.requestFocusFromTouch();
        mGridView.setSelection(0);
        mGridAdapter.changeCursor(null);

        resetSpinnerAdapter();
        
        
        mHasRetrievedAllMedia = false;
    }",[],[]
"    @Override
    public void onLoadFinished(Loader<Cursor> loader, Cursor data) {
        mCallback.onCursorLoaded(getUri(), data);
        if (mAdapter != null)
            mAdapter.swapCursor(data);
        configureEmptyLabel();
        if (isTablet()) {
            reloadLinearLayout();
        }
    }
","[('4', 'acquire', 'Cursor')]","[(3, 'check', 'mAdapter', 'mAdapter')]"
"    @Override
    public void onLoadFinished(Loader<Cursor> loader, Cursor data) {
        mCallback.onCursorLoaded(getUri(), data);
        if (mAdapter != null)
            mAdapter.changeCursor(data);
        configureEmptyLabel();
        if (isTablet()) {
            reloadLinearLayout();
        }
    }
",[],"[(3, 'check', 'mAdapter', 'mAdapter')]"
"    @Override
    public void onLoaderReset(Loader<Cursor> loader) {
        if (mAdapter != null)
            mAdapter.swapCursor(null);
        configureEmptyLabel();
        if (isTablet()) {
            reloadLinearLayout();
        }
    }
","[('3', 'acquire', 'Cursor')]","[(2, 'check', 'mAdapter', 'mAdapter')]"
"    @Override
    public void onLoaderReset(Loader<Cursor> loader) {
        if (mAdapter != null)
            mAdapter.changeCursor(null);
        configureEmptyLabel();
        if (isTablet()) {
            reloadLinearLayout();
        }
    }
",[],"[(2, 'check', 'mAdapter', 'mAdapter')]"
"public void search(String searchTerm) {
        mLastSearch = searchTerm;
        
        String blogId = getBlogId();
        Cursor cursor =  WordPress.wpDB.getThemes(blogId, searchTerm);
        if (mAdapter == null) {
            return;
        } else {   
            mAdapter.swapCursor(cursor);   
            mGridView.invalidateViews();
            
            if (cursor == null || cursor.getCount() == 0) {
                mNoResultText.setVisibility(View.VISIBLE);
            } else {
                mNoResultText.setVisibility(View.GONE);
            }
        }             
    }","[('5', 'acquire', 'Cursor'), ('9', 'acquire', 'Cursor'), ('9', 'release', 'Cursor'), ('12', 'check', 'Cursor')]","[(5, 'acquire', 'cursor', 'Cursor'), (6, 'check', 'mAdapter', 'mAdapter')]"
"public void search(String searchTerm) {
        mLastSearch = searchTerm;
        
        String blogId = getBlogId();
        Cursor cursor =  WordPress.wpDB.getThemes(blogId, searchTerm);
        if (mAdapter == null) {
            return;
        } else {   
            mAdapter.changeCursor(cursor);   
            mGridView.invalidateViews();
            
            if (cursor == null || cursor.getCount() == 0) {
                mNoResultText.setVisibility(View.VISIBLE);
            } else {
                mNoResultText.setVisibility(View.GONE);
            }
        }             
    }","[('5', 'acquire', 'Cursor'), ('9', 'release', 'Cursor'), ('12', 'check', 'Cursor')]","[(5, 'acquire', 'cursor', 'Cursor'), (6, 'check', 'mAdapter', 'mAdapter')]"
"    private void refresh() {
        Cursor cursor = fetchThemes(getThemeSortType());
        if (mAdapter == null) {
            mAdapter = new ThemeTabAdapter(getActivity(), cursor, false);
        }
        
        if (mNoResultText.isShown())
            mNoResultText.setVisibility(View.GONE);
        mAdapter.swapCursor(cursor);
    }
","[('2', 'acquire', 'Cursor'), ('9', 'acquire', 'Cursor'), ('9', 'release', 'Cursor')]","[(2, 'acquire', 'cursor', 'Cursor'), (3, 'check', 'mAdapter', 'mAdapter')]"
"    private void refresh() {
        Cursor cursor = fetchThemes(getThemeSortType());
        if (mAdapter == null) {
            mAdapter = new ThemeTabAdapter(getActivity(), cursor, false);
        }
        
        if (mNoResultText.isShown())
            mNoResultText.setVisibility(View.GONE);
        mAdapter.changeCursor(cursor);
    }
","[('2', 'acquire', 'Cursor'), ('9', 'release', 'Cursor')]","[(2, 'acquire', 'cursor', 'Cursor'), (3, 'check', 'mAdapter', 'mAdapter')]"
"public static FileInfo getFileInfoFromURI(Context aContext, Uri uri) throws IllegalArgumentException {
        FileInfo info = new FileInfo();
        if (uri.getScheme() != null && uri.getScheme().equals(""file"")) {
            info.path = uri.getPath();
            return info;
        }
        
        if (uri.toString().startsWith(""content://org.openintents.filemanager/"")) {
            // Work around URI escaping brokenness
            info.path = uri.toString().replaceFirst(""content://org.openintents.filemanager"", """");
            return info;
        }
        
        Cursor cursor = aContext.getContentResolver().query(uri, null, null, null, null);
        
        if (cursor != null && cursor.getCount() > 0)
        {
            cursor.moveToFirst();
            
            //need to check columns for different types
            int dataIdx = cursor.getColumnIndex(MediaStore.Images.Media.DATA);
            if (dataIdx != -1) 
            {
                info.path = cursor.getString(dataIdx);
                info.type = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Images.Media.MIME_TYPE));
            
            }
            else
            {
                dataIdx = cursor.getColumnIndex(MediaStore.Video.Media.DATA);
            
                if (dataIdx != -1)
                {
                    info.path = cursor.getString(dataIdx);
                    info.type = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Video.Media.MIME_TYPE));
                }
                else
                {
                    dataIdx = cursor.getColumnIndex(MediaStore.Audio.Media.DATA);
            
                    if (dataIdx != -1)
                    {
                        info.path = cursor.getString(dataIdx);
                        info.type = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.MIME_TYPE));
                    }
                    else
                    {
                        dataIdx = cursor.getColumnIndex(MediaStore.MediaColumns.DATA);
                
                        if (dataIdx != -1)
                        {
                            info.path = cursor.getString(dataIdx);
                            info.type = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.MIME_TYPE));
                          
                        }
                    }
                }
                
                cursor.close();
            }
        }
        
        return info;
    }","[('14', 'acquire', 'cursor'), ('16', 'check', 'cursor'), ('59', 'release', 'cursor')]","[(14, 'acquire', 'cursor', 'Cursor'), (16, 'check', 'cursor', 'Cursor'), (22, 'check', 'cursor', 'Cursor'), (32, 'check', 'cursor', 'Cursor'), (41, 'check', 'cursor', 'Cursor'), (50, 'check', 'cursor', 'Cursor'), (59, 'release', 'cursor', 'Cursor')]"
"public static FileInfo getFileInfoFromURI(Context aContext, Uri uri) throws IllegalArgumentException {
        FileInfo info = new FileInfo();
        if (uri.getScheme() != null && uri.getScheme().equals(""file"")) {
            info.path = uri.getPath();
            return info;
        }
        
        if (uri.toString().startsWith(""content://org.openintents.filemanager/"")) {
            // Work around URI escaping brokenness
            info.path = uri.toString().replaceFirst(""content://org.openintents.filemanager"", """");
            return info;
        }
        
        Cursor cursor = aContext.getContentResolver().query(uri, null, null, null, null);
        
        if (cursor != null && cursor.getCount() > 0)
        {
            cursor.moveToFirst();
            
            //need to check columns for different types
            int dataIdx = cursor.getColumnIndex(MediaStore.Images.Media.DATA);
            if (dataIdx != -1) 
            {
                info.path = cursor.getString(dataIdx);
                info.type = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Images.Media.MIME_TYPE));
            
            }
            else
            {
                dataIdx = cursor.getColumnIndex(MediaStore.Video.Media.DATA);
            
                if (dataIdx != -1)
                {
                    info.path = cursor.getString(dataIdx);
                    info.type = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Video.Media.MIME_TYPE));
                }
                else
                {
                    dataIdx = cursor.getColumnIndex(MediaStore.Audio.Media.DATA);
            
                    if (dataIdx != -1)
                    {
                        info.path = cursor.getString(dataIdx);
                        info.type = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.MIME_TYPE));
                    }
                    else
                    {
                        dataIdx = cursor.getColumnIndex(MediaStore.MediaColumns.DATA);
                
                        if (dataIdx != -1)
                        {
                            info.path = cursor.getString(dataIdx);
                            info.type = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.MIME_TYPE));
                          
                        }
                    }
                }
                
               
            }
        }
        
        if (cursor != null)
            cursor.close();
        
        return info;
    }","[('14', 'acquire', 'cursor'), ('16', 'check', 'cursor'), ('63', 'check', 'cursor'), ('64', 'release', 'cursor')]","[(14, 'acquire', 'cursor', 'Cursor'), (63, 'check', 'cursor', 'Cursor'), (64, 'release', 'cursor', 'Cursor')]"
"public void bindChat(long chatId) {
        log(""bind "" + this + "" "" + chatId);
        mLastChatId = chatId;
        
        Uri contactUri = ContentUris.withAppendedId(Imps.Contacts.CONTENT_URI, chatId);
        mCursor = mActivity.getContentResolver().query(contactUri, CHAT_PROJECTION, null, null, null);
        
        if (mCursor == null)
            return;
        
        if (!mCursor.moveToFirst()) {
            if (Log.isLoggable(ImApp.LOG_TAG, Log.DEBUG)) {
                log(""Failed to query chat: "" + chatId);
            }
            mLastChatId = -1;
        } else {
        
            updateContactInfo();
            
            mCurrentChatSession = getChatSession();
            
            if (mCurrentChatSession == null)
                mCurrentChatSession = createChatSession();
            
            if (mCurrentChatSession != null) {
                isServiceUp = true;
                
            }
            
            updateChat();
        }

    }","[('6', 'acquire', 'mCursor'), ('8', 'check', 'mCursor')]","[(6, 'acquire', 'mCursor', 'mCursor'), (8, 'check', 'mCursor', 'mCursor'), (11, 'check', 'mCursor', 'mCursor'), (20, 'acquire', 'mCurrentChatSession', 'mCurrentChatSession'), (22, 'check', 'mCurrentChatSession', 'mCurrentChatSession'), (23, 'acquire', 'mCurrentChatSession', 'mCurrentChatSession'), (25, 'check', 'mCurrentChatSession', 'mCurrentChatSession')]"
"public void bindChat(long chatId) {
        log(""bind "" + this + "" "" + chatId);
        mLastChatId = chatId;
        
        if (mCursor != null && !mCursor.isClosed())
            mCursor.close();
        
        Uri contactUri = ContentUris.withAppendedId(Imps.Contacts.CONTENT_URI, chatId);
        mCursor = mActivity.getContentResolver().query(contactUri, CHAT_PROJECTION, null, null, null);
        
        if (mCursor == null)
            return;
        
        if (!mCursor.moveToFirst()) {
            if (Log.isLoggable(ImApp.LOG_TAG, Log.DEBUG)) {
                log(""Failed to query chat: "" + chatId);
            }
            mLastChatId = -1;
        } else {
        
            updateContactInfo();
            
            mCurrentChatSession = getChatSession();
            
            if (mCurrentChatSession == null)
                mCurrentChatSession = createChatSession();
            
            if (mCurrentChatSession != null) {
                isServiceUp = true;
                
            }
            
            updateChat();
        }

    }","[('5', 'check', 'mCursor'), ('6', 'release', 'mCursor'), ('9', 'acquire', 'mCursor')]","[(5, 'check', 'mCursor', 'mCursor'), (6, 'release', 'mCursor', 'mCursor'), (9, 'acquire', 'mCursor', 'mCursor'), (11, 'check', 'mCursor', 'mCursor'), (25, 'check', 'mCurrentChatSession', 'mCurrentChatSession'), (26, 'acquire', 'mCurrentChatSession', 'mCurrentChatSession'), (28, 'check', 'mCurrentChatSession', 'mCurrentChatSession')]"
"public List<SearchSite> getAvailableSites() {

		// Try to access the TorrentSitesProvider of the Torrent Search app
		Uri uri = Uri.parse(""content://org.transdroid.search.torrentsitesprovider/sites"");
		ContentProviderClient test = context.getContentResolver().acquireContentProviderClient(uri);
		if (test == null) {
			// Torrent Search package is not yet installed
			return null;
		}

		// Query the available in-app torrent search sites
		Cursor cursor = context.getContentResolver().query(uri, null, null, null, null);
		if (cursor == null) {
			// The installed Torrent Search version is corrupt or incompatible
			return null;
		}
		if (cursor.moveToFirst()) {
			List<SearchSite> sites = new ArrayList<SearchSite>();
			do {
				// Read the cursor fields into the SearchSite object
				sites.add(new SearchSite(cursor.getInt(CURSOR_SITE_ID), cursor.getString(CURSOR_SITE_CODE), cursor
						.getString(CURSOR_SITE_NAME), cursor.getString(CURSOR_SITE_RSSURL),
						cursor.getColumnNames().length > 4 ? (cursor.getInt(CURSOR_SITE_ISPRIVATE) == 1 ? true : false)
								: false));
			} while (cursor.moveToNext());
			cursor.close();
			return sites;
		}

		return null;

	}","[('5', 'acquire', 'ContentProviderClient'), ('6', 'check', 'ContentProviderClient'), ('12', 'acquire', 'Cursor'), ('13', 'check', 'Cursor'), ('26', 'release', 'Cursor')]","[(5, 'acquire', 'test', 'ContentProviderClient'), (6, 'check', 'test', 'ContentProviderClient'), (12, 'acquire', 'cursor', 'Cursor'), (13, 'check', 'cursor', 'Cursor'), (17, 'check', 'cursor', 'Cursor'), (26, 'release', 'cursor', 'Cursor')]"
"public List<SearchSite> getAvailableSites() {

		// Try to access the TorrentSitesProvider of the Torrent Search app
		Uri uri = Uri.parse(""content://org.transdroid.search.torrentsitesprovider/sites"");
		ContentProviderClient test = context.getContentResolver().acquireContentProviderClient(uri);
		if (test == null) {
			// Torrent Search package is not yet installed
			return null;
		}

		// Query the available in-app torrent search sites
		Cursor cursor = context.getContentResolver().query(uri, null, null, null, null);
		if (cursor == null) {
			// The installed Torrent Search version is corrupt or incompatible
			return null;
		}
		List<SearchSite> sites = new ArrayList<>();
		if (cursor.moveToFirst()) {
			do {
				// Read the cursor fields into the SearchSite object
				sites.add(new SearchSite(cursor.getInt(CURSOR_SITE_ID), cursor.getString(CURSOR_SITE_CODE), cursor
						.getString(CURSOR_SITE_NAME), cursor.getString(CURSOR_SITE_RSSURL),
						cursor.getColumnNames().length > 4 && cursor.getInt(CURSOR_SITE_ISPRIVATE) == 1));
			} while (cursor.moveToNext());
		}

		cursor.close();
		return sites;

	}","[('5', 'acquire', 'ContentProviderClient'), ('6', 'check', 'ContentProviderClient'), ('12', 'acquire', 'Cursor'), ('13', 'check', 'Cursor'), ('27', 'release', 'Cursor')]","[(5, 'acquire', 'test', 'ContentProviderClient'), (6, 'check', 'test', 'ContentProviderClient'), (12, 'acquire', 'cursor', 'Cursor'), (13, 'check', 'cursor', 'Cursor'), (27, 'release', 'cursor', 'Cursor')]"
"public ArrayList<SearchResult> search(String query, SearchSite site, SearchSortOrder sortBy) {
  // Try to query the TorrentSearchProvider to search for torrents on the web
  Uri uri = Uri.parse(""content://org.transdroid.search.torrentsearchprovider/search/"" + query);
  Cursor cursor;
  if (site == null) {
   // If no explicit site was supplied, rely on the Torrent Search package's default
   cursor = context.getContentResolver().query(uri, null, null, null, sortBy.name());
  } else {
   cursor = context.getContentResolver().query(uri, null, ""SITE = ?"", new String[] { site.getKey() },
     sortBy.name());
  }
  if (cursor == null) {
   // The content provider could not load any content (for example when there is no connection)
   return null;
  }
  if (cursor.moveToFirst()) {
   ArrayList<SearchResult> results = new ArrayList<SearchResult>();
   do {
    // Read the cursor fields into the SearchResult object
    results.add(new SearchResult(cursor.getInt(CURSOR_SEARCH_ID), cursor.getString(CURSOR_SEARCH_NAME),
      cursor.getString(CURSOR_SEARCH_TORRENTURL), cursor.getString(CURSOR_SEARCH_DETAILSURL), cursor
        .getString(CURSOR_SEARCH_SIZE), cursor.getLong(CURSOR_SEARCH_ADDED), cursor
        .getString(CURSOR_SEARCH_SEEDERS), cursor.getString(CURSOR_SEARCH_LEECHERS)));
   } while (cursor.moveToNext());
   cursor.close();
   return results;
  }

  // Torrent Search package is not yet installed

  return null;

 }
","[('7', 'acquire', 'cursor'), ('9', 'acquire', 'cursor'), ('12', 'check', 'cursor'), ('25', 'release', 'cursor')]","[(5, 'check', 'site', 'SearchSite'), (7, 'acquire', 'cursor', 'Cursor'), (9, 'acquire', 'cursor', 'Cursor'), (12, 'check', 'cursor', 'Cursor'), (16, 'check', 'cursor', 'Cursor'), (25, 'release', 'cursor', 'Cursor')]"
"	public ArrayList<SearchResult> search(String query, SearchSite site, SearchSortOrder sortBy) {

		// Try to query the TorrentSearchProvider to search for torrents on the web
		Uri uri = Uri.parse(""content://org.transdroid.search.torrentsearchprovider/search/"" + query);
		Cursor cursor;
		if (site == null) {
			// If no explicit site was supplied, rely on the Torrent Search package's default
			cursor = context.getContentResolver().query(uri, null, null, null, sortBy.name());
		} else {
			cursor = context.getContentResolver().query(uri, null, ""SITE = ?"", new String[] { site.getKey() },
					sortBy.name());
		}
		if (cursor == null) {
			// The content provider could not load any content (for example when there is no connection)
			return null;
		}
		if (cursor.moveToFirst()) {
			ArrayList<SearchResult> results = new ArrayList<>();
			do {
				// Read the cursor fields into the SearchResult object
				results.add(new SearchResult(cursor.getInt(CURSOR_SEARCH_ID), cursor.getString(CURSOR_SEARCH_NAME),
						cursor.getString(CURSOR_SEARCH_TORRENTURL), cursor.getString(CURSOR_SEARCH_DETAILSURL), cursor
								.getString(CURSOR_SEARCH_SIZE), cursor.getLong(CURSOR_SEARCH_ADDED), cursor
								.getString(CURSOR_SEARCH_SEEDERS), cursor.getString(CURSOR_SEARCH_LEECHERS)));
			} while (cursor.moveToNext());
			cursor.close();
			return results;
		}

		// Torrent Search package is not yet installed
		cursor.close();
		return null;

	}
","[('8', 'acquire', 'cursor'), ('10', 'acquire', 'cursor'), ('13', 'check', 'cursor'), ('26', 'release', 'cursor'), ('31', 'release', 'cursor')]","[(6, 'check', 'site', 'SearchSite'), (8, 'acquire', 'cursor', 'Cursor'), (10, 'acquire', 'cursor', 'Cursor'), (13, 'check', 'cursor', 'Cursor'), (17, 'check', 'cursor', 'Cursor'), (26, 'release', 'cursor', 'Cursor'), (31, 'release', 'cursor', 'Cursor')]"
"public ArrayList<Phone> getPhoneNumbers(Context ctxt, String id) {
   ArrayList<Phone> phones = new ArrayList<Phone>();
   
   Cursor pCur = ctxt.getContentResolver().query(
     ContactsContract.CommonDataKinds.Phone.CONTENT_URI, 
     null, 
     ContactsContract.CommonDataKinds.Phone.CONTACT_ID +"" = ?"", 
     new String[]{id}, null);
   while (pCur.moveToNext()) {
    phones.add(new Phone(pCur.getString(pCur.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)), 
      pCur.getString(pCur.getColumnIndex(ContactsContract.CommonDataKinds.Phone.TYPE))
    ));
 
   } 
   pCur.close();
   // Add any custom IM named 'sip' and set its type to 'sip'
        pCur = ctxt.getContentResolver().query(
                ContactsContract.Data.CONTENT_URI, 
                null, 
                ContactsContract.Data.CONTACT_ID + "" = ? AND "" + ContactsContract.Data.MIMETYPE + "" = ?"",
                new String[]{id, ContactsContract.CommonDataKinds.Im.CONTENT_ITEM_TYPE}, null);
        while (pCur.moveToNext()) {
            // Could also use some other IM type but may be confusing. Are there phones with no 'custom' IM type?
            if (pCur.getInt(pCur.getColumnIndex(ContactsContract.CommonDataKinds.Im.PROTOCOL)) == ContactsContract.CommonDataKinds.Im.PROTOCOL_CUSTOM) {
                if (pCur.getString(pCur.getColumnIndex(ContactsContract.CommonDataKinds.Im.CUSTOM_PROTOCOL)).equalsIgnoreCase(""sip"")) {
                    phones.add(new Phone(pCur.getString(pCur.getColumnIndex(ContactsContract.CommonDataKinds.Im.DATA)), ""sip""));
                }
            }
                
        } 
        pCur.close();
        
        // Add any SIP uri if android 9
        if(Compatibility.isCompatible(9)) {
          pCur = ctxt.getContentResolver().query(
                     ContactsContract.Data.CONTENT_URI, 
                     null, 
                     ContactsContract.Data.CONTACT_ID + "" = ? AND "" + ContactsContract.Data.MIMETYPE + "" = ?"",
                     new String[]{id, GINGER_SIP_TYPE}, null);
             while (pCur.moveToNext()) {
                 // Could also use some other IM type but may be confusing. Are there phones with no 'custom' IM type?
              phones.add(new Phone(pCur.getString(pCur.getColumnIndex(ContactsContract.Data.DATA1)), ""sip""));
             } 
        }

   return(phones);
  }","[('4', 'acquire', 'Cursor'), ('15', 'release', 'Cursor'), ('17', 'acquire', 'Cursor'), ('31', 'release', 'Cursor'), ('35', 'acquire', 'Cursor')]","[(4, 'acquire', 'pCur', 'Cursor'), (15, 'release', 'pCur', 'Cursor'), (17, 'acquire', 'pCur', 'Cursor'), (31, 'release', 'pCur', 'Cursor'), (35, 'acquire', 'pCur', 'Cursor')]"
"public ArrayList<Phone> getPhoneNumbers(Context ctxt, String id) {
 		ArrayList<Phone> phones = new ArrayList<Phone>();
 		
 		Cursor pCur = ctxt.getContentResolver().query(
 				ContactsContract.CommonDataKinds.Phone.CONTENT_URI, 
 				null, 
 				ContactsContract.CommonDataKinds.Phone.CONTACT_ID +"" = ?"", 
 				new String[]{id}, null);
 		while (pCur.moveToNext()) {
 			phones.add(new Phone(pCur.getString(pCur.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)), 
 					pCur.getString(pCur.getColumnIndex(ContactsContract.CommonDataKinds.Phone.TYPE))
 			));
 
 		} 
 		pCur.close();

 		// Add any custom IM named 'sip' and set its type to 'sip'
        pCur = ctxt.getContentResolver().query(
                ContactsContract.Data.CONTENT_URI, 
                null, 
                ContactsContract.Data.CONTACT_ID + "" = ? AND "" + ContactsContract.Data.MIMETYPE + "" = ?"",
                new String[]{id, ContactsContract.CommonDataKinds.Im.CONTENT_ITEM_TYPE}, null);
        while (pCur.moveToNext()) {
            // Could also use some other IM type but may be confusing. Are there phones with no 'custom' IM type?
            if (pCur.getInt(pCur.getColumnIndex(ContactsContract.CommonDataKinds.Im.PROTOCOL)) == ContactsContract.CommonDataKinds.Im.PROTOCOL_CUSTOM) {
                if (pCur.getString(pCur.getColumnIndex(ContactsContract.CommonDataKinds.Im.CUSTOM_PROTOCOL)).equalsIgnoreCase(""sip"")) {
                    phones.add(new Phone(pCur.getString(pCur.getColumnIndex(ContactsContract.CommonDataKinds.Im.DATA)), ""sip""));
                }
            }
                
        } 
        pCur.close();
        
        // Add any SIP uri if android 9
        if(Compatibility.isCompatible(9)) {
        	 pCur = ctxt.getContentResolver().query(
                     ContactsContract.Data.CONTENT_URI, 
                     null, 
                     ContactsContract.Data.CONTACT_ID + "" = ? AND "" + ContactsContract.Data.MIMETYPE + "" = ?"",
                     new String[]{id, GINGER_SIP_TYPE}, null);
             while (pCur.moveToNext()) {
                 // Could also use some other IM type but may be confusing. Are there phones with no 'custom' IM type?
            	 phones.add(new Phone(pCur.getString(pCur.getColumnIndex(ContactsContract.Data.DATA1)), ""sip""));
             }
             pCur.close();
        }

 		return(phones);
 	}","[('4', 'acquire', 'Cursor'), ('15', 'release', 'Cursor'), ('18', 'acquire', 'Cursor'), ('32', 'release', 'Cursor'), ('36', 'acquire', 'Cursor'), ('45', 'release', 'Cursor')]","[(4, 'acquire', 'pCur', 'Cursor'), (15, 'release', 'pCur', 'Cursor'), (18, 'acquire', 'pCur', 'Cursor'), (32, 'release', 'pCur', 'Cursor'), (36, 'acquire', 'pCur', 'Cursor'), (45, 'release', 'pCur', 'Cursor')]"
"	@Override
	public void onDestroy() {
		if (myLibrary != null) {
			myLibrary.deactivate();
			myLibrary = null;
		}
		super.onDestroy();
	}
","[('2', 'check', 'myLibrary')]","[(2, 'check', 'myLibrary', 'myLibrary'), (3, 'release', 'myLibrary', 'myLibrary'), (4, 'release', 'myLibrary', 'myLibrary')]"
"	@Override
	public void onDestroy() {
		if (myLibrary != null) {
			final LibraryImplementation l = myLibrary;
			myLibrary = null;
			l.deactivate();
			l.close();
		}
		super.onDestroy();
	}
","[('2', 'check', 'myLibrary'), ('6', 'release', 'l')]","[(2, 'check', 'myLibrary', 'myLibrary'), (5, 'release', 'l', 'LibraryImplementation'), (6, 'release', 'l', 'LibraryImplementation')]"
"	@Override
	protected void closeAllResources() {
	}
",[],[]
"	@Override
	protected void closeAllResources() {
		if (mOpenHelper != null)
			mOpenHelper.close();
	}
","[('2', 'check', 'mOpenHelper'), ('3', 'release', 'mOpenHelper')]","[(2, 'check', 'mOpenHelper', 'mOpenHelper'), (3, 'release', 'mOpenHelper', 'mOpenHelper')]"
"    private void releaseMediaRecorder() {
        Log.v(TAG, ""Releasing media recorder."");
        if (mMediaRecorder != null) {
            mMediaRecorder.reset();
            mMediaRecorder.release();
            mMediaRecorder = null;
        }
    }
","[('3', 'check', 'mMediaRecorder'), ('5', 'release', 'mMediaRecorder')]","[(3, 'check', 'mMediaRecorder', 'mMediaRecorder'), (4, 'release', 'mMediaRecorder', 'mMediaRecorder'), (5, 'release', 'mMediaRecorder', 'mMediaRecorder')]"
"private void releaseMediaRecorder() {
        Log.v(TAG, ""Releasing media recorder."");
        if (mMediaRecorder != null) {
            mMediaRecorder.reset();
            if (mCamera != null) {
	        	if (Integer.parseInt(Build.VERSION.SDK) >= 8)
	        		VideoCameraNew2.reconnect(mCamera);
	        	mCamera.release();
	        	mCamera = null;
            }
            mMediaRecorder.release();
            mMediaRecorder = null;
        }
    }","[('3', 'check', 'mMediaRecorder'), ('5', 'check', 'mCamera'), ('7', 'acquire', 'mCamera'), ('8', 'release', 'mCamera'), ('11', 'release', 'mMediaRecorder')]","[(3, 'check', 'mMediaRecorder', 'mMediaRecorder'), (4, 'release', 'mMediaRecorder', 'mMediaRecorder'), (5, 'check', 'mCamera', 'mCamera'), (8, 'release', 'mCamera', 'mCamera'), (11, 'release', 'mMediaRecorder', 'mMediaRecorder')]"
"
    public void onDestroy() {
        super.onDestroy();
        ((LocationManager)getSystemService(Context.LOCATION_SERVICE))
                .removeUpdates(new DeviceLocationListener());
    }","[('3', 'acquire', 'locListener')]","[(4, 'release', 'LocationManager', 'LocationManager')]"
"    public void onPause() {
        super.onPause();
        locListener.stop();
    }
    public void onDestroy() {
        super.onDestroy();
        locListener.stop();
    }","[('3', 'release', 'locListener')]",[]
" @Override
 protected void onDestroy() {
  super.onDestroy();

  getLocationManager().removeUpdates(mLocationListener);

  if (this.mDoGPSRecordingAndContributing) {
   OSMUploader.uploadAsync(this.mRouteRecorder.getRecordedGeoPoints());
  }

 }",[],"[(4, 'release', 'mLocationListener', 'mLocationListener')]"
"	@Override
	protected void onPause() {
		getLocationManager().removeUpdates(mLocationListener);

		if (this.mDoGPSRecordingAndContributing) {
			OSMUploader.uploadAsync(this.mRouteRecorder.getRecordedGeoPoints());
		}

		super.onResume();
	}
",[],[]
"                @Override
                public void surfaceDestroyed(SurfaceHolder surfaceHolder) {

                }
",[],[]
"                @Override
                public void surfaceDestroyed(SurfaceHolder surfaceHolder) {
                    if(player != null) {
                        player.stop();
                        player.release();
                        player = null;
                    }
                }
","[('2', 'check', 'player'), ('4', 'release', 'player')]","[(2, 'check', 'player', 'player'), (4, 'release', 'player', 'player')]"
"                 @Override
                public void surfaceDestroyed(SurfaceHolder surfaceHolder) {
                    if(player != null) {
                        player.stop();

                        player.release();
                        player = null;
                    }
                }",[],"[(2, 'check', 'player', 'player'), (5, 'release', 'player', 'player')]"
"    @Override
    public void onPause() {
        super.onPause();
        if(player != null) {
            try {
                player.stop();
            } catch (IllegalStateException e) {
            }
            player.release();
            player = null;
        }
    } 
 @Override
                public void surfaceDestroyed(SurfaceHolder surfaceHolder) {
                    if(player != null) {
                        try {
                            player.stop();
                        } catch (IllegalStateException e) {
                        }
                        player.release();
                        player = null;
                    }
                }
",[],"[(3, 'check', 'player', 'player'), (8, 'release', 'player', 'player'), (13, 'check', 'player', 'player'), (18, 'release', 'player', 'player')]"
"private String getCookie(String url) {
      String cookie = CookieManager.getInstance().getCookie(url);
      if (cookie == null || cookie.length() == 0) {
        Log.v(TAG, ""Book Search cookie was missing or expired"");
        HttpHead head = new HttpHead(url);
        AndroidHttpClient client = AndroidHttpClient.newInstance(mUserAgent);
        try {
          HttpResponse response = client.execute(head);
          if (response.getStatusLine().getStatusCode() == 200) {
            Header[] cookies = response.getHeaders(""set-cookie"");
            for (int x = 0; x < cookies.length; x++) {
              CookieManager.getInstance().setCookie(url, cookies[x].getValue());
            }
            CookieSyncManager.getInstance().sync();
            cookie = CookieManager.getInstance().getCookie(url);
          }
        } catch (IOException e) {
          Log.e(TAG, e.toString());
        }
      }
      return cookie;
    }","[('6', 'acquire', 'client')]","[(6, 'acquire', 'client', 'AndroidHttpClient')]"
"private String getCookie(String url) {
      String cookie = CookieManager.getInstance().getCookie(url);
      if (cookie == null || cookie.length() == 0) {
        Log.v(TAG, ""Book Search cookie was missing or expired"");
        HttpHead head = new HttpHead(url);
        AndroidHttpClient client = AndroidHttpClient.newInstance(mUserAgent);
        try {
          HttpResponse response = client.execute(head);
          if (response.getStatusLine().getStatusCode() == 200) {
            Header[] cookies = response.getHeaders(""set-cookie"");
            for (int x = 0; x < cookies.length; x++) {
              CookieManager.getInstance().setCookie(url, cookies[x].getValue());
            }
            CookieSyncManager.getInstance().sync();
            cookie = CookieManager.getInstance().getCookie(url);
          }
        } catch (IOException e) {
          Log.e(TAG, e.toString());
        }
        client.close();
      }
      return cookie;
    }","[('6', 'acquire', 'client'), ('20', 'release', 'client')]","[(5, 'acquire', 'head', 'HttpHead'), (6, 'acquire', 'client', 'AndroidHttpClient'), (20, 'release', 'client', 'AndroidHttpClient')]"
"public void removeHandler(Handler handler) {
  handlers.remove(handler);
  if(handlers.isEmpty()){
   if(shutdownTimer == null) {
    shutdownTimer = new Timer();
    SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(IRCCloudApplication.getInstance().getApplicationContext());
    long timeout = Long.valueOf(prefs.getString(""timeout"", ""300000""));
    shutdownTimer.schedule( new TimerTask(){
               public void run() {
                if(handlers.isEmpty()) {
                    disconnect();
                }
                   shutdownTimer = null;
                }
             }, timeout);
   }
   if(idleTimer != null && state != STATE_CONNECTED) {
    idleTimer.cancel();
    idleTimer = null;
    state = STATE_DISCONNECTED;
   }
  }
 }",[],"[(4, 'check', 'shutdownTimer', 'shutdownTimer'), (5, 'acquire', 'shutdownTimer', 'shutdownTimer'), (6, 'acquire', 'prefs', 'SharedPreferences'), (13, 'release', 'shutdownTimer', 'shutdownTimer'), (17, 'check', 'idleTimer', 'idleTimer'), (18, 'acquire', 'idleTimer', 'idleTimer'), (19, 'release', 'idleTimer', 'idleTimer')]"
"public void removeHandler(Handler handler) {
  handlers.remove(handler);
  if(handlers.isEmpty()){
   if(shutdownTimer == null) {
    shutdownTimer = new Timer();
    SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(IRCCloudApplication.getInstance().getApplicationContext());
    long timeout = Long.valueOf(prefs.getString(""timeout"", ""300000""));
    shutdownTimer.schedule( new TimerTask(){
               public void run() {
                if(handlers.isEmpty()) {
                    disconnect();
                }
                   shutdownTimer = null;
                }
             }, timeout);
   }
   if(idleTimer != null && state != STATE_CONNECTED) {
    idleTimer.cancel();
    idleTimer = null;
                failCount = 0;
                if(wifiLock.isHeld())
                    wifiLock.release();
                reconnect_timestamp = 0;
    state = STATE_DISCONNECTED;
   }
  }
 }","[('21', 'check', 'wifiLock'), ('22', 'release', 'wifiLock')]","[(4, 'check', 'shutdownTimer', 'shutdownTimer'), (5, 'acquire', 'shutdownTimer', 'shutdownTimer'), (6, 'acquire', 'prefs', 'SharedPreferences'), (13, 'release', 'shutdownTimer', 'shutdownTimer'), (17, 'check', 'idleTimer', 'idleTimer'), (19, 'release', 'idleTimer', 'idleTimer'), (21, 'acquire', 'wifiLock', 'wifiLock'), (21, 'check', 'wifiLock', 'wifiLock'), (22, 'release', 'wifiLock', 'wifiLock')]"
"public static void testParcel() throws Exception {
        final Image image1 = new Image.Builder().setUrl(FILE1).setTitle(""Title1"").setDescription(""Description1"").build();

        final Parcel parcel = Parcel.obtain();
        image1.writeToParcel(parcel, 0);
        parcel.setDataPosition(0);

        final Image image2 = Image.CREATOR.createFromParcel(parcel);

        assertThat(image1).isEqualTo(image2);
    }","[('4', 'acquire', 'parcel')]","[(4, 'acquire', 'parcel', 'Parcel')]"
"public static void testParcel() throws Exception {
        final Image image1 = new Image.Builder().setUrl(FILE1).setTitle(""Title1"").setDescription(""Description1"").build();

        final Parcel parcel = Parcel.obtain();
        image1.writeToParcel(parcel, 0);
        parcel.setDataPosition(0);

        final Image image2 = Image.CREATOR.createFromParcel(parcel);

        assertThat(image1).isEqualTo(image2);
        parcel.recycle();
    }","[('4', 'acquire', 'Parcel'), ('11', 'release', 'Parcel')]","[(2, 'acquire', 'image1', 'Image'), (4, 'acquire', 'parcel', 'Parcel'), (8, 'acquire', 'image2', 'Image'), (11, 'release', 'parcel', 'Parcel')]"
"public Intent executeApi(Intent data, InputStream is, OutputStream os) {

        try {
            data.putExtra(EXTRA_API_VERSION, OpenPgpApi.API_VERSION);

            Intent result = null;
            if (ACTION_GET_KEY_IDS.equals(data.getAction())) {
                result = mService.execute(data, null, null);
                return result;
            } else {
                // pipe the input and output
                ParcelFileDescriptor input = ParcelFileDescriptorUtil.pipeFrom(is,
    
                        new ParcelFileDescriptorUtil.IThreadListener() {

                            @Override
                            public void onThreadFinished(Thread thread) {
                                //Log.d(OpenPgpApi.TAG, ""Copy to service finished"");
                            }
                        });
                ParcelFileDescriptor output = ParcelFileDescriptorUtil.pipeTo(os,
                        new ParcelFileDescriptorUtil.IThreadListener() {
                            @Override
                            public void onThreadFinished(Thread thread) {
                                //Log.d(OpenPgpApi.TAG, ""Service finished writing!"");
                            }
                        });
                // blocks until result is ready
                result = mService.execute(data, input, output);
                // close() is required to halt the TransferThread
                output.close();
                // set class loader to current context to allow unparcelling
                // of OpenPgpError and OpenPgpSignatureResult
                // http://stackoverflow.com/a/3806769
                result.setExtrasClassLoader(mContext.getClassLoader());
                return result;
            }
        } catch (Exception e) {
            Log.e(OpenPgpApi.TAG, ""Exception"", e);
            Intent result = new Intent();
            result.putExtra(RESULT_CODE, RESULT_CODE_ERROR);
            result.putExtra(RESULT_ERROR,
                    new OpenPgpError(OpenPgpError.CLIENT_SIDE_ERROR, e.getMessage()));
            return result;
        }
    }",[],"[(12, 'acquire', 'input', 'ParcelFileDescriptor'), (21, 'acquire', 'output', 'ParcelFileDescriptor'), (31, 'release', 'output', 'ParcelFileDescriptor')]"
"public Intent executeApi(Intent data, InputStream is, OutputStream os) {
        ParcelFileDescriptor input = null;
        try {
            data.putExtra(EXTRA_API_VERSION, OpenPgpApi.API_VERSION);

            Intent result = null;

            if (ACTION_GET_KEY_IDS.equals(data.getAction())) {
                result = mService.execute(data, null, null);
                return result;
            } else {
                // pipe the input and output
                input = ParcelFileDescriptorUtil.pipeFrom(is,
                        new ParcelFileDescriptorUtil.IThreadListener() {

                            @Override
                            public void onThreadFinished(Thread thread) {
                                //Log.d(OpenPgpApi.TAG, ""Copy to service finished"");
                            }
                        });
                ParcelFileDescriptor output = ParcelFileDescriptorUtil.pipeTo(os,
                        new ParcelFileDescriptorUtil.IThreadListener() {

                            @Override
                            public void onThreadFinished(Thread thread) {
                                //Log.d(OpenPgpApi.TAG, ""Service finished writing!"");
                            }
                        });

                // blocks until result is ready
                result = mService.execute(data, input, output);
                // close() is required to halt the TransferThread
                output.close();

                // set class loader to current context to allow unparcelling
                // of OpenPgpError and OpenPgpSignatureResult
                // http://stackoverflow.com/a/3806769
                result.setExtrasClassLoader(mContext.getClassLoader());

                return result;
            }
        } catch (Exception e) {
            Log.e(OpenPgpApi.TAG, ""Exception"", e);
            Intent result = new Intent();
            result.putExtra(RESULT_CODE, RESULT_CODE_ERROR);
            result.putExtra(RESULT_ERROR,
                    new OpenPgpError(OpenPgpError.CLIENT_SIDE_ERROR, e.getMessage()));
            return result;
        } finally {
            if (input != null) {
                try {
                    input.close();
                } catch (IOException e) {
                    Log.e(OpenPgpApi.TAG, ""Failed to close input file descriptor"", e);
                }
            }
        }
    }",[],"[(13, 'acquire', 'input', 'ParcelFileDescriptor'), (21, 'acquire', 'output', 'ParcelFileDescriptor'), (33, 'release', 'output', 'ParcelFileDescriptor'), (50, 'check', 'input', 'ParcelFileDescriptor'), (52, 'release', 'input', 'ParcelFileDescriptor')]"
"public void checkMail(final Context context, final Account account, 
            final boolean ignoreLastCheckedTime,
            final boolean useManualWakeLock,
            final MessagingListener listener) {
    	
      if (useManualWakeLock) {
        PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
        WakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""Email"");
        wakeLock.setReferenceCounted(false);
        wakeLock.acquire(Email.MANUAL_WAKE_LOCK_TIMEOUT);
      }
      
      
        for (MessagingListener l : getListeners()) {
            l.checkMailStarted(context, account);
        }
        put(""checkMail"", listener, new Runnable() {
            public void run() {

                final NotificationManager notifMgr = (NotificationManager)context
                  .getSystemService(Context.NOTIFICATION_SERVICE);
            	  try
            	  {
	              	Log.i(Email.LOG_TAG, ""Starting mail check"");
          				Preferences prefs = Preferences.getPreferences(context);

	                Account[] accounts;
	                if (account != null) {
	                    accounts = new Account[] {
	                        account
	                    };
	                } else {
	                    accounts = prefs.getAccounts();
	                }

	                for (final Account account : accounts) {
	                  	final long accountInterval = account.getAutomaticCheckIntervalMinutes() * 60 * 1000;
	                  	if (ignoreLastCheckedTime == false && accountInterval <= 0)
	                  	{
		                  	if (Config.LOGV || true)
		                  	{
		                  		Log.v(Email.LOG_TAG, ""Skipping synchronizing account "" + account.getDescription());
		                  	}

	                  		continue;
	                  	}

	                  	if (Config.LOGV || true)
	                  	{
	                  		Log.v(Email.LOG_TAG, ""Synchronizing account "" + account.getDescription());
	                  	}
                    	putBackground(""sendPending "" + account.getDescription(), null, new Runnable() {
                        public void run() {
                          if (account.isShowOngoing()) {
                            Notification notif = new Notification(R.drawable.ic_menu_refresh, 
                                context.getString(R.string.notification_bg_send_ticker, account.getDescription()), System.currentTimeMillis());                         
                            // JRV XXX TODO - do we want to notify MessageList too? 
                            Intent intent = FolderList.actionHandleAccountIntent(context, account, Email.INBOX);
                            PendingIntent pi = PendingIntent.getActivity(context, 0, intent, 0);
                              notif.setLatestEventInfo(context, context.getString(R.string.notification_bg_send_title), 
                                  account.getDescription() , pi);
                              notif.flags = Notification.FLAG_ONGOING_EVENT;
                              
                              if (Email.NOTIFICATION_LED_WHILE_SYNCING) {
                                notif.flags |= Notification.FLAG_SHOW_LIGHTS;
                                notif.ledARGB = Email.NOTIFICATION_LED_DIM_COLOR;
                                notif.ledOnMS = Email.NOTIFICATION_LED_FAST_ON_TIME;
                                notif.ledOffMS = Email.NOTIFICATION_LED_FAST_OFF_TIME;
                              }
                              
                              notifMgr.notify(Email.FETCHING_EMAIL_NOTIFICATION_ID, notif);
                          }
                          try
                          {
                            sendPendingMessagesSynchronous(account);
                          }
                        	finally {
                        	  if (account.isShowOngoing()) {
                        	    notifMgr.cancel(Email.FETCHING_EMAIL_NOTIFICATION_ID);
                        	  }
                          }
                        }
                    	}
                    	);
	                    try
	                    {
	                    	Account.FolderMode aDisplayMode = account.getFolderDisplayMode();
	                    	Account.FolderMode aSyncMode = account.getFolderSyncMode();

		                    Store localStore = Store.getInstance(account.getLocalStoreUri(), mApplication);
		                    for (final Folder folder : localStore.getPersonalNamespaces())
		                    {
		                    	
		                    	folder.open(Folder.OpenMode.READ_WRITE);
		                    	folder.refresh(prefs);
		                    	
		                    	Folder.FolderClass fDisplayMode = folder.getDisplayClass();
		                    	Folder.FolderClass fSyncMode = folder.getSyncClass();

		                    	if ((aDisplayMode == Account.FolderMode.FIRST_CLASS && 
		                    					fDisplayMode != Folder.FolderClass.FIRST_CLASS) 
		                    			|| (aDisplayMode == Account.FolderMode.FIRST_AND_SECOND_CLASS &&
		                      					fDisplayMode != Folder.FolderClass.FIRST_CLASS &&
		                      					fDisplayMode != Folder.FolderClass.SECOND_CLASS) 
		                      		|| (aDisplayMode == Account.FolderMode.NOT_SECOND_CLASS &&
		                      					fDisplayMode == Folder.FolderClass.SECOND_CLASS))
		                      {
		                    		// Never sync a folder that isn't displayed
			                    	if (Config.LOGV) {
			                    		Log.v(Email.LOG_TAG, ""Not syncing folder "" + folder.getName() + 
			                    				"" which is in display mode "" + fDisplayMode + "" while account is in display mode "" + aDisplayMode);
			                    	}

		                       	continue;
		                      }

		                    	if ((aSyncMode == Account.FolderMode.FIRST_CLASS && 
		                    			fSyncMode != Folder.FolderClass.FIRST_CLASS)
		                    			|| (aSyncMode == Account.FolderMode.FIRST_AND_SECOND_CLASS &&
		                      					fSyncMode != Folder.FolderClass.FIRST_CLASS &&
		                      					fSyncMode != Folder.FolderClass.SECOND_CLASS) 
		                    			|| (aSyncMode == Account.FolderMode.NOT_SECOND_CLASS &&
		                    					fSyncMode == Folder.FolderClass.SECOND_CLASS))
		                      {
		                    		// Do not sync folders in the wrong class
			                    	if (Config.LOGV) {
			                    		Log.v(Email.LOG_TAG, ""Not syncing folder "" + folder.getName() + 
			                    				"" which is in sync mode "" + fSyncMode + "" while account is in sync mode "" + aSyncMode);
			                    	}

		                       	continue;
		                      }
	                    	
		                    	
	
		                    	if (Config.LOGV) {
		                    		Log.v(Email.LOG_TAG, ""Folder "" + folder.getName() + "" was last synced @ "" +
		                    				new Date(folder.getLastChecked()));
		                    	}
		                    	
		                    	if (ignoreLastCheckedTime == false && folder.getLastChecked() > 
		                    		(System.currentTimeMillis() - accountInterval))
		                    	{
			                    		if (Config.LOGV) {
			                    			Log.v(Email.LOG_TAG, ""Not syncing folder "" + folder.getName()
			                    					+ "", previously synced @ "" + new Date(folder.getLastChecked())
			                    							+ "" which would be too recent for the account period"");
			                    		}					

		                    			continue;
		                    	}
		                    	putBackground(""sync"" + folder.getName(), null, new Runnable() {
		                        public void run() {
				                    	try {
				                    		// In case multiple Commands get enqueued, don't run more than
				                    		// once
				                    		final LocalStore localStore =
				                          (LocalStore) Store.getInstance(account.getLocalStoreUri(), mApplication);
				                    		LocalFolder tLocalFolder = (LocalFolder) localStore.getFolder(folder.getName());
				                    		tLocalFolder.open(Folder.OpenMode.READ_WRITE);
				                    						                    		
				                    		if (ignoreLastCheckedTime == false && tLocalFolder.getLastChecked() > 
				                    			    (System.currentTimeMillis() - accountInterval))
				                    		{
				                    			if (Config.LOGV) {
					                    			Log.v(Email.LOG_TAG, ""Not running Command for folder "" + folder.getName()
					                    					+ "", previously synced @ "" + new Date(folder.getLastChecked())
					                    							+ "" which would be too recent for the account period"");
				                    			}
				                    			return;
				                    		}
				                    		if (account.isShowOngoing()) {
  				                    		Notification notif = new Notification(R.drawable.ic_menu_refresh, 
  				                    		    context.getString(R.string.notification_bg_sync_ticker, account.getDescription(), folder.getName()), 
  				                    		    System.currentTimeMillis());                         
                                      // JRV XXX TODO - do we want to notify MessageList too? 
  			                          Intent intent = FolderList.actionHandleAccountIntent(context, account, Email.INBOX);
  			                          PendingIntent pi = PendingIntent.getActivity(context, 0, intent, 0);
  			                            notif.setLatestEventInfo(context, context.getString(R.string.notification_bg_sync_title), account.getDescription()
  			                                + context.getString(R.string.notification_bg_title_separator) + folder.getName(), pi);
  			                            notif.flags = Notification.FLAG_ONGOING_EVENT;
  			                            if (Email.NOTIFICATION_LED_WHILE_SYNCING) {
    			                            notif.flags |= Notification.FLAG_SHOW_LIGHTS;
    			                            notif.ledARGB = Email.NOTIFICATION_LED_DIM_COLOR;
    			                            notif.ledOnMS = Email.NOTIFICATION_LED_FAST_ON_TIME;
    			                            notif.ledOffMS = Email.NOTIFICATION_LED_FAST_OFF_TIME;
  			                            }
  
  			                            notifMgr.notify(Email.FETCHING_EMAIL_NOTIFICATION_ID, notif);
				                    		}
			                          try
			                          {
			                            synchronizeMailboxSynchronous(account, folder.getName());
			                          }
				                    	  
		                            finally {
		                              if (account.isShowOngoing()) {
		                                notifMgr.cancel(Email.FETCHING_EMAIL_NOTIFICATION_ID);
		                              }
		                            }
				                    	}
				                    	catch (Exception e)
				                    	{
				                    		
				                    		Log.e(Email.LOG_TAG, ""Exception while processing folder "" + 
				                    				account.getDescription() + "":"" + folder.getName(), e);
				                    		addErrorMessage(account, e);
				                    	}
		                        }
		                    	}
		                    	);
		                    } 
	                    }
	                    catch (MessagingException e) {
	                      Log.e(Email.LOG_TAG, ""Unable to synchronize account "" + account.getName(), e);
	                      addErrorMessage(account, e);
	                    }
	                }
            	  }
            	  catch (Exception e)
            	  {
            	  	 Log.e(Email.LOG_TAG, ""Unable to synchronize mail"", e);
            	  	 addErrorMessage(account, e);
            	  }
              	putBackground(""finalize sync"", null, new Runnable() {
                  public void run() {

		            	  Log.i(Email.LOG_TAG, ""Finished mail sync"");
		             	 
		                for (MessagingListener l : getListeners()) {
		                    l.checkMailFinished(context, account);
		                }
		                
                  }
              	}
              	);
            }
        });
    }",[],"[(8, 'acquire', 'wakeLock', 'WakeLock'), (10, 'acquire', 'wakeLock', 'WakeLock'), (28, 'check', 'account', 'Account')]"
"public void checkMail(final Context context, final Account account, 
            final boolean ignoreLastCheckedTime,
            final boolean useManualWakeLock,
            final MessagingListener listener) {
        
      WakeLock twakeLock = null;
      if (useManualWakeLock) {
        PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
        twakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""Email"");
        twakeLock.setReferenceCounted(false);
        twakeLock.acquire(Email.MANUAL_WAKE_LOCK_TIMEOUT);
      }
      final WakeLock wakeLock = twakeLock;
      
        for (MessagingListener l : getListeners()) {
            l.checkMailStarted(context, account);
        }
        put(""checkMail"", listener, new Runnable() {
            public void run() {

                final NotificationManager notifMgr = (NotificationManager)context
                  .getSystemService(Context.NOTIFICATION_SERVICE);
            	  try
            	  {
	              	Log.i(Email.LOG_TAG, ""Starting mail check"");
          				Preferences prefs = Preferences.getPreferences(context);

	                Account[] accounts;
	                if (account != null) {
	                    accounts = new Account[] {
	                        account
	                    };
	                } else {
	                    accounts = prefs.getAccounts();
	                }

	                for (final Account account : accounts) {
	                  	final long accountInterval = account.getAutomaticCheckIntervalMinutes() * 60 * 1000;
	                  	if (ignoreLastCheckedTime == false && accountInterval <= 0)
	                  	{
		                  	if (Config.LOGV || true)
		                  	{
		                  		Log.v(Email.LOG_TAG, ""Skipping synchronizing account "" + account.getDescription());
		                  	}

	                  		continue;
	                  	}

	                  	if (Config.LOGV || true)
	                  	{
	                  		Log.v(Email.LOG_TAG, ""Synchronizing account "" + account.getDescription());
	                  	}
                    	putBackground(""sendPending "" + account.getDescription(), null, new Runnable() {
                        public void run() {
                          if (account.isShowOngoing()) {
                            Notification notif = new Notification(R.drawable.ic_menu_refresh, 
                                context.getString(R.string.notification_bg_send_ticker, account.getDescription()), System.currentTimeMillis());                         
                            // JRV XXX TODO - do we want to notify MessageList too? 
                            Intent intent = FolderList.actionHandleAccountIntent(context, account, Email.INBOX);
                            PendingIntent pi = PendingIntent.getActivity(context, 0, intent, 0);
                              notif.setLatestEventInfo(context, context.getString(R.string.notification_bg_send_title), 
                                  account.getDescription() , pi);
                              notif.flags = Notification.FLAG_ONGOING_EVENT;
                              
                              if (Email.NOTIFICATION_LED_WHILE_SYNCING) {
                                notif.flags |= Notification.FLAG_SHOW_LIGHTS;
                                notif.ledARGB = Email.NOTIFICATION_LED_DIM_COLOR;
                                notif.ledOnMS = Email.NOTIFICATION_LED_FAST_ON_TIME;
                                notif.ledOffMS = Email.NOTIFICATION_LED_FAST_OFF_TIME;
                              }
                              
                              notifMgr.notify(Email.FETCHING_EMAIL_NOTIFICATION_ID, notif);
                          }
                          try
                          {
                            sendPendingMessagesSynchronous(account);
                          }
                        	finally {
                        	  if (account.isShowOngoing()) {
                        	    notifMgr.cancel(Email.FETCHING_EMAIL_NOTIFICATION_ID);
                        	  }
                          }
                        }
                    	}
                    	);
	                    try
	                    {
	                    	Account.FolderMode aDisplayMode = account.getFolderDisplayMode();
	                    	Account.FolderMode aSyncMode = account.getFolderSyncMode();

		                    Store localStore = Store.getInstance(account.getLocalStoreUri(), mApplication);
		                    for (final Folder folder : localStore.getPersonalNamespaces())
		                    {
		                    	
		                    	folder.open(Folder.OpenMode.READ_WRITE);
		                    	folder.refresh(prefs);
		                    	
		                    	Folder.FolderClass fDisplayMode = folder.getDisplayClass();
		                    	Folder.FolderClass fSyncMode = folder.getSyncClass();

		                    	if ((aDisplayMode == Account.FolderMode.FIRST_CLASS && 
		                    					fDisplayMode != Folder.FolderClass.FIRST_CLASS) 
		                    			|| (aDisplayMode == Account.FolderMode.FIRST_AND_SECOND_CLASS &&
		                      					fDisplayMode != Folder.FolderClass.FIRST_CLASS &&
		                      					fDisplayMode != Folder.FolderClass.SECOND_CLASS) 
		                      		|| (aDisplayMode == Account.FolderMode.NOT_SECOND_CLASS &&
		                      					fDisplayMode == Folder.FolderClass.SECOND_CLASS))
		                      {
		                    		// Never sync a folder that isn't displayed
			                    	if (Config.LOGV) {
			                    		Log.v(Email.LOG_TAG, ""Not syncing folder "" + folder.getName() + 
			                    				"" which is in display mode "" + fDisplayMode + "" while account is in display mode "" + aDisplayMode);
			                    	}

		                       	continue;
		                      }

		                    	if ((aSyncMode == Account.FolderMode.FIRST_CLASS && 
		                    			fSyncMode != Folder.FolderClass.FIRST_CLASS)
		                    			|| (aSyncMode == Account.FolderMode.FIRST_AND_SECOND_CLASS &&
		                      					fSyncMode != Folder.FolderClass.FIRST_CLASS &&
		                      					fSyncMode != Folder.FolderClass.SECOND_CLASS) 
		                    			|| (aSyncMode == Account.FolderMode.NOT_SECOND_CLASS &&
		                    					fSyncMode == Folder.FolderClass.SECOND_CLASS))
		                      {
		                    		// Do not sync folders in the wrong class
			                    	if (Config.LOGV) {
			                    		Log.v(Email.LOG_TAG, ""Not syncing folder "" + folder.getName() + 
			                    				"" which is in sync mode "" + fSyncMode + "" while account is in sync mode "" + aSyncMode);
			                    	}

		                       	continue;
		                      }
	                    	
		                    	
	
		                    	if (Config.LOGV) {
		                    		Log.v(Email.LOG_TAG, ""Folder "" + folder.getName() + "" was last synced @ "" +
		                    				new Date(folder.getLastChecked()));
		                    	}
		                    	
		                    	if (ignoreLastCheckedTime == false && folder.getLastChecked() > 
		                    		(System.currentTimeMillis() - accountInterval))
		                    	{
			                    		if (Config.LOGV) {
			                    			Log.v(Email.LOG_TAG, ""Not syncing folder "" + folder.getName()
			                    					+ "", previously synced @ "" + new Date(folder.getLastChecked())
			                    							+ "" which would be too recent for the account period"");
			                    		}					

		                    			continue;
		                    	}
		                    	putBackground(""sync"" + folder.getName(), null, new Runnable() {
		                        public void run() {
				                    	try {
				                    		// In case multiple Commands get enqueued, don't run more than
				                    		// once
				                    		final LocalStore localStore =
				                          (LocalStore) Store.getInstance(account.getLocalStoreUri(), mApplication);
				                    		LocalFolder tLocalFolder = (LocalFolder) localStore.getFolder(folder.getName());
				                    		tLocalFolder.open(Folder.OpenMode.READ_WRITE);
				                    						                    		
				                    		if (ignoreLastCheckedTime == false && tLocalFolder.getLastChecked() > 
				                    			    (System.currentTimeMillis() - accountInterval))
				                    		{
				                    			if (Config.LOGV) {
					                    			Log.v(Email.LOG_TAG, ""Not running Command for folder "" + folder.getName()
					                    					+ "", previously synced @ "" + new Date(folder.getLastChecked())
					                    							+ "" which would be too recent for the account period"");
				                    			}
				                    			return;
				                    		}
				                    		if (account.isShowOngoing()) {
  				                    		Notification notif = new Notification(R.drawable.ic_menu_refresh, 
  				                    		    context.getString(R.string.notification_bg_sync_ticker, account.getDescription(), folder.getName()), 
  				                    		    System.currentTimeMillis());                         
                                      // JRV XXX TODO - do we want to notify MessageList too? 
  			                          Intent intent = FolderList.actionHandleAccountIntent(context, account, Email.INBOX);
  			                          PendingIntent pi = PendingIntent.getActivity(context, 0, intent, 0);
  			                            notif.setLatestEventInfo(context, context.getString(R.string.notification_bg_sync_title), account.getDescription()
  			                                + context.getString(R.string.notification_bg_title_separator) + folder.getName(), pi);
  			                            notif.flags = Notification.FLAG_ONGOING_EVENT;
  			                            if (Email.NOTIFICATION_LED_WHILE_SYNCING) {
    			                            notif.flags |= Notification.FLAG_SHOW_LIGHTS;
    			                            notif.ledARGB = Email.NOTIFICATION_LED_DIM_COLOR;
    			                            notif.ledOnMS = Email.NOTIFICATION_LED_FAST_ON_TIME;
    			                            notif.ledOffMS = Email.NOTIFICATION_LED_FAST_OFF_TIME;
  			                            }
  
  			                            notifMgr.notify(Email.FETCHING_EMAIL_NOTIFICATION_ID, notif);
				                    		}
			                          try
			                          {
			                            synchronizeMailboxSynchronous(account, folder.getName());
			                          }
				                    	  
		                            finally {
		                              if (account.isShowOngoing()) {
		                                notifMgr.cancel(Email.FETCHING_EMAIL_NOTIFICATION_ID);
		                              }
		                            }
				                    	}
				                    	catch (Exception e)
				                    	{
				                    		
				                    		Log.e(Email.LOG_TAG, ""Exception while processing folder "" + 
				                    				account.getDescription() + "":"" + folder.getName(), e);
				                    		addErrorMessage(account, e);
				                    	}
		                        }
		                    	}
		                    	);
		                    } 
	                    }
	                    catch (MessagingException e) {
	                      Log.e(Email.LOG_TAG, ""Unable to synchronize account "" + account.getName(), e);
	                      addErrorMessage(account, e);
	                    }
	                }
            	  }
            	  catch (Exception e)
            	  {
            	  	 Log.e(Email.LOG_TAG, ""Unable to synchronize mail"", e);
            	  	 addErrorMessage(account, e);
            	  }
              	putBackground(""finalize sync"", null, new Runnable() {
                  public void run() {

		            	  Log.i(Email.LOG_TAG, ""Finished mail sync"");
		            	  if (wakeLock != null)
		            	  {
		            	      wakeLock.release();
		            	  }
		                for (MessagingListener l : getListeners()) {
		                    l.checkMailFinished(context, account);
		                }
		                
                  }
              	}
              	);
            }
        });
    }",[],"[(9, 'acquire', 'twakeLock', 'WakeLock'), (11, 'acquire', 'twakeLock', 'WakeLock'), (29, 'check', 'account', 'Account'), (230, 'check', 'wakeLock', 'WakeLock'), (232, 'release', 'wakeLock', 'WakeLock')]"
"@Override
	protected void onHandleIntent(final Intent intent) {
		if (intent == null) {
			Log.w(TAG, ""onHandleIntent(null)"");
			return;
		}
		final String a = intent.getAction();
		Log.d(TAG, ""onHandleIntent("" + a + "")"");

		final PowerManager pm = (PowerManager) this
				.getSystemService(Context.POWER_SERVICE);
		final PowerManager.WakeLock wakelock = pm.newWakeLock(
				PowerManager.PARTIAL_WAKE_LOCK, TAG);
		wakelock.acquire();
		Log.i(TAG, ""got wakelock"");

		if (a != null && (// .
				a.equals(TelephonyManager.ACTION_PHONE_STATE_CHANGED) // .
				|| a.equals(ACTION_SMS))) {
			Log.i(TAG, ""sleep for "" + WAIT_FOR_LOGS + ""ms"");
			try {
				Thread.sleep(WAIT_FOR_LOGS);
			} catch (InterruptedException e) {
				Log.e(TAG, ""interrupted while waiting for logs"", e);
			}
		}

		final Handler h = Plans.getHandler();
		if (h != null) {
			h.sendEmptyMessage(Plans.MSG_BACKGROUND_START_MATCHER);
		}

		// update roaming info
		roaming = ((TelephonyManager) this
				.getSystemService(Context.TELEPHONY_SERVICE))
				.isNetworkRoaming();
		Log.d(TAG, ""roaming: "" + roaming);
		final SharedPreferences p = PreferenceManager
				.getDefaultSharedPreferences(this);
		if (System.currentTimeMillis() - // .
				p.getLong(PREFS_LASTBACKUP, 0L) > BACKUP_PERIOD) {
			if (DataProvider.doBackup(this)) {
				p.edit().putLong(PREFS_LASTBACKUP, System.currentTimeMillis())
						.commit();
			}
		}
		dateStart = p.getLong(Preferences.PREFS_DATE_BEGIN,
				DatePreference.DEFAULT_VALUE);
		deleteBefore = Preferences.getDeleteLogsBefore(p);
		splitAt160 = p.getBoolean(Preferences.PREFS_SPLIT_SMS_AT_160, false);
		final boolean showCallInfo = p.getBoolean(
				Preferences.PREFS_SHOWCALLINFO, false);
		final boolean askForPlan = p.getBoolean(Preferences.PREFS_ASK_FOR_PLAN,
				false);

		final boolean runMatcher = a == ACTION_RUN_MATCHER;
		boolean shortRun = runMatcher
				|| a != null
				&& (a.equals(Intent.ACTION_BOOT_COMPLETED)
						|| a.equals(Intent.ACTION_SHUTDOWN) // .
						|| a.equals(Intent.ACTION_REBOOT) // .
				|| a.equals(Intent.ACTION_DATE_CHANGED));

		if (!shortRun && a != null
				&& a.equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
			if (intent.getBooleanExtra(ConnectivityManager.EXTRA_IS_FAILOVER,
					false)) {
				return;
			}
			shortRun = true;
		}

		final ContentResolver cr = this.getContentResolver();
		boolean showDialog = false;
		if (!shortRun && h != null) {
			final Cursor c = cr.query(DataProvider.Logs.CONTENT_URI,
					new String[] { DataProvider.Logs.PLAN_ID },
					DataProvider.Logs.RULE_ID + "" != "" + DataProvider.NO_ID
							+ "" AND "" + DataProvider.Logs.TYPE + "" != ""
							+ DataProvider.TYPE_DATA, null, null);
			if (c.getCount() < UNMATHCEDLOGS_TO_SHOW_DIALOG) {
				showDialog = true;
				// skip if no plan is set up
				Cursor c1 = cr.query(DataProvider.Plans.CONTENT_URI,
						new String[] { DataProvider.Plans.ID }, null, null,
						null);
				if (c1.getCount() <= 0) {
					shortRun = true;
					showDialog = false;
				}
				c1.close();
				// skip if no rule is set up
				c1 = cr.query(DataProvider.Rules.CONTENT_URI,
						new String[] { DataProvider.Rules.ID }, null, null,
						null);
				if (c1.getCount() <= 0) {
					shortRun = true;
					showDialog = false;
				}
				c1.close();
				if (showDialog) {
					h.sendEmptyMessage(Plans.MSG_BACKGROUND_START_RUNNER);
				}
			}
			c.close();
		}
		updateData(this, shortRun && !runMatcher);
		if (!shortRun || runMatcher) {
			if (deleteBefore > 0L) {
				deleteOldLogs(cr);
			}
			updateCalls(cr);
			updateSMS(cr, DataProvider.DIRECTION_IN);
			updateSMS(cr, DataProvider.DIRECTION_OUT);
			updateMMS(this);
			if (RuleMatcher.match(this, showDialog)) {
				StatsAppWidgetProvider.updateWidgets(this);
			}
		} else if (roaming) {
			updateCalls(cr);
			updateSMS(cr, DataProvider.DIRECTION_IN);
			updateSMS(cr, DataProvider.DIRECTION_OUT);
			updateMMS(this);
		}

		if (showDialog) {
			h.sendEmptyMessage(Plans.MSG_BACKGROUND_STOP_RUNNER);
		}

		if ((showCallInfo || askForPlan) && a != null && a.equals(// .
				TelephonyManager.ACTION_PHONE_STATE_CHANGED)) {
			final Cursor c = cr.query(DataProvider.Logs.CONTENT_URI,
					DataProvider.Logs.PROJECTION, DataProvider.Logs.TYPE
							+ "" = "" + DataProvider.TYPE_CALL, null,
					DataProvider.Logs.DATE + "" DESC"");
			if (c != null && c.moveToFirst()) {
				final long id = c.getLong(DataProvider.Logs.INDEX_ID);
				final long date = c.getLong(DataProvider.Logs.INDEX_DATE);
				final long amount = c.getLong(DataProvider.Logs.INDEX_AMOUNT);

				final long now = System.currentTimeMillis();
				if (amount > 0L
						&& date + amount * CallMeter.MILLIS + GAP_FOR_LOGS // .
						>= now) {
					// only show real calls
					// only show calls made just now
					final float cost = c.getFloat(DataProvider.Logs.INDEX_COST);
					final String planname = DataProvider.Plans.getName(cr,
							c.getLong(DataProvider.Logs.INDEX_PLAN_ID));
					StringBuffer sb = new StringBuffer();
					sb.append(Common.prettySeconds(amount, false));
					if (cost > 0) {
						String currencyFormat = Preferences
								.getCurrencyFormat(this);
						sb.append("" | "" // FIXME
								+ String.format(currencyFormat, cost));
					}
					if (planname != null) {
						sb.insert(0, planname + "": "");
					} else if (askForPlan) {
						this.handler.post(new Runnable() {
							@Override
							public void run() {
								Log.i(TAG, ""launching ask for plan dialog"");
								final Intent i = new Intent(
										LogRunnerService.this, // .
										AskForPlan.class);
								i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
								i.putExtra(AskForPlan.EXTRA_ID, id);
								i.putExtra(AskForPlan.EXTRA_DATE, date);
								i.putExtra(AskForPlan.EXTRA_AMOUNT, amount);
								LogRunnerService.this.startActivity(i);
							}
						});
					}
					if (showCallInfo) {
						final String s = sb.toString();
						Log.i(TAG, ""Toast: "" + s);
						this.handler.post(new Runnable() {
							@Override
							public void run() {
								final Toast toast = Toast.makeText(
										LogRunnerService.this, s,
										Toast.LENGTH_LONG);
								toast.show();
							}
						});
					}
				} else {
					Log.i(TAG, ""skip Toast: amount="" + amount);
					Log.i(TAG, ""skip Toast: date+amount+gap="" + (// .
							date + amount * CallMeter.MILLIS + GAP_FOR_LOGS));
					Log.i(TAG, ""skip Toast: now            ="" + now);
				}
			}
			if (c != null && !c.isClosed()) {
				c.close();
			}
		}

		// schedule next update
		LogRunnerReceiver.schedNext(this);
		if (h != null) {
			h.sendEmptyMessage(Plans.MSG_BACKGROUND_STOP_MATCHER);
		}
		wakelock.release();
		Log.i(TAG, ""wakelock released"");
	}","[('13', 'acquire', 'wakelock'), ('75', 'acquire', 'cursor'), ('83', 'acquire', 'c1'), ('90', 'release', 'c1'), ('92', 'acquire', 'c1'), ('99', 'release', 'c1'), ('104', 'release', 'c'), ('131', 'acquire', 'c'), ('135', 'check', 'c'), ('193', 'check', 'c'), ('194', 'release', 'c'), ('203', 'release', 'wakelock')]","[(2, 'check', 'intent', 'Intent'), (11, 'acquire', 'wakelock', 'PowerManager.WakeLock'), (13, 'acquire', 'wakelock', 'PowerManager.WakeLock'), (28, 'check', 'h', 'Handler'), (74, 'check', '!shortRun && h', '!shortRun && h'), (200, 'check', 'h', 'Handler'), (203, 'release', 'wakelock', 'PowerManager.WakeLock')]"
"@Override
	protected void onHandleIntent(final Intent intent) {
		if (intent == null) {
			Log.w(TAG, ""onHandleIntent(null)"");
			return;
		}
		final String a = intent.getAction();
		Log.d(TAG, ""onHandleIntent(action="" + a + "")"");

		final WakeLock wakelock = this.acquire(a);

		final Handler h = Plans.getHandler();
		if (h != null) {
			h.sendEmptyMessage(Plans.MSG_BACKGROUND_START_MATCHER);
		}

		final SharedPreferences p = PreferenceManager
				.getDefaultSharedPreferences(this);
		if (System.currentTimeMillis() - // .
				p.getLong(PREFS_LASTBACKUP, 0L) > BACKUP_PERIOD) {
			if (DataProvider.doBackup(this)) {
				p.edit().putLong(PREFS_LASTBACKUP, System.currentTimeMillis())
						.commit();
			}
		}
		dateStart = p.getLong(Preferences.PREFS_DATE_BEGIN,
				DatePreference.DEFAULT_VALUE);
		deleteBefore = Preferences.getDeleteLogsBefore(p);
		splitAt160 = p.getBoolean(Preferences.PREFS_SPLIT_SMS_AT_160, false);
		final boolean showCallInfo = p.getBoolean(
				Preferences.PREFS_SHOWCALLINFO, false);
		final boolean askForPlan = p.getBoolean(Preferences.PREFS_ASK_FOR_PLAN,
				false);
		final String deleimter = p
				.getString(Preferences.PREFS_DELIMITER, "" | "");

		final boolean runMatcher = a == ACTION_RUN_MATCHER;
		boolean shortRun = runMatcher
				|| a != null
				&& (a.equals(Intent.ACTION_BOOT_COMPLETED)
						|| a.equals(Intent.ACTION_SHUTDOWN) // .
						|| a.equals(Intent.ACTION_REBOOT) // .
				|| a.equals(Intent.ACTION_DATE_CHANGED));

		if (!shortRun && a != null
				&& a.equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
			if (intent.getBooleanExtra(ConnectivityManager.EXTRA_IS_FAILOVER,
					false)) {
				this.release(wakelock, h);
				return;
			}
			shortRun = true;
		}

		final ContentResolver cr = this.getContentResolver();
		boolean showDialog = false;
		if (!shortRun && h != null) {
			final Cursor c = cr.query(DataProvider.Logs.CONTENT_URI,
					new String[] { DataProvider.Logs.PLAN_ID },
					DataProvider.Logs.RULE_ID + "" != "" + DataProvider.NO_ID
							+ "" AND "" + DataProvider.Logs.TYPE + "" != ""
							+ DataProvider.TYPE_DATA, null, null);
			if (c.getCount() < UNMATHCEDLOGS_TO_SHOW_DIALOG) {
				showDialog = true;
				// skip if no plan is set up
				Cursor c1 = cr.query(DataProvider.Plans.CONTENT_URI,
						new String[] { DataProvider.Plans.ID }, null, null,
						null);
				if (c1.getCount() <= 0) {
					shortRun = true;
					showDialog = false;
				}
				c1.close();
				// skip if no rule is set up
				c1 = cr.query(DataProvider.Rules.CONTENT_URI,
						new String[] { DataProvider.Rules.ID }, null, null,
						null);
				if (c1.getCount() <= 0) {
					shortRun = true;
					showDialog = false;
				}
				c1.close();
				if (showDialog) {
					h.sendEmptyMessage(Plans.MSG_BACKGROUND_START_RUNNER);
				}
			}
			c.close();
		}

		updateData(this, shortRun && !runMatcher);
		if (!shortRun || runMatcher) {
			if (deleteBefore > 0L) {
				deleteOldLogs(cr);
			}
			updateCalls(cr);
			updateSMS(cr, DataProvider.DIRECTION_IN);
			updateSMS(cr, DataProvider.DIRECTION_OUT);
			updateMMS(this);
			if (RuleMatcher.match(this, showDialog)) {
				StatsAppWidgetProvider.updateWidgets(this);
			}
		} else if (roaming) {
			updateCalls(cr);
			updateSMS(cr, DataProvider.DIRECTION_IN);
			updateSMS(cr, DataProvider.DIRECTION_OUT);
			updateMMS(this);
		}

		if (showDialog) {
			h.sendEmptyMessage(Plans.MSG_BACKGROUND_STOP_RUNNER);
		}

		if ((showCallInfo || askForPlan) && a != null && a.equals(// .
				TelephonyManager.ACTION_PHONE_STATE_CHANGED)) {
			final Cursor c = cr.query(DataProvider.Logs.CONTENT_URI,
					DataProvider.Logs.PROJECTION, DataProvider.Logs.TYPE
							+ "" = "" + DataProvider.TYPE_CALL, null,
					DataProvider.Logs.DATE + "" DESC"");
			if (c != null && c.moveToFirst()) {
				final long id = c.getLong(DataProvider.Logs.INDEX_ID);
				final long date = c.getLong(DataProvider.Logs.INDEX_DATE);
				final long amount = c.getLong(DataProvider.Logs.INDEX_AMOUNT);

				final long now = System.currentTimeMillis();
				if (amount > 0L
						&& date + amount * CallMeter.MILLIS + GAP_FOR_LOGS // .
						>= now) {
					// only show real calls
					// only show calls made just now
					final float cost = c.getFloat(DataProvider.Logs.INDEX_COST);
					final String planname = DataProvider.Plans.getName(cr,
							c.getLong(DataProvider.Logs.INDEX_PLAN_ID));
					StringBuffer sb = new StringBuffer();
					sb.append(Common.prettySeconds(amount, false));
					if (cost > 0) {
						String currencyFormat = Preferences
								.getCurrencyFormat(this);
						sb.append(deleimter
								+ String.format(currencyFormat, cost));
					}
					if (planname != null) {
						sb.insert(0, planname + "": "");
					} else if (askForPlan) {
						this.handler.post(new Runnable() {
							@Override
							public void run() {
								Log.i(TAG, ""launching ask for plan dialog"");
								final Intent i = new Intent(
										LogRunnerService.this, // .
										AskForPlan.class);
								i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
								i.putExtra(AskForPlan.EXTRA_ID, id);
								i.putExtra(AskForPlan.EXTRA_DATE, date);
								i.putExtra(AskForPlan.EXTRA_AMOUNT, amount);
								LogRunnerService.this.startActivity(i);
							}
						});
					}
					if (showCallInfo) {
						final String s = sb.toString();
						Log.i(TAG, ""Toast: "" + s);
						this.handler.post(new Runnable() {
							@Override
							public void run() {
								final Toast toast = Toast.makeText(
										LogRunnerService.this, s,
										Toast.LENGTH_LONG);
								toast.show();
							}
						});
					}
				} else {
					Log.i(TAG, ""skip Toast: amount="" + amount);
					Log.i(TAG, ""skip Toast: date+amount+gap="" + (// .
							date + amount * CallMeter.MILLIS + GAP_FOR_LOGS));
					Log.i(TAG, ""skip Toast: now            ="" + now);
				}
			}
			if (c != null && !c.isClosed()) {
				c.close();
			}
		}

		this.release(wakelock, h);
	}","[('9', 'acquire', 'WakeLock'), ('48', 'release', 'WakeLock'), ('57', 'acquire', 'c'), ('65', 'acquire', 'c1'), ('72', 'release', 'c1'), ('74', 'acquire', 'c1'), ('81', 'release', 'c1'), ('86', 'release', 'c'), ('114', 'acquire', 'c'), ('118', 'check', 'c'), ('176', 'check', 'c'), ('177', 'release', 'c'), ('181', 'release', 'WakeLock')]","[(2, 'check', 'intent', 'Intent'), (9, 'acquire', 'wakelock', 'WakeLock'), (12, 'check', 'h', 'Handler'), (48, 'release', 'wakelock', 'WakeLock'), (56, 'check', '!shortRun && h', '!shortRun && h'), (57, 'acquire', 'c', 'Cursor'), (62, 'check', 'c', 'Cursor'), (65, 'acquire', 'c1', 'Cursor'), (68, 'check', 'c1', 'Cursor'), (72, 'release', 'c1', 'Cursor'), (74, 'acquire', 'c1', 'Cursor'), (77, 'check', 'c1', 'Cursor'), (81, 'release', 'c1', 'Cursor'), (86, 'release', 'c', 'Cursor'), (114, 'acquire', 'c', 'Cursor'), (118, 'check', 'c', 'Cursor'), (176, 'check', 'c', 'Cursor'), (177, 'release', 'c', 'Cursor'), (181, 'release', 'wakelock', 'WakeLock')]"
"	@Override
	public void onPause() {
		super.onPause();
		Log.d(TAG, ""onPause called"");

		if (forcedOrientation && bound != null)
			bound.setResizeAllowed(false);
	}
",[],"[(5, 'check', 'forcedOrientation && bound', 'forcedOrientation && bound')]"
"	@Override
	public void onPause() {
		super.onPause();
		Log.d(TAG, ""onPause called"");

		// Allow the screen to dim and fall asleep.
		if (wakelock != null && wakelock.isHeld())
			wakelock.release();

		if (forcedOrientation && bound != null)
			bound.setResizeAllowed(false);
	}
","[('6', 'check', 'wakelock'), ('7', 'release', 'wakelock')]","[(6, 'check', 'wakelock', 'wakelock'), (7, 'release', 'wakelock', 'wakelock'), (9, 'check', 'forcedOrientation && bound', 'forcedOrientation && bound'), (9, 'check', 'bound', 'bound')]"
"   private void updateWakeLock()
   {
      if( this.mLoggingState == Constants.LOGGING )
      {
         PreferenceManager.getDefaultSharedPreferences( this ).registerOnSharedPreferenceChangeListener( mSharedPreferenceChangeListener );

         PowerManager pm = (PowerManager) this.getSystemService( Context.POWER_SERVICE );
         this.mWakeLock = pm.newWakeLock( PowerManager.PARTIAL_WAKE_LOCK, TAG );
         this.mWakeLock.acquire();
      }
      else
      {
         if( this.mWakeLock != null )
         {
            this.mWakeLock.release();
            this.mWakeLock = null;
         }
      }
   }
","[('9', 'acquire', 'WakeLock'), ('13', 'check', 'WakeLock'), ('15', 'release', 'WakeLock')]","[(8, 'acquire', 'mWakeLock', 'mWakeLock'), (9, 'acquire', 'mWakeLock', 'mWakeLock'), (13, 'check', 'this.mWakeLock', 'this.mWakeLock'), (13, 'check', 'mWakeLock', 'mWakeLock'), (15, 'release', 'mWakeLock', 'mWakeLock')]"
"   private void updateWakeLock()
   {
      if( this.mLoggingState == Constants.LOGGING )
      {
         PreferenceManager.getDefaultSharedPreferences( this ).registerOnSharedPreferenceChangeListener( mSharedPreferenceChangeListener );

         PowerManager pm = (PowerManager) this.getSystemService( Context.POWER_SERVICE );
         if( this.mWakeLock != null )
         {
            this.mWakeLock.release();
            this.mWakeLock = null;
         }
         this.mWakeLock = pm.newWakeLock( PowerManager.PARTIAL_WAKE_LOCK, TAG );
         this.mWakeLock.acquire();
      }
      else
      {
         if( this.mWakeLock != null )
         {
            this.mWakeLock.release();
            this.mWakeLock = null;
         }
      }
   }
","[('9', 'check', 'WakeLock'), ('10', 'release', 'WakeLock'), ('14', 'acquire', 'WakeLock'), ('18', 'check', 'WakeLock'), ('20', 'release', 'WakeLock')]","[(8, 'check', 'this.mWakeLock', 'this.mWakeLock'), (8, 'check', 'mWakeLock', 'mWakeLock'), (10, 'release', 'mWakeLock', 'mWakeLock'), (13, 'acquire', 'mWakeLock', 'mWakeLock'), (14, 'acquire', 'mWakeLock', 'mWakeLock'), (18, 'check', 'this.mWakeLock', 'this.mWakeLock'), (18, 'check', 'mWakeLock', 'mWakeLock'), (20, 'release', 'mWakeLock', 'mWakeLock')]"
"@Override
	public void on_incoming_call(final int acc_id, final int callId, SWIGTYPE_p_pjsip_rx_data rdata) {
		lockCpu();
		
		//Check if we have not already an ongoing call
		if(pjService != null && pjService.service != null && !pjService.service.supportMultipleCalls) {
			SipCallSession[] calls = getCalls();
			if(calls != null && calls.length > 0) {
				for( SipCallSession existingCall : calls) {
					if(!existingCall.isAfterEnded()) {
						Log.e(THIS_FILE, ""For now we do not support two call at the same time !!!"");
						//If there is an ongoing call and we do not support multiple calls
						//Send busy here
						pjsua.call_hangup(callId, 486, null, null);
						return;
					}
				}
			}
		}
		pjService.service.getExecutor().execute(pjService.service.new SipRunnable() {
			@Override
			public void doRun() throws SameThreadException {
				SipCallSession callInfo = updateCallInfoFromStack(callId);
				Log.d(THIS_FILE, ""Incoming call <<"");
				IncomingCallInfos iCInfo = new IncomingCallInfos();
				iCInfo.accId = acc_id;
				iCInfo.callInfo = callInfo;
				msgHandler.sendMessage(msgHandler.obtainMessage(ON_INCOMING_CALL, iCInfo));
				Log.d(THIS_FILE, ""Incoming call >>"");
			}
		});
		unlockCpu();
		
		
	}","[('2', 'acquire', 'lockCpu'), ('30', 'release', 'lockCpu')]","[(5, 'check', 'pjService', 'pjService'), (7, 'check', 'calls', 'SipCallSession[]'), (9, 'check', 'existingCall', 'existingCall')]"
"@Override
	public void on_incoming_call(final int acc_id, final int callId, SWIGTYPE_p_pjsip_rx_data rdata) {
		lockCpu();
		
		//Check if we have not already an ongoing call
		if(pjService != null && pjService.service != null && !pjService.service.supportMultipleCalls) {
			SipCallSession[] calls = getCalls();
			if(calls != null && calls.length > 0) {
				for( SipCallSession existingCall : calls) {
					if(!existingCall.isAfterEnded()) {
						Log.e(THIS_FILE, ""Settings to not support two call at the same time !!!"");
						//If there is an ongoing call and we do not support multiple calls
						//Send busy here
						pjsua.call_hangup(callId, 486, null, null);
						unlockCpu();
						return;
					}
				}
			}
		}
		pjService.service.getExecutor().execute(pjService.service.new SipRunnable() {
			@Override
			public void doRun() throws SameThreadException {
				SipCallSession callInfo = updateCallInfoFromStack(callId);
				Log.d(THIS_FILE, ""Incoming call <<"");
				IncomingCallInfos iCInfo = new IncomingCallInfos();
				iCInfo.accId = acc_id;
				iCInfo.callInfo = callInfo;
				msgHandler.sendMessage(msgHandler.obtainMessage(ON_INCOMING_CALL, iCInfo));
				Log.d(THIS_FILE, ""Incoming call >>"");
			}
		});
		unlockCpu();
		
		
	}","[('2', 'acquire', 'lockCpu'), ('14', 'release', 'lockCpu'), ('31', 'release', 'lockCpu')]",[]
"protected void onChanged(String type, boolean connected) {
			synchronized (SipService.this) {
				// When turning on WIFI, it needs some time for network
				// connectivity to get stabile so we defer good news (because
				// we want to skip the interim ones) but deliver bad news
				// immediately
				if (connected) {
					if (mTask != null) {
						mTask.cancel();
					}
					mTask = new MyTimerTask(type, connected);
					if(mTimer == null) {
						mTimer = new Timer();
					}
					mTimer.schedule(mTask, 2 * 1000L);
					// hold wakup lock so that we can finish changes before the
					// device goes to sleep
					sipWakeLock.acquire(mTask);
				} else {
					if ((mTask != null) && mTask.mNetworkType.equals(type)) {
						mTask.cancel();
						sipWakeLock.release(mTask);
					}
					// onConnectivityChanged(type, false);
					dataConnectionChanged();
				}
			}
		}","[('18', 'acquire', 'sipWakeLock'), ('22', 'release', 'sipWakeLock')]","[(8, 'check', 'mTask', 'mTask'), (9, 'release', 'mTask', 'mTask'), (11, 'acquire', 'mTask', 'mTask'), (12, 'check', 'mTimer', 'mTimer'), (13, 'acquire', 'mTimer', 'mTimer'), (18, 'acquire', 'sipWakeLock', 'sipWakeLock'), (20, 'check', '(mTask', '(mTask'), (20, 'check', 'mTask', 'mTask'), (21, 'release', 'mTask', 'mTask'), (22, 'release', 'sipWakeLock', 'sipWakeLock')]"
"protected void onChanged(String type, boolean connected) {
			synchronized (SipService.this) {
				// When turning on WIFI, it needs some time for network
				// connectivity to get stabile so we defer good news (because
				// we want to skip the interim ones) but deliver bad news
				// immediately
				if (connected) {
					if (mTask != null) {
						Log.d(THIS_FILE, ""We already have a current task in stack"");
						mTask.cancel();
						sipWakeLock.release(mTask);
					}
					mTask = new MyTimerTask(type, connected);
					if(mTimer == null) {
						mTimer = new Timer();
					}
					mTimer.schedule(mTask, 2 * 1000L);
					// hold wakup lock so that we can finish changes before the
					// device goes to sleep
					sipWakeLock.acquire(mTask);
				} else {
					if ((mTask != null) && mTask.mNetworkType.equals(type)) {
						mTask.cancel();
						sipWakeLock.release(mTask);
					}
					// onConnectivityChanged(type, false);
					dataConnectionChanged();
				}
			}
		}","[('11', 'release', 'wakup lock'), ('20', 'acquire', 'wakup lock'), ('24', 'release', 'wakup lock')]","[(8, 'check', 'mTask', 'mTask'), (11, 'release', 'mTask', 'mTask'), (13, 'acquire', 'mTask', 'mTask'), (14, 'check', 'mTimer', 'mTimer'), (15, 'acquire', 'mTimer', 'mTimer'), (20, 'acquire', 'mTask', 'mTask'), (22, 'check', 'mTask', 'mTask'), (22, 'check', '(mTask', '(mTask'), (24, 'release', 'mTask', 'mTask')]"
"			private void realRun() {
				synchronized (createLock) {
					if (mTask != this) {
						Log.w(THIS_FILE, ""  unexpected task: "" + mNetworkType + (mConnected ? "" CONNECTED"" : ""DISCONNECTED""));
						return;
					}
					mTask = null;
					Log.d(THIS_FILE, "" deliver change for "" + mNetworkType + (mConnected ? "" CONNECTED"" : ""DISCONNECTED""));
					// onConnectivityChanged(mNetworkType, mConnected);
					dataConnectionChanged(mNetworkType, true);
					sipWakeLock.release(this);
				}
			}
",[],"[(11, 'release', 'sipWakeLock', 'sipWakeLock')]"
"			private void realRun() {
				synchronized (createLock) {
					if (mTask != this) {
						Log.w(THIS_FILE, ""  unexpected task: "" + mNetworkType + (mConnected ? "" CONNECTED"" : ""DISCONNECTED""));
						sipWakeLock.release(this);
						return;
					}
					mTask = null;
					Log.d(THIS_FILE, "" deliver change for "" + mNetworkType + (mConnected ? "" CONNECTED"" : ""DISCONNECTED""));
					// onConnectivityChanged(mNetworkType, mConnected);
					dataConnectionChanged(mNetworkType, true);
					sipWakeLock.release(this);
				}
			}
",[],[]
"private void stopMovement() {
		listView.onTouchEvent(MotionEvent.obtain(SystemClock.uptimeMillis(),
				SystemClock.uptimeMillis(), MotionEvent.ACTION_CANCEL, 0, 0, 0));
	}","[('2', 'acquire', 'MotionEvent')]",[]
"private void stopMovement() {
		MotionEvent event = MotionEvent.obtain(SystemClock.uptimeMillis(),
				SystemClock.uptimeMillis(), MotionEvent.ACTION_CANCEL, 0, 0, 0);
		listView.onTouchEvent(event);
		event.recycle();
	}","[('2', 'acquire', 'event'), ('5', 'release', 'event')]","[(2, 'acquire', 'event', 'MotionEvent'), (5, 'release', 'event', 'MotionEvent')]"
"private boolean resumeDownload() {
   BufferedInputStream in = null;
   FileOutputStream fos = null;
   BufferedOutputStream bout = null;

   try {
    for (; downloadIndex < fileNames.length; downloadIndex++) {
     int downloaded = 0; ;
     File f = new File(saveToDirectories[downloadIndex]);
     f.mkdirs();
     File file = new File(saveToDirectories[downloadIndex],
       fileNames[downloadIndex] + DOWNLOAD_EXT);
     URL url = new URL(downloadUrls[downloadIndex]);
     URLConnection conn = url.openConnection();
     int total = conn.getContentLength();
     Log.d(""quran_srv"", ""File to download: "" + file.getName()
       + "" - total length: "" + total);
     HttpURLConnection connection = (HttpURLConnection) url
       .openConnection();
     if (file.exists()) {
      downloaded = (int) file.length();
      connection.setRequestProperty(""Range"", ""bytes=""
        + (file.length()) + ""-"");
      Log.d(""quran_srv"", ""Resuming from "" + downloaded);
      if (downloaded == total)
       continue;
     }
     connection.setRequestProperty(""Range"", ""bytes=""
       + downloaded + ""-"");
     connection.setDoInput(true);
     in = new BufferedInputStream(connection.getInputStream());
     fos = (downloaded == 0) ? new FileOutputStream(file
       .getAbsolutePath()) : new FileOutputStream(file
       .getAbsolutePath(), true);
     bout = new BufferedOutputStream(fos, DOWNLOAD_BUFFER_SIZE);
     byte[] data = new byte[DOWNLOAD_BUFFER_SIZE];
     int x = 0;
     while (isRunning && (x = in.read(data, 0, DOWNLOAD_BUFFER_SIZE)) >= 0) {
      bout.write(data, 0, x);
      downloaded += x;
      double percent = 100.0 * ((1.0 * downloaded) / (1.0 * total));
      updateProgress((int) percent, fileNames.length, downloadIndex);
     }
     if (isRunning) {
      file.renameTo(new File(saveToDirectories[downloadIndex], fileNames[downloadIndex]));
 
      if (zipped || fileNames[downloadIndex].endsWith("".zip""))
       unzipFile(saveToDirectories[downloadIndex], fileNames[downloadIndex]);
 
      Log.d(""quran_srv"", ""Download Completed ["" + downloadUrls[downloadIndex] + ""]"");
     } else 
      return false;
    }
   } catch (FileNotFoundException e) {
    Log.e(""quran_srv"", ""File not found: IO Exception"", e);
   } catch (IOException e) {
    Log.e(""quran_srv"", ""Download paused: IO Exception"", e);
    return false;
   } catch (Exception e) {
    Log.e(""quran_srv"", ""Download paused: Exception"", e);
    return false;
   }
   return true;
  }","[('14', 'acquire', 'conn'), ('18', 'acquire', 'connection'), ('20', 'check', 'file'), ('31', 'acquire', 'in'), ('32', 'acquire', 'fos'), ('34', 'acquire', 'bout')]","[(31, 'acquire', 'in', 'BufferedInputStream'), (32, 'acquire', 'fos', 'FileOutputStream'), (35, 'acquire', 'bout', 'BufferedOutputStream')]"
"private boolean resumeDownload() {
   BufferedInputStream in = null;
   FileOutputStream fos = null;
   BufferedOutputStream bout = null;

   try {
    for (; downloadIndex < fileNames.length; downloadIndex++) {
     int downloaded = 0;
     File f = new File(saveToDirectories[downloadIndex]);
     f.mkdirs();
     File file = new File(saveToDirectories[downloadIndex],
       fileNames[downloadIndex] + DOWNLOAD_EXT);
     URL url = new URL(downloadUrls[downloadIndex]);
     URLConnection conn = url.openConnection();
     int total = conn.getContentLength();
     Log.d(""quran_srv"", ""File to download: "" + file.getName()
       + "" - total length: "" + total);
     HttpURLConnection connection = (HttpURLConnection) url
       .openConnection();
     if (file.exists()) {
      downloaded = (int) file.length();
      connection.setRequestProperty(""Range"", ""bytes=""
        + (file.length()) + ""-"");
      Log.d(""quran_srv"", ""Resuming from "" + downloaded);
      if (downloaded == total)
       continue;
     }
     connection.setRequestProperty(""Range"", ""bytes=""
       + downloaded + ""-"");
     connection.setDoInput(true);
     in = new BufferedInputStream(connection.getInputStream(), DOWNLOAD_BUFFER_SIZE);
     fos = (downloaded == 0) ? new FileOutputStream(file
       .getAbsolutePath()) : new FileOutputStream(file
       .getAbsolutePath(), true);
     bout = new BufferedOutputStream(fos, DOWNLOAD_BUFFER_SIZE);
     byte[] data = new byte[DOWNLOAD_BUFFER_SIZE];
     int x = 0;
     while (isRunning && (x = in.read(data, 0, DOWNLOAD_BUFFER_SIZE)) >= 0) {
      bout.write(data, 0, x);
      downloaded += x;
      double percent = 100.0 * ((1.0 * downloaded) / (1.0 * total));
      updateProgress((int) percent, fileNames.length, downloadIndex);
     }
     bout.flush();
     bout.close();
     fos.close();

     if (isRunning) {
      file.renameTo(new File(saveToDirectories[downloadIndex], fileNames[downloadIndex]));
 
      if (zipped || fileNames[downloadIndex].endsWith("".zip""))
       unzipFile(saveToDirectories[downloadIndex], fileNames[downloadIndex]);
 
      Log.d(""quran_srv"", ""Download Completed ["" + downloadUrls[downloadIndex] + ""]"");
     } else 
      return false;
    }
   } catch (FileNotFoundException e) {
    Log.e(""quran_srv"", ""File not found: IO Exception"", e);
   } catch (IOException e) {
    Log.e(""quran_srv"", ""Download paused: IO Exception"", e);
    return false;
   } catch (Exception e) {
    Log.e(""quran_srv"", ""Download paused: Exception"", e);
    return false;
   }
   return true;
  }","[('14', 'acquire', 'conn'), ('18', 'acquire', 'connection'), ('31', 'acquire', 'in'), ('32', 'acquire', 'fos'), ('35', 'acquire', 'bout'), ('45', 'release', 'bout'), ('46', 'release', 'fos')]","[(31, 'acquire', 'in', 'BufferedInputStream'), (32, 'acquire', 'fos', 'FileOutputStream'), (35, 'acquire', 'bout', 'BufferedOutputStream'), (45, 'release', 'bout', 'BufferedOutputStream'), (46, 'release', 'fos', 'FileOutputStream')]"
"byte[] fetch(final String name, int maxAgeInDays)
  {
    if(!isAvailable())
      return null;
    
    final File file = dataFileName(name);
    if(!file.exists())
      return null;
    
    if(expired(file, maxAgeInDays))
      return null;
    
    final ByteArrayOutputStream output = new ByteArrayOutputStream();
    try 
    {
      final FileInputStream fis = new FileInputStream(file);
      byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
    
      int n = 0;
      while ((n = fis.read(buffer)) != -1)
        output.write(buffer, 0, n);            

    } // try
    catch(IOException e)
    {
      return null;
    } // catch
    
    return output.toByteArray();    
  } // fetch","[('16', 'acquire', 'fis')]","[(6, 'acquire', 'file', 'File'), (13, 'acquire', 'output', 'ByteArrayOutputStream'), (16, 'acquire', 'fis', 'FileInputStream')]"
"byte[] fetch(final String name, int maxAgeInDays)
  {
    if(!isAvailable())
      return null;
    
    final File file = dataFileName(name);
    if(!file.exists())
      return null;
    
    if(expired(file, maxAgeInDays))
      return null;
    
    final ByteArrayOutputStream output = new ByteArrayOutputStream();
    try 
    {
      final FileInputStream fis = new FileInputStream(file);
      byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
    
      int n = 0;
      while ((n = fis.read(buffer)) != -1)
        output.write(buffer, 0, n);            
      fis.close();
    } // try
    catch(IOException e)
    {
      return null;
    } // catch
    
    return output.toByteArray();    
  } // fetch","[('13', 'acquire', 'output'), ('16', 'acquire', 'fis'), ('22', 'release', 'fis')]","[(13, 'acquire', 'output', 'ByteArrayOutputStream'), (16, 'acquire', 'fis', 'FileInputStream'), (22, 'release', 'fis', 'FileInputStream')]"
"private boolean resumeDownload() {
   BufferedInputStream in = null;
   FileOutputStream fos = null;
   BufferedOutputStream bout = null;

   try {
    for (; downloadIndex < fileNames.length; downloadIndex++) {
     int downloaded = 0; ;
     File f = new File(saveToDirectories[downloadIndex]);
     f.mkdirs();
     File file = new File(saveToDirectories[downloadIndex],
       fileNames[downloadIndex] + DOWNLOAD_EXT);
     URL url = new URL(downloadUrls[downloadIndex]);
     URLConnection conn = url.openConnection();
     int total = conn.getContentLength();
     Log.d(""quran_srv"", ""File to download: "" + file.getName()
       + "" - total length: "" + total);
     HttpURLConnection connection = (HttpURLConnection) url
       .openConnection();
     if (file.exists()) {
      downloaded = (int) file.length();
      connection.setRequestProperty(""Range"", ""bytes=""
        + (file.length()) + ""-"");
      Log.d(""quran_srv"", ""Resuming from "" + downloaded);
      if (downloaded == total)
       continue;
     }
     connection.setRequestProperty(""Range"", ""bytes=""
       + downloaded + ""-"");
     connection.setDoInput(true);
     in = new BufferedInputStream(connection.getInputStream());
  
     fos = (downloaded == 0) ? new FileOutputStream(file
       .getAbsolutePath()) : new FileOutputStream(file
       .getAbsolutePath(), true);
     bout = new BufferedOutputStream(fos, DOWNLOAD_BUFFER_SIZE);
     byte[] data = new byte[DOWNLOAD_BUFFER_SIZE];
     int x = 0;
     while (isRunning && (x = in.read(data, 0, DOWNLOAD_BUFFER_SIZE)) >= 0) {
      bout.write(data, 0, x);
      downloaded += x;
      double percent = 100.0 * ((1.0 * downloaded) / (1.0 * total));
      updateProgress((int) percent, fileNames.length, downloadIndex);
     }
 

     if (isRunning) {
      file.renameTo(new File(saveToDirectories[downloadIndex], fileNames[downloadIndex]));
 
      if (zipped || fileNames[downloadIndex].endsWith("".zip""))
       unzipFile(saveToDirectories[downloadIndex], fileNames[downloadIndex]);
 
      Log.d(""quran_srv"", ""Download Completed ["" + downloadUrls[downloadIndex] + ""]"");
     } else 
      return false;
    }
   } catch (FileNotFoundException e) {
    Log.e(""quran_srv"", ""File not found: IO Exception"", e);
   } catch (IOException e) {
    Log.e(""quran_srv"", ""Download paused: IO Exception"", e);
    return false;
   } catch (Exception e) {
    Log.e(""quran_srv"", ""Download paused: Exception"", e);
    return false;
   }
   return true;
  }","[('14', 'acquire', 'conn'), ('18', 'acquire', 'connection'), ('20', 'check', 'file'), ('31', 'acquire', 'in'), ('32', 'acquire', 'fos'), ('34', 'acquire', 'bout')]","[(31, 'acquire', 'in', 'BufferedInputStream'), (33, 'acquire', 'fos', 'FileOutputStream'), (36, 'acquire', 'bout', 'BufferedOutputStream')]"
"private boolean resumeDownload() {
   BufferedInputStream in = null;
   FileOutputStream fos = null;
   BufferedOutputStream bout = null;

   try {
    for (; downloadIndex < fileNames.length; downloadIndex++) {
     int downloaded = 0;
     File f = new File(saveToDirectories[downloadIndex]);
     f.mkdirs();
     File file = new File(saveToDirectories[downloadIndex],
       fileNames[downloadIndex] + DOWNLOAD_EXT);
     URL url = new URL(downloadUrls[downloadIndex]);
     URLConnection conn = url.openConnection();
     int total = conn.getContentLength();
     Log.d(""quran_srv"", ""File to download: "" + file.getName()
       + "" - total length: "" + total);
     HttpURLConnection connection = (HttpURLConnection) url
       .openConnection();
     if (file.exists()) {
      downloaded = (int) file.length();
      connection.setRequestProperty(""Range"", ""bytes=""
        + (file.length()) + ""-"");
      Log.d(""quran_srv"", ""Resuming from "" + downloaded);
      if (downloaded == total)
       continue;
     }
     connection.setRequestProperty(""Range"", ""bytes=""
       + downloaded + ""-"");
     connection.setDoInput(true);

     in = new BufferedInputStream(connection.getInputStream(), DOWNLOAD_BUFFER_SIZE);
     fos = (downloaded == 0) ? new FileOutputStream(file
       .getAbsolutePath()) : new FileOutputStream(file
       .getAbsolutePath(), true);
     bout = new BufferedOutputStream(fos, DOWNLOAD_BUFFER_SIZE);
     byte[] data = new byte[DOWNLOAD_BUFFER_SIZE];
     int x = 0;
     while (isRunning && (x = in.read(data, 0, DOWNLOAD_BUFFER_SIZE)) >= 0) {
      bout.write(data, 0, x);
      downloaded += x;
      double percent = 100.0 * ((1.0 * downloaded) / (1.0 * total));
      updateProgress((int) percent, fileNames.length, downloadIndex);
     }
     bout.flush();
     bout.close();
     fos.close();

     if (isRunning) {
      file.renameTo(new File(saveToDirectories[downloadIndex], fileNames[downloadIndex]));
 
      if (zipped || fileNames[downloadIndex].endsWith("".zip""))
       unzipFile(saveToDirectories[downloadIndex], fileNames[downloadIndex]);
 
      Log.d(""quran_srv"", ""Download Completed ["" + downloadUrls[downloadIndex] + ""]"");
     } else 
      return false;
    }
   } catch (FileNotFoundException e) {
    Log.e(""quran_srv"", ""File not found: IO Exception"", e);
   } catch (IOException e) {
    Log.e(""quran_srv"", ""Download paused: IO Exception"", e);
    return false;
   } catch (Exception e) {
    Log.e(""quran_srv"", ""Download paused: Exception"", e);
    return false;
   }
   return true;
  }","[('14', 'acquire', 'conn'), ('18', 'acquire', 'connection'), ('31', 'acquire', 'in'), ('32', 'acquire', 'fos'), ('35', 'acquire', 'bout'), ('45', 'release', 'bout'), ('46', 'release', 'fos')]","[(32, 'acquire', 'in', 'BufferedInputStream'), (33, 'acquire', 'fos', 'FileOutputStream'), (35, 'acquire', 'fos', 'FileOutputStream'), (36, 'acquire', 'bout', 'BufferedOutputStream'), (46, 'release', 'bout', 'BufferedOutputStream'), (47, 'release', 'fos', 'FileOutputStream')]"
"public static BigInteger[] unserialize(byte[] bytes) throws SMException {
        try {
            ByteArrayInputStream in = new ByteArrayInputStream(bytes);
            OtrInputStream ois = new OtrInputStream(in);
            int len = ois.readInt();
            if (len > 100);
          
            BigInteger[] ints = new BigInteger[len];
            for (int i = 0; i < len; i++) {
                ints[i] = ois.readBigInt();
            }
            ois.close();
            return ints;
        } catch (IOException ex) {
            throw new SMException(""cannot unserialize bigints"");
        }
    }",[],"[(3, 'acquire', 'in', 'ByteArrayInputStream'), (4, 'acquire', 'ois', 'OtrInputStream'), (12, 'release', 'ois', 'OtrInputStream')]"
"public static BigInteger[] unserialize(byte[] bytes) throws SMException {
        try {
            ByteArrayInputStream in = new ByteArrayInputStream(bytes);
            OtrInputStream ois = new OtrInputStream(in);
            int len = ois.readInt();
            if (len > 100) {
                ois.close();
                throw new SMException(""Too many ints"");
            }
            BigInteger[] ints = new BigInteger[len];
            for (int i = 0; i < len; i++) {
                ints[i] = ois.readBigInt();
            }
            ois.close();
            return ints;
        } catch (IOException ex) {
            throw new SMException(""cannot unserialize bigints"");
        }
    }",[],"[(3, 'acquire', 'in', 'ByteArrayInputStream'), (4, 'acquire', 'ois', 'OtrInputStream'), (7, 'release', 'ois', 'OtrInputStream'), (14, 'release', 'ois', 'OtrInputStream')]"
"public void testIOShort() throws Exception {
        int source = 10;
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeShort(source);


        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        int result = ois.readShort();


        assertEquals(source, result);
    }","[('4', 'acquire', 'out'), ('5', 'acquire', 'oos'), ('10', 'acquire', 'bin'), ('11', 'acquire', 'ois')]","[(3, 'acquire', 'out', 'ByteArrayOutputStream'), (4, 'acquire', 'oos', 'OtrOutputStream'), (10, 'acquire', 'bin', 'ByteArrayInputStream'), (11, 'acquire', 'ois', 'OtrInputStream')]"
"public void testIOShort() throws Exception {
        int source = 10;

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeShort(source);
        oos.close();

        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        int result = ois.readShort();
        ois.close();

        assertEquals(source, result);
    }","[('4', 'acquire', 'out'), ('5', 'acquire', 'oos'), ('7', 'release', 'oos'), ('11', 'acquire', 'bin'), ('12', 'acquire', 'ois'), ('14', 'release', 'ois')]","[(4, 'acquire', 'out', 'ByteArrayOutputStream'), (5, 'acquire', 'oos', 'OtrOutputStream'), (7, 'release', 'oos', 'OtrOutputStream'), (11, 'acquire', 'bin', 'ByteArrayInputStream'), (12, 'acquire', 'ois', 'OtrInputStream'), (14, 'release', 'ois', 'OtrInputStream')]"
"public void testIOData() throws Exception {
        byte[] source = new byte[] { 1, 1, 1, 1 };
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeData(source);


        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        byte[] result = ois.readData();


        assertTrue(java.util.Arrays.equals(source, result));
    }","[('3', 'acquire', 'out'), ('4', 'acquire', 'oos'), ('10', 'acquire', 'bin'), ('11', 'acquire', 'ois')]","[(3, 'acquire', 'out', 'ByteArrayOutputStream'), (4, 'acquire', 'oos', 'OtrOutputStream'), (10, 'acquire', 'bin', 'ByteArrayInputStream'), (11, 'acquire', 'ois', 'OtrInputStream')]"
"public void testIOData() throws Exception {
        byte[] source = new byte[] { 1, 1, 1, 1 };

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeData(source);
        oos.close();

        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        byte[] result = ois.readData();
        ois.close();

        assertTrue(java.util.Arrays.equals(source, result));
    }","[('4', 'acquire', 'out'), ('5', 'acquire', 'oos'), ('7', 'release', 'oos'), ('11', 'acquire', 'bin'), ('12', 'acquire', 'ois'), ('14', 'release', 'ois')]","[(4, 'acquire', 'out', 'ByteArrayOutputStream'), (5, 'acquire', 'oos', 'OtrOutputStream'), (7, 'release', 'oos', 'OtrOutputStream'), (11, 'acquire', 'bin', 'ByteArrayInputStream'), (12, 'acquire', 'ois', 'OtrInputStream'), (14, 'release', 'ois', 'OtrInputStream')]"
"public void testIOBigInt() throws Exception {
        KeyPair pair = new OtrCryptoEngineImpl().generateDHKeyPair();
        BigInteger source = ((DHPublicKey) pair.getPublic()).getY();
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeBigInt(source);


        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        BigInteger result = ois.readBigInt();


        assertTrue(source.compareTo(result) == 0);
    }","[('4', 'acquire', 'ByteArrayOutputStream'), ('5', 'acquire', 'OtrOutputStream'), ('11', 'acquire', 'ByteArrayInputStream'), ('12', 'acquire', 'OtrInputStream')]","[(4, 'acquire', 'out', 'ByteArrayOutputStream'), (5, 'acquire', 'oos', 'OtrOutputStream'), (11, 'acquire', 'bin', 'ByteArrayInputStream'), (12, 'acquire', 'ois', 'OtrInputStream')]"
"public void testIOBigInt() throws Exception {

        KeyPair pair = new OtrCryptoEngineImpl().generateDHKeyPair();
        BigInteger source = ((DHPublicKey) pair.getPublic()).getY();

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeBigInt(source);
        oos.close();

        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        BigInteger result = ois.readBigInt();
        ois.close();

        assertTrue(source.compareTo(result) == 0);
    }","[('6', 'acquire', 'ByteArrayOutputStream'), ('7', 'acquire', 'OtrOutputStream'), ('9', 'release', 'OtrOutputStream'), ('13', 'acquire', 'ByteArrayInputStream'), ('14', 'acquire', 'OtrInputStream'), ('16', 'release', 'OtrInputStream')]","[(6, 'acquire', 'out', 'ByteArrayOutputStream'), (7, 'acquire', 'oos', 'OtrOutputStream'), (9, 'release', 'oos', 'OtrOutputStream'), (13, 'acquire', 'bin', 'ByteArrayInputStream'), (14, 'acquire', 'ois', 'OtrInputStream'), (16, 'release', 'ois', 'OtrInputStream')]"
"public void testIODHPublicKey() throws Exception {
        KeyPair pair = new OtrCryptoEngineImpl().generateDHKeyPair();
        DHPublicKey source = (DHPublicKey) pair.getPublic();
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeDHPublicKey(source);


        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        DHPublicKey result = ois.readDHPublicKey();


        assertTrue(source.getY().compareTo(result.getY()) == 0);
    }","[('4', 'acquire', 'out'), ('5', 'acquire', 'oos'), ('11', 'acquire', 'bin'), ('12', 'acquire', 'ois')]","[(2, 'acquire', 'pair', 'KeyPair'), (4, 'acquire', 'out', 'ByteArrayOutputStream'), (5, 'acquire', 'oos', 'OtrOutputStream'), (11, 'acquire', 'bin', 'ByteArrayInputStream'), (12, 'acquire', 'ois', 'OtrInputStream')]"
"public void testIODHPublicKey() throws Exception {
        KeyPair pair = new OtrCryptoEngineImpl().generateDHKeyPair();

        DHPublicKey source = (DHPublicKey) pair.getPublic();

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeDHPublicKey(source);
        oos.close();

        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        DHPublicKey result = ois.readDHPublicKey();
        ois.close();

        assertTrue(source.getY().compareTo(result.getY()) == 0);
    }","[('6', 'acquire', 'out'), ('7', 'acquire', 'oos'), ('9', 'release', 'oos'), ('13', 'acquire', 'bin'), ('14', 'acquire', 'ois'), ('16', 'release', 'ois')]","[(2, 'acquire', 'pair', 'KeyPair'), (4, 'acquire', 'source', 'DHPublicKey'), (6, 'acquire', 'out', 'ByteArrayOutputStream'), (7, 'acquire', 'oos', 'OtrOutputStream'), (9, 'release', 'oos', 'OtrOutputStream'), (11, 'acquire', 'converted', 'byte[]'), (13, 'acquire', 'bin', 'ByteArrayInputStream'), (14, 'acquire', 'ois', 'OtrInputStream'), (15, 'acquire', 'result', 'DHPublicKey'), (16, 'release', 'ois', 'OtrInputStream')]"
"    public static byte[] toByteArray(MysteriousT t) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeMysteriousT(t);
        byte[] b = out.toByteArray();
        out.close();

        return b;
    }","[('2', 'acquire', 'out'), ('3', 'acquire', 'oos'), ('6', 'release', 'out')]","[(2, 'acquire', 'out', 'ByteArrayOutputStream'), (3, 'acquire', 'oos', 'OtrOutputStream'), (6, 'release', 'out', 'ByteArrayOutputStream')]"
"    public static byte[] toByteArray(SignatureX x) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeMysteriousX(x);
        byte[] b = out.toByteArray();
        oos.close();
        return b;
    }
","[('2', 'acquire', 'out'), ('3', 'acquire', 'oos'), ('6', 'release', 'oos')]","[(2, 'acquire', 'out', 'ByteArrayOutputStream'), (3, 'acquire', 'oos', 'OtrOutputStream'), (6, 'release', 'oos', 'OtrOutputStream')]"
" public static byte[] writeData(byte[] b) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeData(b);
        byte[] otrb = out.toByteArray();
        out.close();
        return otrb;
    }","[('2', 'acquire', 'out'), ('3', 'acquire', 'oos'), ('6', 'release', 'out')]","[(2, 'acquire', 'out', 'ByteArrayOutputStream'), (3, 'acquire', 'oos', 'OtrOutputStream'), (6, 'release', 'out', 'ByteArrayOutputStream')]"
"    public static byte[] writeData(byte[] b) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeData(b);
        byte[] otrb = out.toByteArray();
        out.close();
        oos.close();
        return otrb;
    }
","[('2', 'acquire', 'out'), ('3', 'acquire', 'oos'), ('6', 'release', 'out'), ('7', 'release', 'oos')]","[(2, 'acquire', 'out', 'ByteArrayOutputStream'), (3, 'acquire', 'oos', 'OtrOutputStream'), (6, 'release', 'out', 'ByteArrayOutputStream'), (7, 'release', 'oos', 'OtrOutputStream')]"
"public void testIOShort() throws Exception {
        int source = 10;
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeShort(source);


        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        int result = ois.readShort();


        assertEquals(source, result);
    }","[('3', 'acquire', 'out'), ('4', 'acquire', 'oos'), ('10', 'acquire', 'bin'), ('11', 'acquire', 'ois')]","[(3, 'acquire', 'out', 'ByteArrayOutputStream'), (4, 'acquire', 'oos', 'OtrOutputStream'), (10, 'acquire', 'bin', 'ByteArrayInputStream'), (11, 'acquire', 'ois', 'OtrInputStream')]"
"public void testIOShort() throws Exception {
        int source = 10;

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeShort(source);
        oos.close();

        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        int result = ois.readShort();
        ois.close();

        assertEquals(source, result);
    }","[('4', 'acquire', 'out'), ('5', 'acquire', 'oos'), ('7', 'release', 'oos'), ('11', 'acquire', 'bin'), ('12', 'acquire', 'ois'), ('14', 'release', 'ois')]","[(4, 'acquire', 'out', 'ByteArrayOutputStream'), (5, 'acquire', 'oos', 'OtrOutputStream'), (7, 'release', 'oos', 'OtrOutputStream'), (11, 'acquire', 'bin', 'ByteArrayInputStream'), (12, 'acquire', 'ois', 'OtrInputStream'), (14, 'release', 'ois', 'OtrInputStream')]"
"public void testIOData() throws Exception {
        byte[] source = new byte[] { 1, 1, 1, 1 };
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeData(source);


        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        byte[] result = ois.readData();


        assertTrue(java.util.Arrays.equals(source, result));
    }","[('3', 'acquire', 'out'), ('4', 'acquire', 'oos'), ('10', 'acquire', 'bin'), ('11', 'acquire', 'ois')]","[(3, 'acquire', 'out', 'ByteArrayOutputStream'), (4, 'acquire', 'oos', 'OtrOutputStream'), (10, 'acquire', 'bin', 'ByteArrayInputStream'), (11, 'acquire', 'ois', 'OtrInputStream')]"
"public void testIOData() throws Exception {
        byte[] source = new byte[] { 1, 1, 1, 1 };

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeData(source);
        oos.close();

        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        byte[] result = ois.readData();
        ois.close();

        assertTrue(java.util.Arrays.equals(source, result));
    }","[('4', 'acquire', 'out'), ('5', 'acquire', 'oos'), ('7', 'release', 'out'), ('11', 'acquire', 'bin'), ('12', 'acquire', 'ois'), ('14', 'release', 'ois')]","[(4, 'acquire', 'out', 'ByteArrayOutputStream'), (5, 'acquire', 'oos', 'OtrOutputStream'), (7, 'release', 'oos', 'OtrOutputStream'), (11, 'acquire', 'bin', 'ByteArrayInputStream'), (12, 'acquire', 'ois', 'OtrInputStream'), (14, 'release', 'ois', 'OtrInputStream')]"
"public void testIOBigInt() throws Exception {
        KeyPair pair = new OtrCryptoEngineImpl().generateDHKeyPair();
        BigInteger source = ((DHPublicKey) pair.getPublic()).getY();
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeBigInt(source);


        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        BigInteger result = ois.readBigInt();

        assertTrue(source.compareTo(result) == 0);
    }","[('4', 'acquire', 'out'), ('5', 'acquire', 'oos'), ('11', 'acquire', 'bin'), ('12', 'acquire', 'ois')]","[(4, 'acquire', 'out', 'ByteArrayOutputStream'), (5, 'acquire', 'oos', 'OtrOutputStream'), (11, 'acquire', 'bin', 'ByteArrayInputStream'), (12, 'acquire', 'ois', 'OtrInputStream')]"
"public void testIOBigInt() throws Exception {

        KeyPair pair = new OtrCryptoEngineImpl().generateDHKeyPair();
        BigInteger source = ((DHPublicKey) pair.getPublic()).getY();

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeBigInt(source);
        oos.close();

        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        BigInteger result = ois.readBigInt();
        ois.close();

        assertTrue(source.compareTo(result) == 0);
    }","[('6', 'acquire', 'out'), ('7', 'acquire', 'oos'), ('9', 'release', 'oos'), ('13', 'acquire', 'bin'), ('14', 'acquire', 'ois'), ('16', 'release', 'ois')]","[(6, 'acquire', 'out', 'ByteArrayOutputStream'), (7, 'acquire', 'oos', 'OtrOutputStream'), (9, 'release', 'oos', 'OtrOutputStream'), (13, 'acquire', 'bin', 'ByteArrayInputStream'), (14, 'acquire', 'ois', 'OtrInputStream'), (16, 'release', 'ois', 'OtrInputStream')]"
"public void testIODHPublicKey() throws Exception {
        KeyPair pair = new OtrCryptoEngineImpl().generateDHKeyPair();
        DHPublicKey source = (DHPublicKey) pair.getPublic();
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeDHPublicKey(source);

        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        DHPublicKey result = ois.readDHPublicKey();

        assertTrue(source.getY().compareTo(result.getY()) == 0);
    }","[('4', 'acquire', 'out'), ('5', 'acquire', 'OtrOutputStream'), ('10', 'acquire', 'bin'), ('11', 'acquire', 'ois')]","[(2, 'acquire', 'pair', 'KeyPair'), (4, 'acquire', 'out', 'ByteArrayOutputStream'), (5, 'acquire', 'oos', 'OtrOutputStream'), (10, 'acquire', 'bin', 'ByteArrayInputStream'), (11, 'acquire', 'ois', 'OtrInputStream')]"
"public void testIODHPublicKey() throws Exception {
        KeyPair pair = new OtrCryptoEngineImpl().generateDHKeyPair();

        DHPublicKey source = (DHPublicKey) pair.getPublic();

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeDHPublicKey(source);
        oos.close();

        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        DHPublicKey result = ois.readDHPublicKey();
        ois.close();

        assertTrue(source.getY().compareTo(result.getY()) == 0);
    }","[('6', 'acquire', 'out'), ('7', 'acquire', 'oos'), ('9', 'release', 'oos'), ('13', 'acquire', 'bin'), ('14', 'acquire', 'ois'), ('16', 'release', 'ois')]","[(6, 'acquire', 'out', 'ByteArrayOutputStream'), (7, 'acquire', 'oos', 'OtrOutputStream'), (9, 'release', 'oos', 'OtrOutputStream'), (13, 'acquire', 'bin', 'ByteArrayInputStream'), (14, 'acquire', 'ois', 'OtrInputStream'), (16, 'release', 'ois', 'OtrInputStream')]"
"private void checkOutgoing() throws MessagingException {
            if (!(account.getRemoteStore() instanceof WebDavStore)) {
                publishProgress(R.string.account_setup_check_settings_check_outgoing_msg);
            }
            Transport transport = Transport.getInstance(K9.app, account);
            transport.close();
            transport.open();
            transport.close();
           
        }","[('5', 'acquire', 'transport'), ('6', 'release', 'transport'), ('7', 'acquire', 'transport'), ('8', 'release', 'transport')]","[(5, 'acquire', 'transport', 'Transport'), (6, 'release', 'transport', 'Transport'), (8, 'release', 'transport', 'Transport')]"
"private void checkOutgoing() throws MessagingException {
            if (!(account.getRemoteStore() instanceof WebDavStore)) {
                publishProgress(R.string.account_setup_check_settings_check_outgoing_msg);
            }
            Transport transport = Transport.getInstance(K9.app, account);
            transport.close();
          
            try {
                transport.open();
            } finally {
                transport.close();
            }
        }","[('5', 'acquire', 'transport'), ('6', 'release', 'transport'), ('9', 'acquire', 'transport'), ('11', 'release', 'transport')]","[(5, 'acquire', 'transport', 'Transport'), (6, 'release', 'transport', 'Transport'), (9, 'acquire', 'transport', 'Transport'), (11, 'release', 'transport', 'Transport')]"
"private Bitmap getPreviewIcon() {
        try {
            return BitmapFactory.decodeStream(
                       mContext.getContentResolver().openInputStream(
                           AttachmentProvider.getAttachmentThumbnailUri(mAccount,
                                   part.getAttachmentId(),
                                   62,
                                   62)));
        } catch (Exception e) {
            /*
             * We don't care what happened, we just return null for the preview icon.
             */
            return null;
        }
    }","[('4', 'acquire', 'input stream')]","[(4, 'acquire', 'InputStream', 'InputStream')]"
"private Bitmap getPreviewIcon() {
        Bitmap icon = null;
        try {
            InputStream input = mContext.getContentResolver().openInputStream(
                           AttachmentProvider.getAttachmentThumbnailUri(mAccount,
                                   part.getAttachmentId(),
                                   62,
                                   62));
            icon = BitmapFactory.decodeStream(input);
            input.close();
        } catch (Exception e) {
            /*
             * We don't care what happened, we just return null for the preview icon.
             */
        }
        return icon;
    }","[('4', 'acquire', 'InputStream'), ('10', 'release', 'InputStream')]","[(4, 'acquire', 'input', 'InputStream'), (10, 'release', 'input', 'InputStream')]"
"public InputStream getAttachmentInputStream(final String attachmentId) throws MessagingException {
        return database.execute(false, new DbCallback<InputStream>() {
            @Override
            public InputStream doDbWork(final SQLiteDatabase db) throws WrappedException {
                Cursor cursor = db.query(""message_parts"",
                        new String[] { ""data_location"", ""data"", ""encoding"" },
                        ""id = ?"",
                        new String[] { attachmentId },
                        null, null, null);
                try {
                    if (!cursor.moveToFirst()) {
                        return null;
                    }

                    int location = cursor.getInt(0);
                    String encoding = cursor.getString(2);

                    InputStream rawInputStream = getRawAttachmentInputStream(cursor, location, attachmentId);
                    return getDecodingInputStream(rawInputStream, encoding);
                } finally {
                    cursor.close();
                }
            }
        });
    }",[],"[(5, 'acquire', 'cursor', 'Cursor'), (18, 'acquire', 'rawInputStream', 'InputStream'), (21, 'release', 'cursor', 'Cursor')]"
"public InputStream getAttachmentInputStream(final String attachmentId) throws MessagingException {
        return database.execute(false, new DbCallback<InputStream>() {
            @Override
            public InputStream doDbWork(final SQLiteDatabase db) throws WrappedException {
                Cursor cursor = db.query(""message_parts"",
                        new String[] { ""data_location"", ""data"", ""encoding"" },
                        ""id = ?"",
                        new String[] { attachmentId },
                        null, null, null);
                try {
                    if (!cursor.moveToFirst()) {
                        return null;
                    }

                    int location = cursor.getInt(0);
                    String encoding = cursor.getString(2);

                    InputStream rawInputStream = getRawAttachmentInputStream(cursor, location, attachmentId);
                    return getDecodingInputStream(rawInputStream, encoding);
                } finally {
                    cursor.close();
                }
            }
        });
    }",[],"[(5, 'acquire', 'cursor', 'Cursor'), (18, 'acquire', 'rawInputStream', 'InputStream'), (21, 'release', 'cursor', 'Cursor')]"
"    public void finish() {
        mIsRunning = false;
        mTranscriptScreen.finish();
        if (mFinishCallback != null) {
            mFinishCallback.onSessionFinish(this);
        }
    }
","[('3', 'release', 'mTranscriptScreen')]","[(4, 'check', 'mFinishCallback', 'mFinishCallback')]"
"    public void finish() {
        mIsRunning = false;
        mTranscriptScreen.finish();

        // Stop the reader and writer threads, and close the I/O streams
        mWriterHandler.sendEmptyMessage(FINISH);
        try {
            mTermIn.close();
            mTermOut.close();
        } catch (IOException e) {
            // We don't care if this fails
        }

        if (mFinishCallback != null) {
            mFinishCallback.onSessionFinish(this);
        }
    }
",[],"[(8, 'release', 'mTermIn', 'mTermIn'), (9, 'release', 'mTermOut', 'mTermOut'), (14, 'check', 'mFinishCallback', 'mFinishCallback')]"
"    public static HNFeed getLastHNFeed() {
        try {
            ObjectInputStream obj = new ObjectInputStream(new FileInputStream(getLastHNFeedFilePath()));
            Object rawHNFeed = obj.readObject();
            if (rawHNFeed instanceof HNFeed)
                return (HNFeed) rawHNFeed;
        } catch (Exception e) {
            Log.e(TAG, ""Could not get last HNFeed from file :("", e);
        }
        return null;
    }
","[('3', 'acquire', 'FileInputStream'), ('3', 'acquire', 'ObjectInputStream')]","[(3, 'acquire', 'obj', 'ObjectInputStream')]"
"    public static HNFeed getLastHNFeed() {
    	ObjectInputStream obj = null;
        try {
            obj = new ObjectInputStream(new FileInputStream(getLastHNFeedFilePath()));
            Object rawHNFeed = obj.readObject();
            if (rawHNFeed instanceof HNFeed)
                return (HNFeed) rawHNFeed;
        } catch (Exception e) {
            Log.e(TAG, ""Could not get last HNFeed from file :("", e);
        } finally {
        	if (obj!=null){
        		try {
					obj.close();
				} catch (IOException e) {
		            Log.e(TAG, ""Couldn't close last NH feed file :("", e);
				}
        	}
        }
        return null;
    }
","[('4', 'acquire', 'ObjectInputStream'), ('4', 'acquire', 'FileInputStream'), ('11', 'check', 'ObjectInputStream'), ('13', 'release', 'ObjectInputStream')]","[(4, 'acquire', 'obj', 'ObjectInputStream'), (11, 'check', 'obj', 'ObjectInputStream'), (13, 'release', 'obj', 'ObjectInputStream')]"
"    public static HNPostComments getLastHNPostComments(String postID) {
        try {
            ObjectInputStream obj = new ObjectInputStream(new FileInputStream(getLastHNPostCommentsPath(postID)));
            Object rawHNComments = obj.readObject();
            if (rawHNComments instanceof HNPostComments)
                return (HNPostComments) rawHNComments;
        } catch (Exception e) {
            Log.e(TAG, ""Could not get last HNPostComments from file :("", e);
        }
        return null;
    }
","[('3', 'acquire', 'FileInputStream'), ('3', 'acquire', 'ObjectInputStream')]","[(3, 'acquire', 'obj', 'ObjectInputStream')]"
"    public static HNPostComments getLastHNPostComments(String postID) {
    	ObjectInputStream obj = null;
        try {
            obj = new ObjectInputStream(new FileInputStream(getLastHNPostCommentsPath(postID)));
            Object rawHNComments = obj.readObject();
            if (rawHNComments instanceof HNPostComments)
                return (HNPostComments) rawHNComments;
        } catch (Exception e) {
            Log.e(TAG, ""Could not get last HNPostComments from file :("", e);
        } finally {
        	if (obj!=null){
        		try {
					obj.close();
				} catch (IOException e) {
		            Log.e(TAG, ""Couldn't close last NH comments file :("", e);
				}
        	}
        }
        return null;
    }
","[('4', 'acquire', 'ObjectInputStream'), ('4', 'acquire', 'FileInputStream'), ('11', 'check', 'ObjectInputStream'), ('13', 'release', 'ObjectInputStream')]","[(4, 'acquire', 'obj', 'ObjectInputStream'), (11, 'check', 'obj', 'ObjectInputStream'), (13, 'release', 'obj', 'ObjectInputStream')]"
"    public static void setLastHNFeed(HNFeed hnFeed) {
        try {
            ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(getLastHNFeedFilePath()));
            os.writeObject(hnFeed);
        } catch (Exception e) {
            Log.e(TAG, ""Could not save last HNFeed to file :("", e);
        }
    }
","[('3', 'acquire', 'FileOutputStream'), ('3', 'acquire', 'ObjectOutputStream')]","[(3, 'acquire', 'os', 'ObjectOutputStream')]"
"    public static void setLastHNFeed(HNFeed hnFeed) {
    	ObjectOutputStream os = null;
        try {
            os = new ObjectOutputStream(new FileOutputStream(getLastHNFeedFilePath()));
            os.writeObject(hnFeed);
        } catch (Exception e) {
            Log.e(TAG, ""Could not save last HNFeed to file :("", e);
        } finally {
        	if (os!=null){
        		try {
					os.close();
				} catch (IOException e) {
		            Log.e(TAG, ""Couldn't close last NH feed file :("", e);
		        }
        	}
        }
    }
","[('4', 'acquire', 'FileOutputStream'), ('4', 'acquire', 'os'), ('9', 'check', 'os'), ('11', 'release', 'os')]","[(4, 'acquire', 'os', 'ObjectOutputStream'), (9, 'check', 'os', 'ObjectOutputStream'), (11, 'release', 'os', 'ObjectOutputStream')]"
"    public static void setLastHNPostComments(HNPostComments comments, String postID) {
        try {
            ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(getLastHNPostCommentsPath(postID)));
            os.writeObject(comments);
        } catch (Exception e) {
            Log.e(TAG, ""Could not save last HNPostComments to file :("", e);
        }
    }
","[('3', 'acquire', 'FileOutputStream'), ('3', 'acquire', 'FileOutputStream')]","[(3, 'acquire', 'os', 'ObjectOutputStream')]"
"    public static void setLastHNPostComments(HNPostComments comments, String postID) {
    	ObjectOutputStream os = null;
        try {
            os = new ObjectOutputStream(new FileOutputStream(getLastHNPostCommentsPath(postID)));
            os.writeObject(comments);
        } catch (Exception e) {
            Log.e(TAG, ""Could not save last HNPostComments to file :("", e);
        } finally {
        	if (os!=null){
        		try {
					os.close();
				} catch (IOException e) {
		            Log.e(TAG, ""Couldn't close last NH comments file :("", e);
		        }
        	}
        }
    }
","[('4', 'acquire', 'os'), ('9', 'check', 'os'), ('11', 'release', 'os')]","[(4, 'acquire', 'os', 'ObjectOutputStream'), (9, 'check', 'os', 'ObjectOutputStream'), (11, 'release', 'os', 'ObjectOutputStream')]"
"private void checkOutgoing() throws MessagingException {
            if (!(account.getRemoteStore() instanceof WebDavStore)) {
                publishProgress(R.string.account_setup_check_settings_check_outgoing_msg);
            }
            Transport transport = Transport.getInstance(K9.app, account);
            transport.close();
            transport.open();
            transport.close();
        }","[('5', 'acquire', 'transport'), ('6', 'release', 'transport'), ('7', 'acquire', 'transport'), ('8', 'release', 'transport')]","[(5, 'acquire', 'transport', 'Transport'), (6, 'release', 'transport', 'Transport'), (8, 'release', 'transport', 'Transport')]"
"private void checkOutgoing() throws MessagingException {
            if (!(account.getRemoteStore() instanceof WebDavStore)) {
                publishProgress(R.string.account_setup_check_settings_check_outgoing_msg);
            }
            Transport transport = Transport.getInstance(K9.app, account);
            transport.close();
            try {
                transport.open();
            } finally {
                transport.close();
            }
        }","[('5', 'acquire', 'transport'), ('6', 'release', 'transport'), ('9', 'acquire', 'transport'), ('11', 'release', 'transport')]","[(5, 'acquire', 'transport', 'Transport'), (6, 'release', 'transport', 'Transport'), (8, 'acquire', 'transport', 'Transport'), (10, 'release', 'transport', 'Transport')]"
"    public void finish() {
        mIsRunning = false;
        mTranscriptScreen.finish();
        if (mFinishCallback != null) {
            mFinishCallback.onSessionFinish(this);
        }
    }
","[('3', 'release', 'mTranscriptScreen')]","[(4, 'check', 'mFinishCallback', 'mFinishCallback')]"
"    public void finish() {
        mIsRunning = false;
        mTranscriptScreen.finish();

        // Stop the reader and writer threads, and close the I/O streams
        mWriterHandler.sendEmptyMessage(FINISH);
        try {
            mTermIn.close();
            mTermOut.close();
        } catch (IOException e) {
            // We don't care if this fails
        }

        if (mFinishCallback != null) {
            mFinishCallback.onSessionFinish(this);
        }
    }
",[],"[(8, 'release', 'mTermIn', 'mTermIn'), (9, 'release', 'mTermOut', 'mTermOut'), (14, 'check', 'mFinishCallback', 'mFinishCallback')]"
"@Override
            public void run() {
                try {
                    Multipart multipartEncryptedMultipart = (Multipart) currentlyDecrypringOrVerifyingPart.getBody();
                    BodyPart encryptionPayloadPart = multipartEncryptedMultipart.getBodyPart(1);
                    Body encryptionPayloadBody = encryptionPayloadPart.getBody();
                    encryptionPayloadBody.writeTo(out);
                } catch (Exception e) {
                    Log.e(K9.LOG_TAG, ""Exception while writing message to crypto provider"", e);
                }
            }",[],[]
"@Override
            public void run() {
                try {
                    Multipart multipartSignedMultipart = (Multipart) currentlyDecrypringOrVerifyingPart.getBody();
                    BodyPart signatureBodyPart = multipartSignedMultipart.getBodyPart(0);
                    Log.d(K9.LOG_TAG, ""signed data type: "" + signatureBodyPart.getMimeType());
                    signatureBodyPart.writeTo(out);
                } catch (Exception e) {
                    Log.e(K9.LOG_TAG, ""Exception while writing message to crypto provider"", e);
                } finally {
                    try {
                        out.close();
                    } catch (IOException e) {
                        // don't care
                    }
                }
            }","[('11', 'release', 'out')]","[(3, 'acquire', 'multipartSignedMultipart', 'Multipart'), (4, 'acquire', 'signatureBodyPart', 'BodyPart'), (6, 'acquire', 'out', 'out'), (11, 'release', 'out', 'out')]"
"@Override
            public void run() {
                try {
                    Multipart multipartSignedMultipart = (Multipart) currentlyDecrypringOrVerifyingPart.getBody();
                    BodyPart signatureBodyPart = multipartSignedMultipart.getBodyPart(0);
                    Log.d(K9.LOG_TAG, ""signed data type: "" + signatureBodyPart.getMimeType());
                    signatureBodyPart.writeTo(out);
                } catch (Exception e) {
                    Log.e(K9.LOG_TAG, ""Exception while writing message to crypto provider"", e);
               
                }
            }",[],[]
"@Override
            public void run() {
                try {
                    Multipart multipartSignedMultipart = (Multipart) currentlyDecrypringOrVerifyingPart.getBody();
                    BodyPart signatureBodyPart = multipartSignedMultipart.getBodyPart(0);
                    Log.d(K9.LOG_TAG, ""signed data type: "" + signatureBodyPart.getMimeType());
                    signatureBodyPart.writeTo(out);
                } catch (Exception e) {
                    Log.e(K9.LOG_TAG, ""Exception while writing message to crypto provider"", e);
                } finally {
                    try {
                        out.close();
                    } catch (IOException e) {
                        // don't care
                    }
                }
            }",[],"[(3, 'acquire', 'multipartSignedMultipart', 'Multipart'), (4, 'acquire', 'signatureBodyPart', 'BodyPart'), (6, 'acquire', 'out', 'out'), (11, 'release', 'out', 'out')]"
"private void checkOutgoing() throws MessagingException {
            if (!(account.getRemoteStore() instanceof WebDavStore)) {
                publishProgress(R.string.account_setup_check_settings_check_outgoing_msg);
            }
            Transport transport = Transport.getInstance(K9.app, account);
            transport.close();
            transport.open();
            transport.close();
         
        }","[('5', 'acquire', 'transport'), ('6', 'release', 'transport'), ('7', 'acquire', 'transport'), ('8', 'release', 'transport')]","[(5, 'acquire', 'transport', 'Transport'), (6, 'release', 'transport', 'Transport'), (8, 'release', 'transport', 'Transport')]"
"private void checkOutgoing() throws MessagingException {
            if (!(account.getRemoteStore() instanceof WebDavStore)) {
                publishProgress(R.string.account_setup_check_settings_check_outgoing_msg);
            }
            Transport transport = Transport.getInstance(K9.app, account);
            transport.close();

            try {
                transport.open();
            } finally {
                transport.close();
            }
        }","[('5', 'acquire', 'transport'), ('6', 'release', 'transport'), ('9', 'acquire', 'transport'), ('11', 'release', 'transport')]","[(5, 'acquire', 'transport', 'Transport'), (6, 'release', 'transport', 'Transport'), (9, 'acquire', 'transport', 'Transport'), (11, 'release', 'transport', 'Transport')]"
"    public void run() {
        while (isRunning) {
            try {
                Socket client = socket.accept();
                if (client == null) {
                    continue;
                }
                HttpRequest request = readRequest(client);
                if (isRunning)
                    processRequest(request, client);
            } catch (SocketTimeoutException e) {
                // Do nothing
            } catch (IOException e) {
                Log.e(LOG_TAG, ""Error connecting to client"", e);
            }
        }
    }
","[('4', 'acquire', 'Socket')]","[(4, 'acquire', 'client', 'Socket'), (5, 'check', 'client', 'Socket'), (8, 'acquire', 'request', 'HttpRequest')]"
"    public void run() {
        while (isRunning) {
            try {
                Socket client = socket.accept();
                if (client == null) {
                    continue;
                }
                HttpRequest request = readRequest(client);
                if (isRunning)
                    processRequest(request, client);
                client.close();
            } catch (SocketTimeoutException e) {
                // Do nothing
            } catch (IOException e) {
                Log.e(LOG_TAG, ""Error connecting to client"", e);
            }
        }
    }
","[('4', 'acquire', 'Socket'), ('11', 'release', 'Socket')]","[(4, 'acquire', 'client', 'Socket'), (5, 'check', 'client', 'Socket'), (8, 'acquire', 'request', 'HttpRequest'), (9, 'check', 'client and request', 'client and request'), (11, 'release', 'client', 'Socket')]"
"    @Override
    public void onChainDownloadStarted(Peer peer, int blocksLeft) {
        startDownload(blocksLeft);
        originalBlocksLeft = blocksLeft;
    }
",[],[]
"@Override
    public void onChainDownloadStarted(Peer peer, int blocksLeft) {
        startDownload(blocksLeft);
        originalBlocksLeft = blocksLeft;
        if (blocksLeft == 0) {
            doneDownload();
            done.release();
        }
    }","[('6', 'release', 'done')]",[]
"@Override
		public void onReceive(Context context, Intent intent) {
			if (getResultCode() != Activity.RESULT_OK) {
				mRecvRetVal = false;
				context.unregisterReceiver(this);
				mSem.release();
				return;
			}
			mPendingIntents.remove(mPendingIntents.size() - 1);
			if (mPendingIntents.isEmpty()) {
				mRecvRetVal = true;
				context.unregisterReceiver(this);
				mSem.release();
			}
		}","[('5', 'release', 'mSem'), ('12', 'release', 'mSem')]","[(4, 'release', 'context', 'Context'), (5, 'release', 'mSem', 'mSem'), (11, 'release', 'context', 'Context'), (12, 'release', 'mSem', 'mSem')]"
"@Override
		public void onReceive(Context context, Intent intent) {
			if (getResultCode() != Activity.RESULT_OK) {
				mRecvRetVal = false;
				context.unregisterReceiver(this);
				mSem.release();
				return;
			}

			// Fix for a potential null object here
			if (mPendingIntents != null) {
				mPendingIntents.remove(mPendingIntents.size() - 1);
				if (mPendingIntents.isEmpty()) {
					mRecvRetVal = true;
					context.unregisterReceiver(this);
					mSem.release();
				}
			}
		}","[('5', 'acquire', 'mSem'), ('15', 'release', 'mSem')]","[(4, 'release', 'context', 'Context'), (5, 'release', 'mSem', 'mSem'), (10, 'check', 'mPendingIntents', 'mPendingIntents'), (14, 'release', 'context', 'Context'), (15, 'release', 'mSem', 'mSem')]"
"private static void appendReport(final StringBuilder report, final File file, final int indent)
 {
  final Formatter formatter = new Formatter(report);

  for (int i = 0; i < indent; i++)
   report.append(""  - "");


  formatter.format(""%tF %tT  %s  [%d]\n"", file.lastModified(), file.lastModified(), file.getName(), file.length());


  if (file.isDirectory())
   for (final File f : file.listFiles())
    appendReport(report, f, indent + 1);
 }","[('3', 'acquire', 'formatter')]","[(3, 'acquire', 'formatter', 'Formatter')]"
"private static void appendReport(final StringBuilder report, final File file, final int indent)
 {

  for (int i = 0; i < indent; i++)
   report.append(""  - "");

  final Formatter formatter = new Formatter(report);
  formatter.format(""%tF %tT  %s  [%d]\n"", file.lastModified(), file.lastModified(), file.getName(), file.length());
  formatter.close();

  if (file.isDirectory())
   for (final File f : file.listFiles())
    appendReport(report, f, indent + 1);
 }","[('7', 'acquire', 'formatter'), ('9', 'release', 'formatter')]","[(7, 'acquire', 'formatter', 'Formatter'), (9, 'release', 'formatter', 'Formatter')]"
"protected void generateIndex(File f, String rName, RegionSpecificData regionSpecificData, Set<String> alreadyGeneratedFiles, Set<String> alreadyUploadedFiles) {
		if (!generateIndexes) {
			return;
		}
		try {
			// be independent of previous results
			RTree.clearCache();
			
			String regionName = f.getName();
			log.warn(""-------------------------------------------"");
			log.warn(""----------- Generate "" + f.getName() + ""\n\n\n"");
			int i = f.getName().indexOf('.');
			if (i > -1) {
				regionName = Algoritms.capitalizeFirstLetterAndLowercase(f.getName().substring(0, i));
			}
			if(Algoritms.isEmpty(rName)){
				rName = regionName;
			} else {
				rName = Algoritms.capitalizeFirstLetterAndLowercase(rName);
			}
			
			IndexCreator indexCreator = new IndexCreator(workDir);
			indexCreator.setIndexAddress(indexAddress);
			indexCreator.setIndexPOI(indexPOI);
			indexCreator.setIndexTransport(indexTransport);
			indexCreator.setIndexMap(indexMap);
			indexCreator.setLastModifiedDate(f.lastModified());
			indexCreator.setNormalizeStreets(true);
			indexCreator.setSaveAddressWays(true);
			indexCreator.setRegionName(rName);
			if (regionSpecificData != null && regionSpecificData.cityAdminLevel != null) {
				indexCreator.setCityAdminLevel(regionSpecificData.cityAdminLevel);
			}
			if(zoomWaySmoothness != null){
				indexCreator.setZoomWaySmothness(zoomWaySmoothness);
			}

			String poiFileName = regionName + ""_"" + IndexConstants.POI_TABLE_VERSION + IndexConstants.POI_INDEX_EXT;
			indexCreator.setPoiFileName(poiFileName);
			String mapFileName = regionName + ""_"" + IndexConstants.BINARY_MAP_VERSION + IndexConstants.BINARY_MAP_INDEX_EXT;
			indexCreator.setMapFileName(mapFileName);
			try {
				alreadyGeneratedFiles.add(f.getName());
				Log warningsAboutMapData = null;
				FileHandler fh = null;
				// configure log path
				try {
					fh = new FileHandler(new File(workDir, mapFileName+"".gen.log"").getAbsolutePath(), 5000000, 1, true);
					fh.setFormatter(new SimpleFormatter());
					fh.setLevel(Level.ALL);
					Jdk14Logger jdk14Logger = new Jdk14Logger(""tempLogger"");
		                        jdk14Logger.getLogger().setLevel(Level.ALL);
		                        jdk14Logger.getLogger().setUseParentHandlers(false);
		                        jdk14Logger.getLogger().addHandler(fh);
		                        warningsAboutMapData = jdk14Logger;												
				} catch (SecurityException e1) {
					e1.printStackTrace();
				} catch (IOException e1) {
					e1.printStackTrace();
				}
				if(fh != null) {
					LogManager.getLogManager().getLogger("""").addHandler(fh);
				}
				
				indexCreator.generateIndexes(f, new ConsoleProgressImplementation(3),  null, mapZooms, types, warningsAboutMapData);
				
				File generated = new File(workDir, mapFileName);
				File ready = new File(indexDirFiles, mapFileName);
				generated.renameTo(ready);
				// Do not upload poi files any more
				if (indexMap || indexAddress || indexTransport || indexPOI) {
					uploadIndex(ready, alreadyUploadedFiles);
				}
				if(fh != null) {
					LogManager.getLogManager().getLogger("""").removeHandler(fh);
				}
			} catch (Exception e) {
				log.error(""Exception generating indexes for "" + f.getName(), e); //$NON-NLS-1$ 
			}
		} catch (OutOfMemoryError e) {
			System.gc();
			log.error(""OutOfMemory"", e);

		}
		System.gc();
	}","[('48', 'acquire', 'FileHandler'), ('61', 'check', 'FileHandler'), ('74', 'check', 'FileHandler')]","[(31, 'check', 'regionSpecificData != null && regionSpecificData.cityAdminLevel', 'regionSpecificData != null && regionSpecificData.cityAdminLevel'), (34, 'check', 'zoomWaySmoothness', 'zoomWaySmoothness'), (48, 'acquire', 'fh', 'FileHandler'), (61, 'check', 'fh', 'FileHandler'), (74, 'check', 'fh', 'FileHandler'), (75, 'release', 'fh', 'FileHandler')]"
"protected void generateIndex(File f, String rName, RegionSpecificData regionSpecificData, Set<String> alreadyGeneratedFiles, Set<String> alreadyUploadedFiles) {
		if (!generateIndexes) {
			return;
		}
		try {
			// be independent of previous results
			RTree.clearCache();
			
			String regionName = f.getName();
			log.warn(""-------------------------------------------"");
			log.warn(""----------- Generate "" + f.getName() + ""\n\n\n"");
			int i = f.getName().indexOf('.');
			if (i > -1) {
				regionName = Algoritms.capitalizeFirstLetterAndLowercase(f.getName().substring(0, i));
			}
			if(Algoritms.isEmpty(rName)){
				rName = regionName;
			} else {
				rName = Algoritms.capitalizeFirstLetterAndLowercase(rName);
			}
			
			IndexCreator indexCreator = new IndexCreator(workDir);
			indexCreator.setIndexAddress(indexAddress);
			indexCreator.setIndexPOI(indexPOI);
			indexCreator.setIndexTransport(indexTransport);
			indexCreator.setIndexMap(indexMap);
			indexCreator.setLastModifiedDate(f.lastModified());
			indexCreator.setNormalizeStreets(true);
			indexCreator.setSaveAddressWays(true);
			indexCreator.setRegionName(rName);
			if (regionSpecificData != null && regionSpecificData.cityAdminLevel != null) {
				indexCreator.setCityAdminLevel(regionSpecificData.cityAdminLevel);
			}
			if(zoomWaySmoothness != null){
				indexCreator.setZoomWaySmothness(zoomWaySmoothness);
			}

			String poiFileName = regionName + ""_"" + IndexConstants.POI_TABLE_VERSION + IndexConstants.POI_INDEX_EXT;
			indexCreator.setPoiFileName(poiFileName);
			String mapFileName = regionName + ""_"" + IndexConstants.BINARY_MAP_VERSION + IndexConstants.BINARY_MAP_INDEX_EXT;
			indexCreator.setMapFileName(mapFileName);
			try {
				alreadyGeneratedFiles.add(f.getName());
				Log warningsAboutMapData = null;
				FileHandler fh = null;
				// configure log path
				try {
					fh = new FileHandler(new File(workDir, mapFileName+"".gen.log"").getAbsolutePath(), 5000000, 1, true);
					fh.setFormatter(new SimpleFormatter());
					fh.setLevel(Level.ALL);
					Jdk14Logger jdk14Logger = new Jdk14Logger(""tempLogger"");
		                        jdk14Logger.getLogger().setLevel(Level.ALL);
		                        jdk14Logger.getLogger().setUseParentHandlers(false);
		                        jdk14Logger.getLogger().addHandler(fh);
		                        warningsAboutMapData = jdk14Logger;												
				} catch (SecurityException e1) {
					e1.printStackTrace();
				} catch (IOException e1) {
					e1.printStackTrace();
				}
				if(fh != null) {
					LogManager.getLogManager().getLogger("""").addHandler(fh);
				}
				
				indexCreator.generateIndexes(f, new ConsoleProgressImplementation(3),  null, mapZooms, types, warningsAboutMapData);
				
				File generated = new File(workDir, mapFileName);
				File ready = new File(indexDirFiles, mapFileName);
				generated.renameTo(ready);
				// Do not upload poi files any more
				if (indexMap || indexAddress || indexTransport || indexPOI) {
					uploadIndex(ready, alreadyUploadedFiles);
				}
				if(fh != null) {
					LogManager.getLogManager().getLogger("""").removeHandler(fh);
					fh.close();
				}
			} catch (Exception e) {
				log.error(""Exception generating indexes for "" + f.getName(), e); //$NON-NLS-1$ 
			}
		} catch (OutOfMemoryError e) {
			System.gc();
			log.error(""OutOfMemory"", e);

		}
		System.gc();
	}","[('48', 'acquire', 'FileHandler'), ('61', 'check', 'FileHandler'), ('76', 'release', 'FileHandler')]","[(31, 'check', 'regionSpecificData != null && regionSpecificData.cityAdminLevel', 'regionSpecificData != null && regionSpecificData.cityAdminLevel'), (34, 'check', 'zoomWaySmoothness', 'zoomWaySmoothness'), (48, 'acquire', 'fh', 'FileHandler'), (61, 'check', 'fh', 'FileHandler'), (74, 'check', 'fh', 'FileHandler'), (76, 'release', 'fh', 'FileHandler')]"
"    protected String getFileContent(int resourceId) {
        final InputStream ins = getResourceStream(resourceId);
        final String result = new Scanner(ins).useDelimiter(""\\A"").next();
        try {
            ins.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return result;
    }
","[('2', 'acquire', 'InputStream'), ('3', 'acquire', 'scanner'), ('5', 'release', 'InputStream')]","[(2, 'acquire', 'ins', 'InputStream'), (5, 'release', 'ins', 'InputStream')]"
"    protected String getFileContent(int resourceId) {
        Scanner scanner = null;
        try {
            final InputStream ins = getResourceStream(resourceId);
            scanner = new Scanner(ins);
            return scanner.useDelimiter(""\\A"").next();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (scanner != null) {
                scanner.close();
            }
        }
        return null;
    }
","[('4', 'acquire', 'InputStream'), ('5', 'acquire', 'Scanner'), ('10', 'check', 'Scanner'), ('11', 'release', 'Scanner')]","[(4, 'acquire', 'ins', 'InputStream'), (5, 'acquire', 'scanner', 'Scanner'), (10, 'check', 'scanner', 'Scanner'), (11, 'release', 'scanner', 'Scanner')]"
"private String getRawResourceString(final int resourceId) {
            InputStream ins = null;
            Scanner scanner = null;
            try {
                ins = res.openRawResource(resourceId);
                scanner = new Scanner(ins, CharEncoding.UTF_8);
                return scanner.useDelimiter(""\\A"").next();
            } finally {
                IOUtils.closeQuietly(scanner);
                IOUtils.closeQuietly(ins);
            }
        }","[('5', 'acquire', 'ins'), ('6', 'acquire', 'scanner'), ('9', 'release', 'scanner'), ('10', 'release', 'ins')]","[(5, 'acquire', 'ins', 'InputStream'), (6, 'acquire', 'scanner', 'Scanner'), (9, 'release', 'scanner', 'Scanner'), (10, 'release', 'ins', 'InputStream')]"
"private String getRawResourceString(final int resourceId) {
            InputStream ins = null;
            Scanner scanner = null;
            try {
                ins = res.openRawResource(resourceId);
                scanner = new Scanner(ins, CharEncoding.UTF_8);
                return scanner.useDelimiter(""\\A"").next();
            } finally {
                IOUtils.closeQuietly(ins);
                // Scanner does not implement Closeable on Android 4.1, so closeQuietly leads to crash there
                if (scanner != null) {
                    scanner.close();
                }
            }
        }","[('5', 'acquire', 'ins'), ('6', 'acquire', 'scanner'), ('9', 'release', 'ins'), ('11', 'check', 'scanner'), ('12', 'release', 'scanner')]","[(5, 'acquire', 'ins', 'InputStream'), (6, 'acquire', 'scanner', 'Scanner'), (9, 'release', 'ins', 'InputStream'), (11, 'check', 'scanner', 'Scanner'), (12, 'release', 'scanner', 'Scanner')]"
"		protected Void doInBackground(final String... args) {
			try {
				Log.d(TAG, ""Updating ""+bank);
				bank.update();
				bank.updateAllTransactions();
				Log.d(TAG, ""Saving ""+bank);
				bank.save();
				Log.d(TAG, ""Disabled: ""+bank.isDisabled());
			} 
			catch (BankException e) {
				this.exc = e;
			} catch (LoginException e) {
				this.exc = e;
			}
			return null;
		}
",[],[]
"		protected Void doInBackground(final String... args) {
			try {
				Log.d(TAG, ""Updating ""+bank);
				bank.update();
				bank.updateAllTransactions();
				bank.closeConnection();
				Log.d(TAG, ""Saving ""+bank);
				bank.save();
				Log.d(TAG, ""Disabled: ""+bank.isDisabled());
			} 
			catch (BankException e) {
				this.exc = e;
			} catch (LoginException e) {
				this.exc = e;
			}
			return null;
		}
","[('6', 'acquire', 'connection')]","[(6, 'release', 'bank', 'bank')]"
"@Override
			protected Void doInBackground(Void... params) {
				String accountId = WidgetConfigureActivity.getAccountId(context, appWidgetId);
				if (accountId == null) {
					Log.d(""WidgetService"", ""Widget not found in db: ""+appWidgetId);
					return null;
				}
				String bankId = accountId.split(""_"")[0];
				Bank bank = BankFactory.bankFromDb(new Long(bankId), context, false);
				if (bank == null) {
					return null;
				}

				try {
					if (!bank.isDisabled()) {
						bank.update();
						bank.save();
					}
					else {
						Log.d(""BankdroidWidgetProvider"", ""Bank is disabled, skipping refresh on ""+bank.getDbId());
					}
				} 
				catch (BankException e) {
    				Log.d(TAG, ""Error while updating bank '""+bank.getDbId()+""'; ""+e.getMessage());
				} catch (LoginException e) {
					Log.d("""", ""Disabling bank: ""+bank.getDbId());
					bank.disable();
				}

				BankdroidWidgetProvider.updateAppWidget(context, appWidgetManager, appWidgetId);
				return null;
			}","[('8', 'acquire', 'Bank'), ('9', 'check', 'Bank'), ('14', 'check', 'Bank'), ('26', 'release', 'Bank')]","[(9, 'check', 'bank', 'Bank')]"
"@Override
			protected Void doInBackground(Void... params) {
				String accountId = WidgetConfigureActivity.getAccountId(context, appWidgetId);
				if (accountId == null) {
					Log.d(""WidgetService"", ""Widget not found in db: ""+appWidgetId);
					return null;
				}
				String bankId = accountId.split(""_"")[0];
				Bank bank = BankFactory.bankFromDb(new Long(bankId), context, false);
				if (bank == null) {
					return null;
				}

				try {
					if (!bank.isDisabled()) {
						bank.update();
						bank.closeConnection();
						bank.save();
					}
					else {
						Log.d(""BankdroidWidgetProvider"", ""Bank is disabled, skipping refresh on ""+bank.getDbId());
					}
				} 
				catch (BankException e) {
    				Log.d(TAG, ""Error while updating bank '""+bank.getDbId()+""'; ""+e.getMessage());
				} catch (LoginException e) {
					Log.d("""", ""Disabling bank: ""+bank.getDbId());
					bank.disable();
				}

				BankdroidWidgetProvider.updateAppWidget(context, appWidgetManager, appWidgetId);
				return null;
			}","[('8', 'acquire', 'Bank'), ('9', 'check', 'bank'), ('14', 'check', 'bank'), ('16', 'release', 'connection'), ('27', 'release', 'bank')]","[(9, 'check', 'bank', 'Bank'), (16, 'release', 'bank', 'Bank')]"
