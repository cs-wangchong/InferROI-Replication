App name,Concerned Class,Fix revision,Buggy revision,Buggy method,Buggy file,Bug report,Use in experiments?,Code Inspection (B),Lint (B),FindBugs (B),PMD (B),Infer (B),Relda2-flow (B),Relda2-inflow (B),Verifier (B),Elite (B),Code Inspection (F),Lint (F),FindBugs (F),PMD (F),Infer (F),Relda2-flow (F),Relda2-inflow (F),Verifier (F),Elite (F),App component lifecycle-related,Resource escape local context,Leak extent,,Repo Link,Java class path,fix version link,buggy version link,buggy_content,fix_content,Pipe (B),Pipe (F),b_answer,f_answer
AnkiDroid,android.database.Cursor,d095337329,ff359989da,eta() @line 2585,Sched.java,Pull 275,yes,no,no,n/a,,yes,n/a,n/a,,,no,no,n/a,,yes,n/a,n/a,,,,no,complete leak,,https://github.com/ankidroid/Anki-Android,src/com/ichi2/libanki/Sched.java,https://github.com/ankidroid/Anki-Android/commit/d09533732992b714e42b82de8477e24a7cf0016b,https://github.com/ankidroid/Anki-Android/commit/ff359989da34ab0335e0a3e61646c49a213c0a4f,"public int eta(int[] counts, boolean reload) {
        double revYesRate;
        double revTime;
        double lrnYesRate;
        double lrnTime;
        if (reload || mEtaCache[0] == -1) {
            Cursor cur = null;
            try {
                cur = mCol
                        .getDb()
                        .getDatabase()
                        .rawQuery(
                                ""SELECT avg(CASE WHEN ease > 1 THEN 1.0 ELSE 0.0 END), avg(time) FROM revlog WHERE type = 1 AND id > ""
                                        + ((mCol.getSched().getDayCutoff() - (7 * 86400)) * 1000), null);
                if (!cur.moveToFirst()) {
                    return -1;
                }
                revYesRate = cur.getDouble(0);
                revTime = cur.getDouble(1);
                cur = mCol
                        .getDb()
                        .getDatabase()
                        .rawQuery(
                                ""SELECT avg(CASE WHEN ease = 3 THEN 1.0 ELSE 0.0 END), avg(time) FROM revlog WHERE type != 1 AND id > ""
                                        + ((mCol.getSched().getDayCutoff() - (7 * 86400)) * 1000), null);
                if (!cur.moveToFirst()) {
                    return -1;
                }
                lrnYesRate = cur.getDouble(0);
                lrnTime = cur.getDouble(1);
            } finally {
                if (cur != null && !cur.isClosed()) {
                    cur.close();
                }
            }
            mEtaCache[0] = revYesRate;
            mEtaCache[1] = revTime;
            mEtaCache[2] = lrnYesRate;
            mEtaCache[3] = lrnTime;
        } else {
            revYesRate = mEtaCache[0];
            revTime = mEtaCache[1];
            lrnYesRate = mEtaCache[2];
            lrnTime = mEtaCache[3];
        }
        // rev cards
        double eta = revTime * counts[2];
        // lrn cards
        double factor = Math.min(1 / (1 - lrnYesRate), 10);
        double lrnAnswers = (counts[0] + counts[1] + counts[2] * (1 - revYesRate)) * factor;
        eta += lrnAnswers * lrnTime;
        return (int) (eta / 60000);
    }","public int eta(int[] counts, boolean reload) {
        double revYesRate;
        double revTime;
        double lrnYesRate;
        double lrnTime;
        if (reload || mEtaCache[0] == -1) {
            Cursor cur = null;
            try {
                cur = mCol
                        .getDb()
                        .getDatabase()
                        .rawQuery(
                                ""SELECT avg(CASE WHEN ease > 1 THEN 1.0 ELSE 0.0 END), avg(time) FROM revlog WHERE type = 1 AND id > ""
                                        + ((mCol.getSched().getDayCutoff() - (7 * 86400)) * 1000), null);
                if (!cur.moveToFirst()) {
                    return -1;
                }
                revYesRate = cur.getDouble(0);
                revTime = cur.getDouble(1);

                if (cur != null && !cur.isClosed()) {
                    cur.close();
                }

                cur = mCol
                        .getDb()
                        .getDatabase()
                        .rawQuery(
                                ""SELECT avg(CASE WHEN ease = 3 THEN 1.0 ELSE 0.0 END), avg(time) FROM revlog WHERE type != 1 AND id > ""
                                        + ((mCol.getSched().getDayCutoff() - (7 * 86400)) * 1000), null);
                if (!cur.moveToFirst()) {
                    return -1;
                }
                lrnYesRate = cur.getDouble(0);
                lrnTime = cur.getDouble(1);
            } finally {
                if (cur != null && !cur.isClosed()) {
                    cur.close();
                }
            }
            mEtaCache[0] = revYesRate;
            mEtaCache[1] = revTime;
            mEtaCache[2] = lrnYesRate;
            mEtaCache[3] = lrnTime;
        } else {
            revYesRate = mEtaCache[0];
            revTime = mEtaCache[1];
            lrnYesRate = mEtaCache[2];
            lrnTime = mEtaCache[3];
        }
        // rev cards
        double eta = revTime * counts[2];
        // lrn cards
        double factor = Math.min(1 / (1 - lrnYesRate), 10);
        double lrnAnswers = (counts[0] + counts[1] + counts[2] * (1 - revYesRate)) * factor;
        eta += lrnAnswers * lrnTime;
        return (int) (eta / 60000);
    }",no,no,"No
Leaky Resources:
None

The code snippet provided does not appear to have any resource leaks. The Cursor object, which is a resource that needs to be managed, is properly closed in the finally block (lines 31-35). This ensures that the Cursor is closed whether the try block executes successfully or an exception is thrown.","No
Leaky Resources:
None

The code snippet provided does not appear to have any resource leaks. The Cursor object 'cur' which is a resource, is properly closed in a finally block, ensuring it gets closed whether an exception occurs or not."
AnkiDroid,android.database.Cursor,a694f4dedc,3e9ddc7eca,hasKey(),Deck.java,,yes,yes,no,n/a,,yes,n/a,n/a,,,yes,no,n/a,,no,n/a,n/a,,,,no,complete leak,,https://github.com/ankidroid/Anki-Android,src/com/ichi2/anki/Deck.java,https://github.com/ankidroid/Anki-Android/commit/a694f4dedca21e25221f3f5aa7d8f2f945b340e5,https://github.com/ankidroid/Anki-Android/commit/3e9ddc7eca6cd035e1cf6f82cb4e5d1e3b7220cf,"public boolean hasKey(String key) {
        return getDB().getDatabase().rawQuery(""SELECT 1 FROM deckVars WHERE key = '"" + key + ""'"", null).moveToNext();
    }","public boolean hasKey(String key) {
        Cursor cur = null;
        try {
            cur = getDB().getDatabase().rawQuery(""SELECT 1 FROM deckVars WHERE key = '"" + key + ""'"", null);
            return cur.moveToNext();
        } finally {
            if (cur != null) {
                cur.close();
            }	
        }
    }",no,no,"Yes
Leaky Resources:
Database Cursor","No
Leaky Resources:
None

The code snippet provided is properly handling the Cursor resource. It is correctly closed in the finally block, which ensures that the resource is released regardless of whether the try block executes successfully or not. Therefore, there are no resource leaks in this code snippet."
AnkiDroid,android.database.Cursor,c993a3398e,3725ce7582,upgradeDB() @line 91,MetaDB.java,Pull 4093,yes,yes,yes,n/a,,yes,n/a,n/a,,,yes,no,n/a,,no,n/a,n/a,,,,no,complete leak,,https://github.com/ankidroid/Anki-Android,AnkiDroid/src/main/java/com/ichi2/anki/MetaDB.java,https://github.com/ankidroid/Anki-Android/commit/c993a3398ec325672fd43307d8e2b457b3be9db7,https://github.com/ankidroid/Anki-Android/commit/3725ce75828aaf4fa0b7bc36416a973f2ea6a157,"private static SQLiteDatabase upgradeDB(SQLiteDatabase mMetaDb, int databaseVersion) {
        Timber.i(""MetaDB:: Upgrading Internal Database.."");
        // if (mMetaDb.getVersion() == 0) {
        Timber.i(""MetaDB:: Applying changes for version: 0"");
        if (mMetaDb.getVersion() < 4) {
            mMetaDb.execSQL(""DROP TABLE IF EXISTS languages;"");
            mMetaDb.execSQL(""DROP TABLE IF EXISTS customDictionary;"");
            mMetaDb.execSQL(""DROP TABLE IF EXISTS whiteboardState;"");
        }
        // Create tables if not exist
        mMetaDb.execSQL(""CREATE TABLE IF NOT EXISTS languages ("" + "" _id INTEGER PRIMARY KEY AUTOINCREMENT, ""
                + ""did INTEGER NOT NULL, ord INTEGER, "" + ""qa INTEGER, "" + ""language TEXT)"");
        mMetaDb.execSQL(""CREATE TABLE IF NOT EXISTS whiteboardState ("" + ""_id INTEGER PRIMARY KEY AUTOINCREMENT, ""
                + ""did INTEGER NOT NULL, "" + ""state INTEGER)"");
        mMetaDb.execSQL(""CREATE TABLE IF NOT EXISTS customDictionary ("" + ""_id INTEGER PRIMARY KEY AUTOINCREMENT, ""
                + ""did INTEGER NOT NULL, "" + ""dictionary INTEGER)"");
        mMetaDb.execSQL(""CREATE TABLE IF NOT EXISTS smallWidgetStatus ("" + ""id INTEGER PRIMARY KEY AUTOINCREMENT, ""
                + ""due INTEGER NOT NULL, eta INTEGER NOT NULL)"");
        // Use pragma to get info about widgetStatus.
        Cursor c = mMetaDb.rawQuery(""PRAGMA table_info(widgetStatus)"", null);
        int columnNumber = c.getCount();
        if (columnNumber > 0) {
            if (columnNumber < 7) {
                mMetaDb.execSQL(""ALTER TABLE widgetStatus "" + ""ADD COLUMN eta INTEGER NOT NULL DEFAULT '0'"");
                mMetaDb.execSQL(""ALTER TABLE widgetStatus "" + ""ADD COLUMN time INTEGER NOT NULL DEFAULT '0'"");
            }
        } else {
            mMetaDb.execSQL(""CREATE TABLE IF NOT EXISTS widgetStatus ("" + ""deckId INTEGER NOT NULL PRIMARY KEY, ""
                    + ""deckName TEXT NOT NULL, "" + ""newCards INTEGER NOT NULL, "" + ""lrnCards INTEGER NOT NULL, ""
                    + ""dueCards INTEGER NOT NULL, "" + ""progress INTEGER NOT NULL, "" + ""eta INTEGER NOT NULL)"");
        }
        mMetaDb.setVersion(databaseVersion);
        Timber.i(""MetaDB:: Upgrading Internal Database finished. New version: %d"", databaseVersion);
        return mMetaDb;
    }","private static SQLiteDatabase upgradeDB(SQLiteDatabase mMetaDb, int databaseVersion) {
        Timber.i(""MetaDB:: Upgrading Internal Database.."");
        // if (mMetaDb.getVersion() == 0) {
        Timber.i(""MetaDB:: Applying changes for version: 0"");

        if (mMetaDb.getVersion() < 4) {
            mMetaDb.execSQL(""DROP TABLE IF EXISTS languages;"");
            mMetaDb.execSQL(""DROP TABLE IF EXISTS customDictionary;"");
            mMetaDb.execSQL(""DROP TABLE IF EXISTS whiteboardState;"");
        }

        // Create tables if not exist
        mMetaDb.execSQL(""CREATE TABLE IF NOT EXISTS languages ("" + "" _id INTEGER PRIMARY KEY AUTOINCREMENT, ""
                + ""did INTEGER NOT NULL, ord INTEGER, "" + ""qa INTEGER, "" + ""language TEXT)"");
        mMetaDb.execSQL(""CREATE TABLE IF NOT EXISTS whiteboardState ("" + ""_id INTEGER PRIMARY KEY AUTOINCREMENT, ""
                + ""did INTEGER NOT NULL, "" + ""state INTEGER)"");
        mMetaDb.execSQL(""CREATE TABLE IF NOT EXISTS customDictionary ("" + ""_id INTEGER PRIMARY KEY AUTOINCREMENT, ""
                + ""did INTEGER NOT NULL, "" + ""dictionary INTEGER)"");
        mMetaDb.execSQL(""CREATE TABLE IF NOT EXISTS smallWidgetStatus ("" + ""id INTEGER PRIMARY KEY AUTOINCREMENT, ""
                + ""due INTEGER NOT NULL, eta INTEGER NOT NULL)"");
        // Use pragma to get info about widgetStatus.
        Cursor c = null;
        try {
             c = mMetaDb.rawQuery(""PRAGMA table_info(widgetStatus)"", null);
            int columnNumber = c.getCount();
            if (columnNumber > 0) {
                if (columnNumber < 7) {
                    mMetaDb.execSQL(""ALTER TABLE widgetStatus "" + ""ADD COLUMN eta INTEGER NOT NULL DEFAULT '0'"");
                    mMetaDb.execSQL(""ALTER TABLE widgetStatus "" + ""ADD COLUMN time INTEGER NOT NULL DEFAULT '0'"");
                }
            } else {
                mMetaDb.execSQL(""CREATE TABLE IF NOT EXISTS widgetStatus ("" + ""deckId INTEGER NOT NULL PRIMARY KEY, ""
                        + ""deckName TEXT NOT NULL, "" + ""newCards INTEGER NOT NULL, "" + ""lrnCards INTEGER NOT NULL, ""
                        + ""dueCards INTEGER NOT NULL, "" + ""progress INTEGER NOT NULL, "" + ""eta INTEGER NOT NULL)"");
            }
            mMetaDb.setVersion(databaseVersion);
            Timber.i(""MetaDB:: Upgrading Internal Database finished. New version: %d"", databaseVersion);
            return mMetaDb;
        } finally {
            if (c != null) {
                c.close();
            }
        }
    }",no,no,"Yes
Leaky Resources:
Cursor","No
Leaky Resources: None

The provided code snippet does not seem to have any resource leaks. The database and cursor resources are properly managed. The cursor is closed in the finally block which ensures that it gets closed even if an exception occurs. The database resource is returned and it's the responsibility of the calling function to close it when it's no longer needed."
AnySoftKeyboard,android.database.Cursor,cc8c1c8fa4,b832671708,addWords(),ContactsDictionary.java,,yes,no,no,n/a,,no,n/a,n/a,,,no,no,n/a,,no,n/a,n/a,,,,yes,leak on certain normal paths,,https://github.com/AnySoftKeyboard/AnySoftKeyboard,src/com/menny/android/anysoftkeyboard/dictionary/ContactsDictionary.java,https://github.com/AnySoftKeyboard/AnySoftKeyboard/commit/cc8c1c8fa4e34baf1e2b23b0abb3897a331f2619,https://github.com/AnySoftKeyboard/AnySoftKeyboard/commit/b832671708e8f5c5763ed81ac707dad40f6308aa,"private void addWords(Cursor cursor) {
    	int newCount = 0;
    	long newHash = 0;
    	//first checking if something has changed
    	if (cursor.moveToFirst()) {
            while (!cursor.isAfterLast()) {
                String name = cursor.getString(INDEX_NAME);
                if(name != null){
                    newHash += name.hashCode();
                    newCount++;
                }
                cursor.moveToNext();
            }
    	}
    	
    	if (newCount == mContactsCount  && newHash == mContactsHash )
    	{
    	    return;
    	}
    		if (AnySoftKeyboardConfiguration.DEBUG) Log.d(TAG, ""Contacts will be reloaded since count or hash changed. New count ""+newCount+"" was(""+mContactsCount+""), new hash ""+newHash+"" (was ""+mContactsHash+"")."");
    		mContactsCount = newCount;
    		mContactsHash = newHash;
    		
    		clearDictionary();
            int loadedContacts = 0;
            final int maxWordLength = MAX_WORD_LENGTH;
            if (cursor.moveToFirst()) {
                while (!cursor.isAfterLast()) {
                    String name = cursor.getString(INDEX_NAME);

                    if (name != null) {
                        int len = name.length();

                        // TODO: Better tokenization for non-Latin writing systems
                        for (int i = 0; i < len; i++) {
                            if (Character.isLetter(name.charAt(i))) {
                                int j;
                                for (j = i + 1; j < len; j++) {
                                    char c = name.charAt(j);

                                    if (!(c == '-' || c == '\'' ||
                                          Character.isLetter(c))) {
                                        break;
                                    }
                                }

                                String word = name.substring(i, j);
                                i = j - 1;

                                // Safeguard against adding really long words. Stack
                                // may overflow due to recursion
                                // Also don't add single letter words, possibly confuses
                                // capitalization of i.
                                final int wordLen = word.length();
                                if (wordLen < maxWordLength && wordLen > 1) {
                                	if (AnySoftKeyboardConfiguration.DEBUG)
                                		Log.d(TAG, ""Contact '""+word+""' will be added to contacts dictionary."");
                                	loadedContacts++;
                                    super.addWord(word, 128);
                                }
                            }
                        }
                    }

                    cursor.moveToNext();
                }
            }
            
            Log.i(TAG, ""Loaded ""+loadedContacts+"" contacts"");
    	
        
        cursor.close();
    }","private void addWords(Cursor cursor) {
    	int newCount = 0;
    	long newHash = 0;
    	//first checking if something has changed
    	if (cursor.moveToFirst()) {
            while (!cursor.isAfterLast()) {
                String name = cursor.getString(INDEX_NAME);
                if(name != null){
                    newHash += name.hashCode();
                    newCount++;
                }
                cursor.moveToNext();
            }
    	}
    	
    	if (newCount == mContactsCount  && newHash == mContactsHash )
    	{
    	    cursor.close();
    	    return;
    	    
    	}
    		if (AnySoftKeyboardConfiguration.DEBUG) Log.d(TAG, ""Contacts will be reloaded since count or hash changed. New count ""+newCount+"" was(""+mContactsCount+""), new hash ""+newHash+"" (was ""+mContactsHash+"")."");
    		mContactsCount = newCount;
    		mContactsHash = newHash;
    		
    		clearDictionary();
            int loadedContacts = 0;
            final int maxWordLength = MAX_WORD_LENGTH;
            if (cursor.moveToFirst()) {
                while (!cursor.isAfterLast()) {
                    String name = cursor.getString(INDEX_NAME);

                    if (name != null) {
                        int len = name.length();

                        // TODO: Better tokenization for non-Latin writing systems
                        for (int i = 0; i < len; i++) {
                            if (Character.isLetter(name.charAt(i))) {
                                int j;
                                for (j = i + 1; j < len; j++) {
                                    char c = name.charAt(j);

                                    if (!(c == '-' || c == '\'' ||
                                          Character.isLetter(c))) {
                                        break;
                                    }
                                }

                                String word = name.substring(i, j);
                                i = j - 1;

                                // Safeguard against adding really long words. Stack
                                // may overflow due to recursion
                                // Also don't add single letter words, possibly confuses
                                // capitalization of i.
                                final int wordLen = word.length();
                                if (wordLen < maxWordLength && wordLen > 1) {
                                	if (AnySoftKeyboardConfiguration.DEBUG)
                                		Log.d(TAG, ""Contact '""+word+""' will be added to contacts dictionary."");
                                	loadedContacts++;
                                    super.addWord(word, 128);
                                }
                            }
                        }
                    }

                    cursor.moveToNext();
                }
            }
            
            Log.i(TAG, ""Loaded ""+loadedContacts+"" contacts"");
    	
        
        cursor.close();
    }",no,no,"Yes
Leaky Resources:
Cursor","Yes
Leaky Resources:
Cursor

Explanation:
In the provided code snippet, the Cursor object 'cursor' is not properly managed. It is closed only in two places: line 18 and line 74. However, there are several paths through the code that do not lead to the cursor being closed. For example, if an exception occurs before reaching these lines, the cursor will not be closed, leading to a resource leak. 

To avoid this, the cursor should be managed in a try-finally block. This ensures that the cursor is closed no matter what happens in the try block."
AnySoftKeyboard,android.database.Cursor,f3ec3698f0,4b7d714258,doInBackground(),UserDictionaryEditorActivity.java,,yes,yes,yes,n/a,,yes,n/a,n/a,,,yes,no,n/a,,no,n/a,n/a,,,,no,complete leak,,https://github.com/AnySoftKeyboard/AnySoftKeyboard,src/com/anysoftkeyboard/ui/settings/UserDictionaryEditorActivity.java,https://github.com/AnySoftKeyboard/AnySoftKeyboard/commit/f3ec3698f0a20d4a94b92a0ef522e0a9548a1405,https://github.com/AnySoftKeyboard/AnySoftKeyboard/commit/4b7d7142583554833dac2516c4351cb7c03ff974,"@Override
      protected String[] doInBackground(Void... params) {
       try
       {
        Cursor langsCursor = getContentResolver().query(UserDictionary.Words.CONTENT_URI, 
          new String[]{UserDictionary.Words.LOCALE},
          null, null, null);
        if (langsCursor == null) throw new NullPointerException(""No device-wide user dictionary"");
        langsCursor.moveToFirst();
        ArrayList<String> langs = new ArrayList<String>();
        while(!langsCursor.isAfterLast())
        {
         String locale = langsCursor.getString(0);
         langsCursor.moveToNext();
         if (TextUtils.isEmpty(locale)) continue;
         if (langs.contains(locale)) continue;
         langs.add(locale);
        }

        return langs.toArray(new String[langs.size()]);
       }
       catch(Exception e)
       {
        //TODO: Use ASK fallback
        e.printStackTrace();
       }

       return new String[]{""en""};
      }","@Override
    		protected String[] doInBackground(Void... params) {
    			try
    			{
    				Cursor langsCursor = getContentResolver().query(UserDictionary.Words.CONTENT_URI, 
    						new String[]{UserDictionary.Words.LOCALE},
    						null, null, null);
    				if (langsCursor == null) throw new NullPointerException(""No device-wide user dictionary"");
    				langsCursor.moveToFirst();
    				ArrayList<String> langs = new ArrayList<String>();
    				while(!langsCursor.isAfterLast())
    				{
    					String locale = langsCursor.getString(0);
    					langsCursor.moveToNext();
    					if (TextUtils.isEmpty(locale)) continue;
    					if (langs.contains(locale)) continue;
    					Log.d(TAG, ""Adding locale ""+locale+"" to editor."");
    					langs.add(locale);
    				}
    				
    				langsCursor.close();
    				//now to add all layouts locales
    				ArrayList<KeyboardAddOnAndBuilder> keyboards = KeyboardFactory.getAllAvailableKeyboards(getApplicationContext());
    				for(KeyboardAddOnAndBuilder kbd : keyboards)
    				{
    					String locale = kbd.getKeyboardLocale();
    					if (TextUtils.isEmpty(locale)) continue;
    					if (langs.contains(locale)) continue;
    					Log.d(TAG, ""Adding locale ""+locale+"" to editor."");
    					langs.add(locale);
    				}
    				return langs.toArray(new String[langs.size()]);
    			}
    			catch(Exception e)
    			{
    				//TODO: Use ASK fallback
    				e.printStackTrace();
    			}
    			
    			return new String[]{};
    		}",no,no,"Yes
Leaky Resources:
Cursor","No
Leaky Resources: None

The code snippet provided does not seem to have any resource leaks. The Cursor object 'langsCursor' which is a common cause of resource leaks in Android if not managed properly, is closed properly at line 21. There are no other resources such as streams, database connections, etc. opened in the code that could potentially cause a resource leak."
Osmand,android.database.Cursor,d82036938a,99ba127f50,indexCachedResources(),HillshadeLayer.java,Pull 649,yes,yes,no,n/a,,yes,n/a,n/a,,,yes,no,n/a,,no,n/a,n/a,,,,no,leak on certain normal paths,,https://github.com/osmandapp/Osmand,OsmAnd/src/net/osmand/plus/srtmplugin/HillshadeLayer.java,https://github.com/osmandapp/Osmand/commit/d82036938acf78efc8bbdbd22697581ed963aaea,https://github.com/osmandapp/Osmand/commit/99ba127f50cd590b59ac80ff7850b03582d04832,"private void indexCachedResources(Map<String, Long> fileModified, Map<String, SQLiteTileSource> rs) {
				Cursor cursor = sqliteDb.rawQuery(""SELECT filename, date_modified, left, right, top, bottom FROM TILE_SOURCES"", 
						new String[0]);
				if(cursor.moveToFirst()) {
					do {
						String filename = cursor.getString(0);
						long lastModified = cursor.getLong(1);
						Long read = fileModified.get(filename);
						if(rs.containsKey(filename) && read != null && lastModified == read) {
							int left = cursor.getInt(2);
							int right = cursor.getInt(3);
							int top = cursor.getInt(4);
							float bottom = cursor.getInt(5);
							indexedResources.insert(filename, new QuadRect(left, top, right, bottom));
							fileModified.remove(filename);
						}
						
					} while(cursor.moveToNext());
					cursor.close();
				}
			}","private void indexCachedResources(Map<String, Long> fileModified, Map<String, SQLiteTileSource> rs) {
				Cursor cursor = sqliteDb.rawQuery(""SELECT filename, date_modified, left, right, top, bottom FROM TILE_SOURCES"", 
						new String[0]);
				if(cursor.moveToFirst()) {
					do {
						String filename = cursor.getString(0);
						long lastModified = cursor.getLong(1);
						Long read = fileModified.get(filename);
						if(rs.containsKey(filename) && read != null && lastModified == read) {
							int left = cursor.getInt(2);
							int right = cursor.getInt(3);
							int top = cursor.getInt(4);
							float bottom = cursor.getInt(5);
							indexedResources.insert(filename, new QuadRect(left, top, right, bottom));
							fileModified.remove(filename);
						}
						
					} while(cursor.moveToNext());
				}
				cursor.close();
			}",no,no,"Yes
Leaky Resources:
Cursor","No
Leaky Resources: None

The code snippet provided does not appear to have any resource leaks. The Cursor object, which is a resource that needs to be managed, is properly closed at line 20. This ensures that the database resource it was using is freed up."
SMSDroid,android.database.Cursor,5020594a25,3aa0d074ae,getConversation() @line 238,Conversation.java,,yes,no,no,n/a,,yes,n/a,n/a,,,no,no,n/a,,yes,n/a,n/a,,,,no,complete leak,,https://github.com/felixb/smsdroid,src/de/ub0r/android/smsdroid/Conversation.java,https://github.com/felixb/smsdroid/commit/5020594a25c7dd1d77b5e4571bce2135f4a17138,https://github.com/felixb/smsdroid/commit/3aa0d074ae2b952fa623a0c095f41fb4d610884b,"	public static Conversation getConversation(final Context context,
			final int threadId, final boolean forceUpdate) {
		synchronized (CACHE) {
			Conversation ret = CACHE.get(threadId);
			if (ret == null || ret.getAddress() == null || forceUpdate) {
				Cursor cursor = context.getContentResolver().query(
						ConversationProvider.CONTENT_URI,
						ConversationProvider.PROJECTION,
						ConversationProvider.PROJECTION[// .
								ConversationProvider.INDEX_THREADID]
								+ "" = "" + threadId, null, null);
				if (cursor != null && cursor.moveToFirst()) {
					return getConversation(context, cursor, true);
				} else {
					Log.e(TAG, ""did not found conversation: "" + threadId);
				}
			}
			return ret;
		}
	}
","	public static Conversation getConversation(final Context context,
			final Cursor cursor, final boolean sync) {
		synchronized (CACHE) {
			Conversation ret = CACHE.get(cursor
					.getInt(ConversationProvider.INDEX_THREADID));
			if (ret == null) {
				ret = new Conversation(context, cursor, sync);
				CACHE.put(ret.getThreadId(), ret);
				Log.d(TAG, ""cachesize: "" + CACHE.size());
				while (CACHE.size() > CAHCESIZE) {
					Integer i = CACHE.keySet().iterator().next();
					Log.d(TAG, ""rm con. from cache: "" + i);
					Conversation cc = CACHE.remove(i);
					if (cc == null) {
						Log.w(TAG, ""CACHE might be inconsistent!"");
						break;
					}
				}
			} else {
				ret.update(context, cursor, sync);
			}
			return ret;
		}
	}
",no,no,"Yes
Leaky Resources:
Cursor","No
Leaky Resources:
None"
Google Authenticator,android.database.Cursor,89a1b41e2b,f7dee7574d,nameExists(),AccountDb.java,,yes,yes,yes,n/a,,yes,n/a,n/a,,,no,no,n/a,,no,n/a,n/a,,,,yes,complete leak,,https://github.com/google/google-authenticator,mobile/android/src/com/google/android/apps/authenticator/AccountDb.java,https://github.com/google/google-authenticator/commit/89a1b41e2ba7e80ef3df0056b2e83408608f6ad3,https://github.com/google/google-authenticator/commit/f7dee7574d30fb7f948acdc1ccc9fe2e0fcdc432,"static boolean nameExists(String email) {
    Cursor cursor = DATABASE.query(TABLE_NAME, null, EMAIL_COLUMN + ""= ?"",
        new String[] {email}, null, null, null);
    if (cursor != null && cursor.getCount() > 0) {
      return true;
    } else {
      return false;
    }
  }","  static boolean nameExists(String email) {
    Cursor cursor = getAccount(email);
    try {
      return !cursorIsEmpty(cursor);
    } finally {
      tryCloseCursor(cursor);
    }
  }
",no,no,"Yes
Leaky Resources:
Cursor","No
Leaky Resources:
None"
Google Authenticator,android.database.Cursor,89a1b41e2b,f7dee7574d,getSecret(),AccountDb.java,,yes,yes,yes,n/a,,yes,n/a,n/a,,,no,no,n/a,,no,n/a,n/a,,,,yes,complete leak,,https://github.com/google/google-authenticator,mobile/android/src/com/google/android/apps/authenticator/AccountDb.java,https://github.com/google/google-authenticator/commit/89a1b41e2ba7e80ef3df0056b2e83408608f6ad3,https://github.com/google/google-authenticator/commit/f7dee7574d30fb7f948acdc1ccc9fe2e0fcdc432,"static String getSecret(String email) {
    Cursor cursor = DATABASE.query(TABLE_NAME, null, EMAIL_COLUMN + ""= ?"",
        new String[] {email}, null, null, null);
    if (cursor != null && cursor.getCount() > 0) {
      cursor.moveToFirst();
      return cursor.getString(cursor.getColumnIndex(SECRET_COLUMN));
    } 
    return null;   
  }","  static String getSecret(String email) {
    Cursor cursor = getAccount(email);
    try {
      if (!cursorIsEmpty(cursor)) {
        cursor.moveToFirst();
        return cursor.getString(cursor.getColumnIndex(SECRET_COLUMN));
      }
    } finally {
      tryCloseCursor(cursor);
    }
    return null;   
  }
",no,no,"Yes
Leaky Resources:
Cursor","No
Leaky Resources:
None"
Google Authenticator,android.database.Cursor,89a1b41e2b,f7dee7574d,getCounter(),AccountDb.java,,yes,yes,yes,n/a,,yes,n/a,n/a,,,no,no,n/a,,no,n/a,n/a,,,,yes,complete leak,,https://github.com/google/google-authenticator,mobile/android/src/com/google/android/apps/authenticator/AccountDb.java,https://github.com/google/google-authenticator/commit/89a1b41e2ba7e80ef3df0056b2e83408608f6ad3,https://github.com/google/google-authenticator/commit/f7dee7574d30fb7f948acdc1ccc9fe2e0fcdc432,"static Integer getCounter(String email) {
    Cursor cursor = DATABASE.query(TABLE_NAME, null, EMAIL_COLUMN + ""= ?"", 
        new String[] {email}, null, null, null);
    if (cursor != null && cursor.getCount() > 0) {
      cursor.moveToFirst();
      return cursor.getInt(cursor.getColumnIndex(COUNTER_COLUMN));
    } 
    return null;   
  }","  static Integer getCounter(String email) {
    Cursor cursor = getAccount(email);
    try {
      if (!cursorIsEmpty(cursor)) {
        cursor.moveToFirst();
        return cursor.getInt(cursor.getColumnIndex(COUNTER_COLUMN));
      } 
    } finally {
      tryCloseCursor(cursor);
    }
    return null;   
  }
",no,no,"Yes
Leaky Resources:
Cursor","No
Leaky Resources:
None"
Google Authenticator,android.database.Cursor,89a1b41e2b,f7dee7574d,getType(),AccountDb.java,,yes,yes,yes,n/a,,yes,n/a,n/a,,,no,no,n/a,,no,n/a,n/a,,,,yes,complete leak,,https://github.com/google/google-authenticator,mobile/android/src/com/google/android/apps/authenticator/AccountDb.java,https://github.com/google/google-authenticator/commit/89a1b41e2ba7e80ef3df0056b2e83408608f6ad3,https://github.com/google/google-authenticator/commit/f7dee7574d30fb7f948acdc1ccc9fe2e0fcdc432,"static OtpType getType(String email) {
    Cursor cursor = DATABASE.query(TABLE_NAME, null, EMAIL_COLUMN + ""= ?"", 
        new String[] {email}, null, null, null);
    if (cursor != null && cursor.getCount() > 0) {
      cursor.moveToFirst();
      Integer value = cursor.getInt(cursor.getColumnIndex(TYPE_COLUMN));
      return OtpType.getEnum(value);
    } 
    return null;   
  }","  static OtpType getType(String email) {
    Cursor cursor = getAccount(email);
    try {
      if (!cursorIsEmpty(cursor)) {
        cursor.moveToFirst();
        Integer value = cursor.getInt(cursor.getColumnIndex(TYPE_COLUMN));
        return OtpType.getEnum(value);
      } 
    } finally {
      tryCloseCursor(cursor);
    }
    return null;   
  }
",no,no,"Yes
Leaky Resources:
Cursor","No
Leaky Resources:
None"
Google Authenticator,android.database.Cursor,89a1b41e2b,f7dee7574d,refreshUserList(),AuthenticatorActivity.java,,yes,yes,no,n/a,,yes,n/a,n/a,,,no,no,n/a,,no,n/a,n/a,,,,yes,complete leak,,https://github.com/google/google-authenticator,mobile/android/src/com/google/android/apps/authenticator/AuthenticatorActivity.java,https://github.com/google/google-authenticator/commit/89a1b41e2ba7e80ef3df0056b2e83408608f6ad3,https://github.com/google/google-authenticator/commit/f7dee7574d30fb7f948acdc1ccc9fe2e0fcdc432,"protected void refreshUserList() {
    
    // If the users have changed, let the (potentially running) widget know it needs to be
    // updated
    Intent intent = new Intent(AuthenticatorWidget.WidgetReceiver.APPWIDGET_UPDATE);
    intent.setClass(this, AuthenticatorWidget.WidgetReceiver.class);
    sendBroadcast(intent);
    
    Cursor cursor = AccountDb.getNames();
    int index = cursor.getColumnIndex(AccountDb.EMAIL_COLUMN);
    if (cursor.requery() && cursor.getCount() > 0) {
      if (mUsers.length != cursor.getCount()) {
        mUsers = new PinInfo[cursor.getCount()];
      }
      for (int i = 0; i < cursor.getCount(); i++) {
        cursor.moveToPosition(i);
        String user = cursor.getString(index);
        Log.i(TAG, ""onResume user: "" + user);
        computeAndDisplayPin(user, i, false);
      }

      mUserAdapter = new PinListAdapter(this, mUsers);
      mUserList.setAdapter(mUserAdapter); // force refresh of display

      if (mUserList.getVisibility() != View.VISIBLE) {
        mEnterPinTextView.setText(R.string.enter_pin);
        mEnterPinTextView.setVisibility(View.VISIBLE);
        mUserList.setVisibility(View.VISIBLE);
        registerForContextMenu(mUserList);
      }

    } else {
      // If the user started up this app but there is no secret key yet,
      // then tell the user to visit a web page to get the secret key.
      mUsers = new PinInfo[0]; // clear any existing user PIN state 
      tellUserToGetSecretKey();
    }
  }","  protected void refreshUserList() {
    refreshUserList(false);
  }
",no,no,"Yes
Leaky Resources:
Cursor","No
Leaky Resources:
None

The provided code snippet does not contain any information about resource allocation or usage, so it's impossible to identify any resource leaks from it."
Bankdroid,android.database.Cursor,f4fbbfd966,1747b81da8,accountFromDb() @line 191,BankFactory.java,,yes,yes,no,n/a,,yes,n/a,n/a,,,yes,no,n/a,,no,n/a,n/a,,,,no,complete leak,,https://github.com/liato/android-bankdroid,src/com/liato/bankdroid/BankFactory.java,https://github.com/liato/android-bankdroid/commit/f4fbbfd966a25a9c2e4b0a5aca381b47c2f36ac1,https://github.com/liato/android-bankdroid/commit/1747b81da807e5ea03f2e2e26b890e013b80e3a7,"public static Account accountFromDb(Context context, String accountId, boolean loadTransactions) {
  DBAdapter db = new DBAdapter(context);
  db.open();
  Cursor c = db.getAccount(accountId);
  if (c == null || c.isClosed() || (c.isBeforeFirst() && c.isAfterLast())) {
   db.close();
   return null;
  }
  Account account = new Account(c.getString(c.getColumnIndex(""name"")),
                                      new BigDecimal(c.getString(c.getColumnIndex(""balance""))),
                                      c.getString(c.getColumnIndex(""id"")).split(""_"")[1],
                                      c.getLong(c.getColumnIndex(""bankid"")),
                                      c.getInt(c.getColumnIndex(""acctype"")));
        account.setHidden(c.getInt(c.getColumnIndex(""hidden"")) == 1 ? true : false);
        account.setNotify(c.getInt(c.getColumnIndex(""notify"")) == 1 ? true : false);
        account.setCurrency(c.getString(c.getColumnIndex(""currency"")));
  c.close();
  if (loadTransactions) {
   ArrayList<Transaction> transactions = new ArrayList<Transaction>();
   //""transdate"", ""btransaction"", ""amount""}   
   c = db.fetchTransactions(accountId);
   if (!(c == null || c.isClosed() || (c.isBeforeFirst() && c.isAfterLast()))) {
    while (!c.isLast() && !c.isAfterLast()) {
     c.moveToNext();
     transactions.add(new Transaction(c.getString(c.getColumnIndex(""transdate"")),
                                     c.getString(c.getColumnIndex(""btransaction"")),
                                     new BigDecimal(c.getString(c.getColumnIndex(""amount""))),
                                     c.getString(c.getColumnIndex(""currency""))));
    }
   }
   account.setTransactions(transactions);
  }
  
  db.close();
  return account;
 }","public static Account accountFromDb(Context context, String accountId, boolean loadTransactions) {
		DBAdapter db = new DBAdapter(context);
		db.open();
		Cursor c = db.getAccount(accountId);
		if (c == null || c.isClosed() || (c.isBeforeFirst() && c.isAfterLast())) {
			db.close();
			return null;
		}

		Account account = new Account(c.getString(c.getColumnIndex(""name"")),
                                      new BigDecimal(c.getString(c.getColumnIndex(""balance""))),
                                      c.getString(c.getColumnIndex(""id"")).split(""_"")[1],
                                      c.getLong(c.getColumnIndex(""bankid"")),
                                      c.getInt(c.getColumnIndex(""acctype"")));
        account.setHidden(c.getInt(c.getColumnIndex(""hidden"")) == 1 ? true : false);
        account.setNotify(c.getInt(c.getColumnIndex(""notify"")) == 1 ? true : false);
        account.setCurrency(c.getString(c.getColumnIndex(""currency"")));
		c.close();
		if (loadTransactions) {
			ArrayList<Transaction> transactions = new ArrayList<Transaction>();
			//""transdate"", ""btransaction"", ""amount""}			
			c = db.fetchTransactions(accountId);
			if (!(c == null || c.isClosed() || (c.isBeforeFirst() && c.isAfterLast()))) {
				while (!c.isLast() && !c.isAfterLast()) {
					c.moveToNext();
					transactions.add(new Transaction(c.getString(c.getColumnIndex(""transdate"")),
                                     c.getString(c.getColumnIndex(""btransaction"")),
                                     new BigDecimal(c.getString(c.getColumnIndex(""amount""))),
                                     c.getString(c.getColumnIndex(""currency""))));
				}
				c.close();
			}
			account.setTransactions(transactions);
		}
		
		db.close();
		return account;
	}",no,no,"Yes
Leaky Resources:
Database Connection, Cursor","Yes
Leaky Resources:
Database Connection

Explanation:
In the provided code snippet, the database connection is opened at line 3 and closed at line 6 if the cursor is null or closed or before the first and after the last. However, if these conditions are not met, the database connection remains open until line 36. This could potentially lead to a resource leak if an exception occurs between these lines of code, as the database connection would not be closed. 

To avoid this, it is recommended to use a try-finally block or try-with-resources statement (if using Java 7 or later) to ensure that the database connection is closed even if an exception occurs."
OSMTracker,android.database.Cursor,a4617bc3d4,f66282f5c7,deleteAllTracks(),TrackManager.java,,yes,yes,yes,n/a,,yes,n/a,n/a,,,yes,no,n/a,,no,n/a,n/a,,,,no,complete leak,,https://github.com/nguillaumin/osmtracker-android,src/me/guillaumin/android/osmtracker/activity/TrackManager.java,https://github.com/nguillaumin/osmtracker-android/commit/a4617bc3d49ddd5afd216e14dc88d213126080fc,https://github.com/nguillaumin/osmtracker-android/commit/f66282f5c702cb313ad1d12be83b23af9e255187,"private void deleteAllTracks() {
		Cursor cursor = getContentResolver().query(TrackContentProvider.CONTENT_URI_TRACK, null, null, null, Schema.COL_START_DATE + "" asc"");

		// Stop any currently active tracks
		if (currentTrackId != -1) {
			stopActiveTrack();
		}

		if (cursor.moveToFirst()) {
			int id_col = cursor.getColumnIndex(""_id"");
			do {
				deleteTrack(cursor.getLong(id_col));
			} while (cursor.moveToNext());
		}
	}","private void deleteAllTracks() {
		Cursor cursor = getContentResolver().query(TrackContentProvider.CONTENT_URI_TRACK, null, null, null, Schema.COL_START_DATE + "" asc"");

		// Stop any currently active tracks
		if (currentTrackId != -1) {
			stopActiveTrack();
		}

		if (cursor.moveToFirst()) {
			int id_col = cursor.getColumnIndex(""_id"");
			do {
				deleteTrack(cursor.getLong(id_col));
			} while (cursor.moveToNext());
		}
		cursor.close();
	}",no,no,"Yes
Leaky Resources:
Cursor","No
Leaky Resources:
None"
OSMTracker,android.database.Cursor,a4617bc3d4,f66282f5c7,manageNewStoragePath(),DatabaseHelper.java,,yes,yes,yes,n/a,,yes,n/a,n/a,,,yes,no,n/a,,no,n/a,n/a,,,,no,complete leak,,https://github.com/nguillaumin/osmtracker-android,src/me/guillaumin/android/osmtracker/db/DatabaseHelper.java,https://github.com/nguillaumin/osmtracker-android/commit/a4617bc3d49ddd5afd216e14dc88d213126080fc,https://github.com/nguillaumin/osmtracker-android/commit/f66282f5c702cb313ad1d12be83b23af9e255187,"	@SuppressWarnings(""deprecation"")
	private void manageNewStoragePath(SQLiteDatabase db){
		Log.d(TAG,""manageNewStoragePath"");
		
		// we'll need this FilenameFitler to clean up our track directory
		FilenameFilter gpxFilenameFilter = new FilenameFilter() {
			@Override
			public boolean accept(File dir, String filename) {
				if(filename.toLowerCase().endsWith("".gpx""))
					return true;
				return false;
			}
		};
		
		// query all tracks
		String[] columns = new String[]{Schema.COL_ID, Schema.COL_DIR};
		Cursor cursor = db.query(Schema.TBL_TRACK, columns, null, null, null, null, null);
		
		// if we have a valid cursor and can write to the sdcard, we'll go on and try to copy the files
		if(cursor != null && cursor.moveToFirst()){
			Log.d(TAG, ""manageNewStoragePath (found "" + cursor.getCount() + "" tracks to be processed)"");
			do{
				long trackId = cursor.getLong(cursor.getColumnIndex(Schema.COL_ID));
				Log.d(TAG,""manageNewStoragePath ("" + trackId + "")"");
				String oldDirName = cursor.getString(cursor.getColumnIndex(Schema.COL_DIR));
				File newDir = DataHelper.getTrackDirectory(trackId);
				File oldDir = new File(oldDirName);
				if(oldDir.exists() && oldDir.canRead()){
					
					// if our new directory doesn't exist, we'll create it
					if(!newDir.exists())
						newDir.mkdirs();
					
					if(newDir.exists() && newDir.canWrite()){
						Log.d(TAG,""manageNewStoragePath ("" + trackId + ""): copy directory"");
						// we'll first copy all files to our new storage area... we'll clean up later
						FileSystemUtils.copyDirectoryContents(newDir, oldDir);
						
						// cleaning up new storage area
						// find gpx files we accidentally copied to our new storage area and delete them 
						for(File gpxFile:newDir.listFiles(gpxFilenameFilter)){
							Log.d(TAG,""manageNewStoragePath ("" + trackId + ""): deleting gpx file [""+gpxFile+""]"");
							gpxFile.delete();
						}
					}else{
						Log.e(TAG, ""manageNewStoragePath ("" + trackId + ""): directory [""+newDir+""] is not writable or could not be created"");
					}
					
				}
			}while(cursor.moveToNext());
		}
		
		ContentValues vals = new ContentValues();
		vals.putNull(Schema.COL_DIR);
		db.update(Schema.TBL_TRACK, vals, null, null);
	}
","	@SuppressWarnings(""deprecation"")
	private void manageNewStoragePath(SQLiteDatabase db){
		Log.d(TAG,""manageNewStoragePath"");
		
		// we'll need this FilenameFitler to clean up our track directory
		FilenameFilter gpxFilenameFilter = new FilenameFilter() {
			@Override
			public boolean accept(File dir, String filename) {
				if(filename.toLowerCase().endsWith("".gpx""))
					return true;
				return false;
			}
		};
		
		// query all tracks
		String[] columns = new String[]{Schema.COL_ID, Schema.COL_DIR};
		Cursor cursor = db.query(Schema.TBL_TRACK, columns, null, null, null, null, null);
		
		// if we have a valid cursor and can write to the sdcard, we'll go on and try to copy the files
		if(cursor != null && cursor.moveToFirst()){
			Log.d(TAG, ""manageNewStoragePath (found "" + cursor.getCount() + "" tracks to be processed)"");
			do{
				long trackId = cursor.getLong(cursor.getColumnIndex(Schema.COL_ID));
				Log.d(TAG,""manageNewStoragePath ("" + trackId + "")"");
				String oldDirName = cursor.getString(cursor.getColumnIndex(Schema.COL_DIR));
				File newDir = DataHelper.getTrackDirectory(trackId);
				File oldDir = new File(oldDirName);
				if(oldDir.exists() && oldDir.canRead()){
					
					// if our new directory doesn't exist, we'll create it
					if(!newDir.exists())
						newDir.mkdirs();
					
					if(newDir.exists() && newDir.canWrite()){
						Log.d(TAG,""manageNewStoragePath ("" + trackId + ""): copy directory"");
						// we'll first copy all files to our new storage area... we'll clean up later
						FileSystemUtils.copyDirectoryContents(newDir, oldDir);
						
						// cleaning up new storage area
						// find gpx files we accidentally copied to our new storage area and delete them 
						for(File gpxFile:newDir.listFiles(gpxFilenameFilter)){
							Log.d(TAG,""manageNewStoragePath ("" + trackId + ""): deleting gpx file [""+gpxFile+""]"");
							gpxFile.delete();
						}
					}else{
						Log.e(TAG, ""manageNewStoragePath ("" + trackId + ""): directory [""+newDir+""] is not writable or could not be created"");
					}
					
				}
			}while(cursor.moveToNext());
			
			cursor.close();
		}
		
		ContentValues vals = new ContentValues();
		vals.putNull(Schema.COL_DIR);
		db.update(Schema.TBL_TRACK, vals, null, null);
	}
",no,no,"Yes
Leaky Resources:
Cursor","No
Leaky Resources: None

The provided code snippet does not seem to have any resource leaks. The database cursor is properly closed after use (line 52). The file resources are also properly handled and there is no evidence of file streams being left open."
OSMTracker,android.database.Cursor,a4617bc3d4,f66282f5c7,readExtraInformation() @line 63,Track.java,,yes,yes,yes,n/a,,yes,n/a,n/a,,,yes,no,n/a,,no,n/a,n/a,,,,no,complete leak,,https://github.com/nguillaumin/osmtracker-android,src/me/guillaumin/android/osmtracker/db/model/Track.java,https://github.com/nguillaumin/osmtracker-android/commit/a4617bc3d49ddd5afd216e14dc88d213126080fc,https://github.com/nguillaumin/osmtracker-android/commit/f66282f5c702cb313ad1d12be83b23af9e255187,"private void readExtraInformation(){
    if(!extraInformationRead){
        Cursor startCursor = cr.query(TrackContentProvider.trackStartUri(trackId), null, null, null, null);
        if(startCursor.moveToFirst()){
            startDate = startCursor.getLong(startCursor.getColumnIndex(Schema.COL_TIMESTAMP));
            startLat = startCursor.getFloat(startCursor.getColumnIndex(Schema.COL_LATITUDE));
            startLong = startCursor.getFloat(startCursor.getColumnIndex(Schema.COL_LONGITUDE));
        }
        Cursor endCursor = cr.query(TrackContentProvider.trackEndUri(trackId), null, null, null, null);
        if(endCursor.moveToFirst()){
            endDate = endCursor.getLong(endCursor.getColumnIndex(Schema.COL_TIMESTAMP));
            endLat = endCursor.getFloat(endCursor.getColumnIndex(Schema.COL_LATITUDE));
            endLong = endCursor.getFloat(endCursor.getColumnIndex(Schema.COL_LONGITUDE));
        }
        extraInformationRead = true;
    }
}","	private void readExtraInformation(){
		if(!extraInformationRead){
			Cursor startCursor = cr.query(TrackContentProvider.trackStartUri(trackId), null, null, null, null);
			if(startCursor.moveToFirst()){
				startDate = startCursor.getLong(startCursor.getColumnIndex(Schema.COL_TIMESTAMP));
				startLat = startCursor.getFloat(startCursor.getColumnIndex(Schema.COL_LATITUDE));
				startLong = startCursor.getFloat(startCursor.getColumnIndex(Schema.COL_LONGITUDE));
			}
			startCursor.close();
			
			Cursor endCursor = cr.query(TrackContentProvider.trackEndUri(trackId), null, null, null, null);
			if(endCursor.moveToFirst()){
				endDate = endCursor.getLong(endCursor.getColumnIndex(Schema.COL_TIMESTAMP));
				endLat = endCursor.getFloat(endCursor.getColumnIndex(Schema.COL_LATITUDE));
				endLong = endCursor.getFloat(endCursor.getColumnIndex(Schema.COL_LONGITUDE));
			}
			endCursor.close();
			
			extraInformationRead = true;
		}
	}
",no,no,"Yes
Leaky Resources:
Cursor","No
Leaky Resources:
None"
OSMTracker,android.database.Cursor,a4617bc3d4,f66282f5c7,readExtraInformation() @line 68,Track.java,,yes,yes,yes,n/a,,yes,n/a,n/a,,,yes,no,n/a,,no,n/a,n/a,,,,no,complete leak,,https://github.com/nguillaumin/osmtracker-android,src/me/guillaumin/android/osmtracker/db/model/Track.java,https://github.com/nguillaumin/osmtracker-android/commit/a4617bc3d49ddd5afd216e14dc88d213126080fc,https://github.com/nguillaumin/osmtracker-android/commit/f66282f5c702cb313ad1d12be83b23af9e255187,"private void readExtraInformation(){
  if(!extraInformationRead){
   Cursor startCursor = cr.query(TrackContentProvider.trackStartUri(trackId), null, null, null, null);
   if(startCursor.moveToFirst()){
    startDate = startCursor.getLong(startCursor.getColumnIndex(Schema.COL_TIMESTAMP));
    startLat = startCursor.getFloat(startCursor.getColumnIndex(Schema.COL_LATITUDE));
    startLong = startCursor.getFloat(startCursor.getColumnIndex(Schema.COL_LONGITUDE));
   }
   Cursor endCursor = cr.query(TrackContentProvider.trackEndUri(trackId), null, null, null, null);
   if(endCursor.moveToFirst()){
    endDate = endCursor.getLong(endCursor.getColumnIndex(Schema.COL_TIMESTAMP));
    endLat = endCursor.getFloat(endCursor.getColumnIndex(Schema.COL_LATITUDE));
    endLong = endCursor.getFloat(endCursor.getColumnIndex(Schema.COL_LONGITUDE));
   }

   extraInformationRead = true;
  }
 }
 ","	private void readExtraInformation(){
		if(!extraInformationRead){
			Cursor startCursor = cr.query(TrackContentProvider.trackStartUri(trackId), null, null, null, null);
			if(startCursor.moveToFirst()){
				startDate = startCursor.getLong(startCursor.getColumnIndex(Schema.COL_TIMESTAMP));
				startLat = startCursor.getFloat(startCursor.getColumnIndex(Schema.COL_LATITUDE));
				startLong = startCursor.getFloat(startCursor.getColumnIndex(Schema.COL_LONGITUDE));
			}
			startCursor.close();
			
			Cursor endCursor = cr.query(TrackContentProvider.trackEndUri(trackId), null, null, null, null);
			if(endCursor.moveToFirst()){
				endDate = endCursor.getLong(endCursor.getColumnIndex(Schema.COL_TIMESTAMP));
				endLat = endCursor.getFloat(endCursor.getColumnIndex(Schema.COL_LATITUDE));
				endLong = endCursor.getFloat(endCursor.getColumnIndex(Schema.COL_LONGITUDE));
			}
			endCursor.close();
			
			extraInformationRead = true;
		}
	}
",no,no,"Yes
Leaky Resources:
Cursor","No
Leaky Resources:
None"
Wordpress,android.database.Cursor,57c0808aa4,42de8a232c,reloadNotes(),NotesAdapter.java,Pull 561,yes,yes,no,n/a,,no,n/a,n/a,,,no,no,n/a,,no,n/a,n/a,,,,yes,complete leak,,https://github.com/wordpress-mobile/WordPress-Android,src/org/wordpress/android/ui/notifications/NotesAdapter.java,https://github.com/wordpress-mobile/WordPress-Android/commit/57c0808aa454e0fd169f423df3951cb62b2bcbcd,https://github.com/wordpress-mobile/WordPress-Android/commit/42de8a232cdb0a6d715662f7020fd4ca515c354e,"    public void reloadNotes() {
        swapCursor(mQuery.execute());
    }
","    public void reloadNotes() {
        changeCursor(mQuery.execute());
    }
",no,no,"No
Leaky Resources:
None","No
Leaky Resources:
None"
Wordpress,android.database.Cursor,3f6227e2d4,4b1d15cb26,swapCursor(),MediaGridAdapter.java,,yes,no,no,n/a,,no,n/a,n/a,,,no,no,n/a,,no,n/a,n/a,,,,yes,complete leak,,https://github.com/wordpress-mobile/WordPress-Android,src/org/wordpress/android/ui/media/MediaGridAdapter.java,https://github.com/wordpress-mobile/WordPress-Android/commit/3f6227e2d4c80d9b758928ce4b3d7488ac982e62,https://github.com/wordpress-mobile/WordPress-Android/commit/4b1d15cb262890639c9a4ea41562ff83b5535da7,"@Override
    public Cursor swapCursor(Cursor newCursor) {
        if (newCursor == null) {
            mCursorDataCount = 0;
            return super.swapCursor(newCursor);
        }
        
        mCursorDataCount = newCursor.getCount();

        // to mimic the infinite the notification's infinite scroll ui 
        // (with a progress spinner on the bottom of the list), we'll need to add
        // extra cells in the gridview:
        // - spacer cells as fillers to place the progress spinner on the first cell (_id < 0)
        // - progress spinner cell (_id = Integer.MIN_VALUE)

        // use a matrix cursor to create the extra rows
        MatrixCursor matrixCursor = new MatrixCursor(new String[] { ""_id"" });

        // add spacer cells
        int columnCount = getColumnCount(mContext);
        int remainder = newCursor.getCount() % columnCount;
        if (remainder > 0) {
            int spaceCount = columnCount - remainder; 
            for (int i = 0; i < spaceCount; i++ ) {
                int id = i - spaceCount;
                matrixCursor.addRow(new Object[] {id + """"});
            }
        }

        // add progress spinner cell
        matrixCursor.addRow(new Object[] { Integer.MIN_VALUE });
        
        // use a merge cursor to place merge the extra rows at the bottom of the newly swapped cursor
        MergeCursor mergeCursor = new MergeCursor(new Cursor[] { newCursor, matrixCursor });
        return super.swapCursor(mergeCursor);
    }","@Override
    public void changeCursor(Cursor newCursor) {
        if (newCursor == null) {
            mCursorDataCount = 0;
            super.changeCursor(newCursor);
            return;
        }

        mCursorDataCount = newCursor.getCount();
        // to mimic the infinite the notification's infinite scroll ui 
        // (with a progress spinner on the bottom of the list), we'll need to add
        // extra cells in the gridview:
        // - spacer cells as fillers to place the progress spinner on the first cell (_id < 0)
        // - progress spinner cell (_id = Integer.MIN_VALUE)
        // use a matrix cursor to create the extra rows
        MatrixCursor matrixCursor = new MatrixCursor(new String[] { ""_id"" });
        // add spacer cells
        int columnCount = getColumnCount(mContext);
        int remainder = newCursor.getCount() % columnCount;
        if (remainder > 0) {
            int spaceCount = columnCount - remainder; 
            for (int i = 0; i < spaceCount; i++ ) {
                int id = i - spaceCount;
                matrixCursor.addRow(new Object[] {id + """"});
            }
        }
        // add progress spinner cell
        matrixCursor.addRow(new Object[] { Integer.MIN_VALUE });

        // use a merge cursor to place merge the extra rows at the bottom of the newly swapped cursor
        MergeCursor mergeCursor = new MergeCursor(new Cursor[] { newCursor, matrixCursor });
        super.changeCursor(mergeCursor);
    }",no,no,"No
Leaky Resources:
None","No
Leaky Resources: None

The provided code snippet does not appear to have any resource leaks. Cursors are managed objects in Android and their lifecycle is handled by the system. The MergeCursor and MatrixCursor are both closed when the containing activity or loader is destroyed."
Wordpress,android.database.Cursor,3f6227e2d4,4b1d15cb26,setFilter(),MediaGridFragment.java,,yes,yes,no,n/a,,no,n/a,n/a,,,no,no,n/a,,no,n/a,n/a,,,,yes,complete leak,,https://github.com/wordpress-mobile/WordPress-Android,src/org/wordpress/android/ui/media/MediaGridFragment.java,https://github.com/wordpress-mobile/WordPress-Android/commit/3f6227e2d4c80d9b758928ce4b3d7488ac982e62,https://github.com/wordpress-mobile/WordPress-Android/commit/4b1d15cb262890639c9a4ea41562ff83b5535da7,"    public void setFilter(Filter filter) {
        mFilter = filter;
        Cursor cursor = filterItems(mFilter);

        if (cursor != null) {
            mGridAdapter.swapCursor(cursor);
            mResultView.setVisibility(View.GONE);
        } else {
            if (filter != Filter.CUSTOM_DATE) {
                mResultView.setVisibility(View.VISIBLE);
                mResultView.setText(getResources().getString(R.string.empty_fields));
            }
        }

    }
","    public void setFilter(Filter filter) {
        mFilter = filter;
        Cursor cursor = filterItems(mFilter);

        if (cursor != null) {
            mGridAdapter.changeCursor(cursor);
            mResultView.setVisibility(View.GONE);
        } else {
            if (filter != Filter.CUSTOM_DATE) {
                mResultView.setVisibility(View.VISIBLE);
                mResultView.setText(getResources().getString(R.string.empty_fields));
            }
        }

    }
",no,no,"No
Leaky Resources:
None","No
Leaky Resources:
None"
Wordpress,android.database.Cursor,3f6227e2d4,4b1d15cb26,setDateFilter(),MediaGridFragment.java,,yes,yes,no,n/a,,no,n/a,n/a,,,no,no,n/a,,no,n/a,n/a,,,,yes,complete leak,,https://github.com/wordpress-mobile/WordPress-Android,src/org/wordpress/android/ui/media/MediaGridFragment.java,https://github.com/wordpress-mobile/WordPress-Android/commit/3f6227e2d4c80d9b758928ce4b3d7488ac982e62,https://github.com/wordpress-mobile/WordPress-Android/commit/4b1d15cb262890639c9a4ea41562ff83b5535da7,"public void setDateFilter() {
        Blog blog = WordPress.getCurrentBlog();

        if (blog == null)
            return;

        String blogId = String.valueOf(blog.getBlogId());

        GregorianCalendar startDate = new GregorianCalendar(mStartYear, mStartMonth, mStartDay);
        GregorianCalendar endDate = new GregorianCalendar(mEndYear, mEndMonth, mEndDay);

        long one_day = 24 * 60 * 60 * 1000;
        Cursor cursor = WordPress.wpDB.getMediaFilesForBlog(blogId, startDate.getTimeInMillis(), endDate.getTimeInMillis() + one_day);
        mGridAdapter.swapCursor(cursor);

        if (cursor != null && cursor.moveToFirst()) {
            mResultView.setVisibility(View.VISIBLE);

            SimpleDateFormat fmt = new SimpleDateFormat(""dd-MMM-yyyy"");
            fmt.setCalendar(startDate);
            String formattedStart = fmt.format(startDate.getTime());
            String formattedEnd = fmt.format(endDate.getTime());

            mResultView.setText(""Displaying media from "" + formattedStart + "" to "" + formattedEnd);
        } else {

            mResultView.setVisibility(View.VISIBLE);
            mResultView.setText(getResources().getString(R.string.empty_fields));

        }
    }","public void setDateFilter() {
        Blog blog = WordPress.getCurrentBlog();

        if (blog == null)
            return;

        String blogId = String.valueOf(blog.getBlogId());

        GregorianCalendar startDate = new GregorianCalendar(mStartYear, mStartMonth, mStartDay);
        GregorianCalendar endDate = new GregorianCalendar(mEndYear, mEndMonth, mEndDay);

        long one_day = 24 * 60 * 60 * 1000;
        Cursor cursor = WordPress.wpDB.getMediaFilesForBlog(blogId, startDate.getTimeInMillis(), endDate.getTimeInMillis() + one_day);
        mGridAdapter.changeCursor(cursor);

        if (cursor != null && cursor.moveToFirst()) {
            mResultView.setVisibility(View.VISIBLE);

            SimpleDateFormat fmt = new SimpleDateFormat(""dd-MMM-yyyy"");
            fmt.setCalendar(startDate);
            String formattedStart = fmt.format(startDate.getTime());
            String formattedEnd = fmt.format(endDate.getTime());

            mResultView.setText(""Displaying media from "" + formattedStart + "" to "" + formattedEnd);
        } else {

            mResultView.setVisibility(View.VISIBLE);
            mResultView.setText(getResources().getString(R.string.empty_fields));

        }
    }",no,no,"No
Leaky Resources:
None

The provided code snippet does not appear to have any resource leaks. The Cursor object is the only resource that could potentially be leaked, but it is properly managed within the code. It is not left open indefinitely and does not appear to be used outside of its intended scope.","No
Leaky Resources:
None

The provided code snippet does not appear to have any resource leaks. The Cursor object, which is a common source of resource leaks if not properly managed, is not closed in the code. However, it is passed to the mGridAdapter through the changeCursor method. It is assumed that the mGridAdapter takes ownership of the cursor and is responsible for closing it when it's no longer needed. If the mGridAdapter does not handle the cursor correctly, then there could be a potential resource leak. But based on the provided code snippet, there is no direct evidence of resource leaks."
Wordpress,android.database.Cursor,3f6227e2d4,4b1d15cb26,reset(),MediaGridFragment.java,,yes,yes,no,n/a,,no,n/a,n/a,,,no,no,n/a,,no,n/a,n/a,,,,yes,complete leak,,https://github.com/wordpress-mobile/WordPress-Android,src/org/wordpress/android/ui/media/MediaGridFragment.java,https://github.com/wordpress-mobile/WordPress-Android/commit/3f6227e2d4c80d9b758928ce4b3d7488ac982e62,https://github.com/wordpress-mobile/WordPress-Android/commit/4b1d15cb262890639c9a4ea41562ff83b5535da7,"public void reset() {
        mCheckedItems.clear();
        mGridView.setSelection(0);
        mGridView.requestFocusFromTouch();
        mGridView.setSelection(0);
        mGridAdapter.swapCursor(null);

        resetSpinnerAdapter();
        
        
        mHasRetrievedAllMedia = false;
    }","public void reset() {
        mCheckedItems.clear();
        mGridView.setSelection(0);
        mGridView.requestFocusFromTouch();
        mGridView.setSelection(0);
        mGridAdapter.changeCursor(null);

        resetSpinnerAdapter();
        
        
        mHasRetrievedAllMedia = false;
    }",no,no,"No
Leaky Resources:
None","No
Leaky Resources:
None

The provided code snippet does not appear to have any resource leaks. It seems to be managing its resources properly."
Wordpress,android.database.Cursor,3f6227e2d4,4b1d15cb26,onLoadFinished(),StatsCursorFragment.java,,yes,yes,no,n/a,,no,n/a,n/a,,,no,no,n/a,,no,n/a,n/a,,,,yes,complete leak,,https://github.com/wordpress-mobile/WordPress-Android,src/org/wordpress/android/ui/stats/StatsCursorFragment.java,https://github.com/wordpress-mobile/WordPress-Android/commit/3f6227e2d4c80d9b758928ce4b3d7488ac982e62,https://github.com/wordpress-mobile/WordPress-Android/commit/4b1d15cb262890639c9a4ea41562ff83b5535da7,"    @Override
    public void onLoadFinished(Loader<Cursor> loader, Cursor data) {
        mCallback.onCursorLoaded(getUri(), data);
        if (mAdapter != null)
            mAdapter.swapCursor(data);
        configureEmptyLabel();
        if (isTablet()) {
            reloadLinearLayout();
        }
    }
","    @Override
    public void onLoadFinished(Loader<Cursor> loader, Cursor data) {
        mCallback.onCursorLoaded(getUri(), data);
        if (mAdapter != null)
            mAdapter.changeCursor(data);
        configureEmptyLabel();
        if (isTablet()) {
            reloadLinearLayout();
        }
    }
",no,no,"No
Leaky Resources:
None

The provided code snippet does not show any explicit resource leaks. However, without the full context of the code, it's impossible to say for certain. For example, if the Cursor object ""data"" is not properly closed elsewhere in the code, that could potentially lead to a resource leak. But based on this snippet alone, no resource leaks are apparent.","No
Leaky Resources:
None

The provided code snippet does not show any explicit resource leaks. However, without the full context of the code, it's impossible to say for certain. For example, if the Cursor object ""data"" is not properly closed elsewhere in the code, that could potentially lead to a resource leak. But based on this snippet alone, no resource leaks are apparent."
Wordpress,android.database.Cursor,3f6227e2d4,4b1d15cb26,onLoaderReset(),StatsCursorFragment.java,,yes,yes,no,n/a,,no,n/a,n/a,,,no,no,n/a,,no,n/a,n/a,,,,yes,complete leak,,https://github.com/wordpress-mobile/WordPress-Android,src/org/wordpress/android/ui/stats/StatsCursorFragment.java,https://github.com/wordpress-mobile/WordPress-Android/commit/3f6227e2d4c80d9b758928ce4b3d7488ac982e62,https://github.com/wordpress-mobile/WordPress-Android/commit/4b1d15cb262890639c9a4ea41562ff83b5535da7,"    @Override
    public void onLoaderReset(Loader<Cursor> loader) {
        if (mAdapter != null)
            mAdapter.swapCursor(null);
        configureEmptyLabel();
        if (isTablet()) {
            reloadLinearLayout();
        }
    }
","    @Override
    public void onLoaderReset(Loader<Cursor> loader) {
        if (mAdapter != null)
            mAdapter.changeCursor(null);
        configureEmptyLabel();
        if (isTablet()) {
            reloadLinearLayout();
        }
    }
",no,no,"No
Leaky Resources:
None

The provided code snippet does not show any resource leaks. It seems to be managing its resources properly.","No
Leaky Resources:
None

The provided code snippet does not show any resource leaks. It seems to be managing resources properly."
Wordpress,android.database.Cursor,3f6227e2d4,4b1d15cb26,search(),ThemeSearchFragment.java,,yes,yes,no,n/a,,no,n/a,n/a,,,no,no,n/a,,no,n/a,n/a,,,,yes,complete leak,,https://github.com/wordpress-mobile/WordPress-Android,src/org/wordpress/android/ui/themes/ThemeSearchFragment.java,https://github.com/wordpress-mobile/WordPress-Android/commit/3f6227e2d4c80d9b758928ce4b3d7488ac982e62,https://github.com/wordpress-mobile/WordPress-Android/commit/4b1d15cb262890639c9a4ea41562ff83b5535da7,"public void search(String searchTerm) {
        mLastSearch = searchTerm;
        
        String blogId = getBlogId();
        Cursor cursor =  WordPress.wpDB.getThemes(blogId, searchTerm);
        if (mAdapter == null) {
            return;
        } else {   
            mAdapter.swapCursor(cursor);   
            mGridView.invalidateViews();
            
            if (cursor == null || cursor.getCount() == 0) {
                mNoResultText.setVisibility(View.VISIBLE);
            } else {
                mNoResultText.setVisibility(View.GONE);
            }
        }             
    }","public void search(String searchTerm) {
        mLastSearch = searchTerm;
        
        String blogId = getBlogId();
        Cursor cursor =  WordPress.wpDB.getThemes(blogId, searchTerm);
        if (mAdapter == null) {
            return;
        } else {   
            mAdapter.changeCursor(cursor);   
            mGridView.invalidateViews();
            
            if (cursor == null || cursor.getCount() == 0) {
                mNoResultText.setVisibility(View.VISIBLE);
            } else {
                mNoResultText.setVisibility(View.GONE);
            }
        }             
    }",no,no,"Yes
Leaky Resources:
Cursor","Yes
Leaky Resources:
Cursor"
Wordpress,android.database.Cursor,3f6227e2d4,4b1d15cb26,refresh(),ThemeTabFragment.java,,yes,yes,no,n/a,,no,n/a,n/a,,,no,no,n/a,,no,n/a,n/a,,,,yes,complete leak,,https://github.com/wordpress-mobile/WordPress-Android,src/org/wordpress/android/ui/themes/ThemeTabFragment.java,https://github.com/wordpress-mobile/WordPress-Android/commit/3f6227e2d4c80d9b758928ce4b3d7488ac982e62,https://github.com/wordpress-mobile/WordPress-Android/commit/4b1d15cb262890639c9a4ea41562ff83b5535da7,"    private void refresh() {
        Cursor cursor = fetchThemes(getThemeSortType());
        if (mAdapter == null) {
            mAdapter = new ThemeTabAdapter(getActivity(), cursor, false);
        }
        
        if (mNoResultText.isShown())
            mNoResultText.setVisibility(View.GONE);
        mAdapter.swapCursor(cursor);
    }
","    private void refresh() {
        Cursor cursor = fetchThemes(getThemeSortType());
        if (mAdapter == null) {
            mAdapter = new ThemeTabAdapter(getActivity(), cursor, false);
        }
        
        if (mNoResultText.isShown())
            mNoResultText.setVisibility(View.GONE);
        mAdapter.changeCursor(cursor);
    }
",no,no,"Yes
Leaky Resources:
Cursor","Yes
Leaky Resources:
Cursor"
ChatSecure,android.database.Cursor,62b3507412,f4d4acc464,getFileInfoFromURI(),SystemServices.java,,yes,yes,no,n/a,,yes,n/a,n/a,,,yes,no,n/a,,no,n/a,n/a,,,,no,leak on certain normal paths,,https://github.com/guardianproject/ChatSecureAndroid,src/info/guardianproject/util/SystemServices.java,https://github.com/guardianproject/ChatSecureAndroid/commit/62b35074122d818433e936745cb4761a6b6d08ea,https://github.com/guardianproject/ChatSecureAndroid/commit/f4d4acc464c22ccc52b6f9c7ca4e768d4675de61,"public static FileInfo getFileInfoFromURI(Context aContext, Uri uri) throws IllegalArgumentException {
        FileInfo info = new FileInfo();
        if (uri.getScheme() != null && uri.getScheme().equals(""file"")) {
            info.path = uri.getPath();
            return info;
        }
        
        if (uri.toString().startsWith(""content://org.openintents.filemanager/"")) {
            // Work around URI escaping brokenness
            info.path = uri.toString().replaceFirst(""content://org.openintents.filemanager"", """");
            return info;
        }
        
        Cursor cursor = aContext.getContentResolver().query(uri, null, null, null, null);
        
        if (cursor != null && cursor.getCount() > 0)
        {
            cursor.moveToFirst();
            
            //need to check columns for different types
            int dataIdx = cursor.getColumnIndex(MediaStore.Images.Media.DATA);
            if (dataIdx != -1) 
            {
                info.path = cursor.getString(dataIdx);
                info.type = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Images.Media.MIME_TYPE));
            
            }
            else
            {
                dataIdx = cursor.getColumnIndex(MediaStore.Video.Media.DATA);
            
                if (dataIdx != -1)
                {
                    info.path = cursor.getString(dataIdx);
                    info.type = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Video.Media.MIME_TYPE));
                }
                else
                {
                    dataIdx = cursor.getColumnIndex(MediaStore.Audio.Media.DATA);
            
                    if (dataIdx != -1)
                    {
                        info.path = cursor.getString(dataIdx);
                        info.type = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.MIME_TYPE));
                    }
                    else
                    {
                        dataIdx = cursor.getColumnIndex(MediaStore.MediaColumns.DATA);
                
                        if (dataIdx != -1)
                        {
                            info.path = cursor.getString(dataIdx);
                            info.type = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.MIME_TYPE));
                          
                        }
                    }
                }
                
                cursor.close();
            }
        }
        
        return info;
    }","public static FileInfo getFileInfoFromURI(Context aContext, Uri uri) throws IllegalArgumentException {
        FileInfo info = new FileInfo();
        if (uri.getScheme() != null && uri.getScheme().equals(""file"")) {
            info.path = uri.getPath();
            return info;
        }
        
        if (uri.toString().startsWith(""content://org.openintents.filemanager/"")) {
            // Work around URI escaping brokenness
            info.path = uri.toString().replaceFirst(""content://org.openintents.filemanager"", """");
            return info;
        }
        
        Cursor cursor = aContext.getContentResolver().query(uri, null, null, null, null);
        
        if (cursor != null && cursor.getCount() > 0)
        {
            cursor.moveToFirst();
            
            //need to check columns for different types
            int dataIdx = cursor.getColumnIndex(MediaStore.Images.Media.DATA);
            if (dataIdx != -1) 
            {
                info.path = cursor.getString(dataIdx);
                info.type = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Images.Media.MIME_TYPE));
            
            }
            else
            {
                dataIdx = cursor.getColumnIndex(MediaStore.Video.Media.DATA);
            
                if (dataIdx != -1)
                {
                    info.path = cursor.getString(dataIdx);
                    info.type = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Video.Media.MIME_TYPE));
                }
                else
                {
                    dataIdx = cursor.getColumnIndex(MediaStore.Audio.Media.DATA);
            
                    if (dataIdx != -1)
                    {
                        info.path = cursor.getString(dataIdx);
                        info.type = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.MIME_TYPE));
                    }
                    else
                    {
                        dataIdx = cursor.getColumnIndex(MediaStore.MediaColumns.DATA);
                
                        if (dataIdx != -1)
                        {
                            info.path = cursor.getString(dataIdx);
                            info.type = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.MIME_TYPE));
                          
                        }
                    }
                }
                
               
            }
        }
        
        if (cursor != null)
            cursor.close();
        
        return info;
    }",no,no,"Yes
Leaky Resources:
Cursor","Yes
Leaky Resources:
Cursor"
ChatSecure,android.database.Cursor,158008c655,cbbbaf8e2f,bindChat(),ChatView.java,,yes,no,no,n/a,,no,n/a,n/a,,,no,no,n/a,,no,n/a,n/a,,,,yes,complete leak,,https://github.com/guardianproject/ChatSecureAndroid,src/info/guardianproject/otr/app/im/app/ChatView.java,https://github.com/guardianproject/ChatSecureAndroid/commit/158008c655034fbf0b20ca7b73a39f2a009e0826,https://github.com/guardianproject/ChatSecureAndroid/commit/cbbbaf8e2fc1ef641bb1c4ecc68f192733db5bf4,"public void bindChat(long chatId) {
        log(""bind "" + this + "" "" + chatId);
        mLastChatId = chatId;
        
        Uri contactUri = ContentUris.withAppendedId(Imps.Contacts.CONTENT_URI, chatId);
        mCursor = mActivity.getContentResolver().query(contactUri, CHAT_PROJECTION, null, null, null);
        
        if (mCursor == null)
            return;
        
        if (!mCursor.moveToFirst()) {
            if (Log.isLoggable(ImApp.LOG_TAG, Log.DEBUG)) {
                log(""Failed to query chat: "" + chatId);
            }
            mLastChatId = -1;
        } else {
        
            updateContactInfo();
            
            mCurrentChatSession = getChatSession();
            
            if (mCurrentChatSession == null)
                mCurrentChatSession = createChatSession();
            
            if (mCurrentChatSession != null) {
                isServiceUp = true;
                
            }
            
            updateChat();
        }

    }","public void bindChat(long chatId) {
        log(""bind "" + this + "" "" + chatId);
        mLastChatId = chatId;
        
        if (mCursor != null && !mCursor.isClosed())
            mCursor.close();
        
        Uri contactUri = ContentUris.withAppendedId(Imps.Contacts.CONTENT_URI, chatId);
        mCursor = mActivity.getContentResolver().query(contactUri, CHAT_PROJECTION, null, null, null);
        
        if (mCursor == null)
            return;
        
        if (!mCursor.moveToFirst()) {
            if (Log.isLoggable(ImApp.LOG_TAG, Log.DEBUG)) {
                log(""Failed to query chat: "" + chatId);
            }
            mLastChatId = -1;
        } else {
        
            updateContactInfo();
            
            mCurrentChatSession = getChatSession();
            
            if (mCurrentChatSession == null)
                mCurrentChatSession = createChatSession();
            
            if (mCurrentChatSession != null) {
                isServiceUp = true;
                
            }
            
            updateChat();
        }

    }",no,no,"Yes
Leaky Resources:
Cursor","No
Leaky Resources:
None

The provided code snippet does not appear to have any resource leaks. The cursor is properly closed before a new one is created, and there are no other resources such as streams or connections that are left open."
Transdroid,android.database.Cursor,dce15b89f2,f82ba6e12b,getAvailableSites() @line 72,SearchHelper.java,,yes,yes,no,n/a,,yes,n/a,n/a,,,yes,no,n/a,,no,n/a,n/a,,,,no,leak on certain normal paths,,https://github.com/erickok/transdroid,app/src/main/java/org/transdroid/core/app/search/SearchHelper.java,https://github.com/erickok/transdroid/commit/dce15b89f20f2a8765703764d29c5bfc675b85cf,https://github.com/erickok/transdroid/commit/f82ba6e12b0d47ddd70f10dc0a318933be602ce0,"public List<SearchSite> getAvailableSites() {

		// Try to access the TorrentSitesProvider of the Torrent Search app
		Uri uri = Uri.parse(""content://org.transdroid.search.torrentsitesprovider/sites"");
		ContentProviderClient test = context.getContentResolver().acquireContentProviderClient(uri);
		if (test == null) {
			// Torrent Search package is not yet installed
			return null;
		}

		// Query the available in-app torrent search sites
		Cursor cursor = context.getContentResolver().query(uri, null, null, null, null);
		if (cursor == null) {
			// The installed Torrent Search version is corrupt or incompatible
			return null;
		}
		if (cursor.moveToFirst()) {
			List<SearchSite> sites = new ArrayList<SearchSite>();
			do {
				// Read the cursor fields into the SearchSite object
				sites.add(new SearchSite(cursor.getInt(CURSOR_SITE_ID), cursor.getString(CURSOR_SITE_CODE), cursor
						.getString(CURSOR_SITE_NAME), cursor.getString(CURSOR_SITE_RSSURL),
						cursor.getColumnNames().length > 4 ? (cursor.getInt(CURSOR_SITE_ISPRIVATE) == 1 ? true : false)
								: false));
			} while (cursor.moveToNext());
			cursor.close();
			return sites;
		}

		return null;

	}","public List<SearchSite> getAvailableSites() {

		// Try to access the TorrentSitesProvider of the Torrent Search app
		Uri uri = Uri.parse(""content://org.transdroid.search.torrentsitesprovider/sites"");
		ContentProviderClient test = context.getContentResolver().acquireContentProviderClient(uri);
		if (test == null) {
			// Torrent Search package is not yet installed
			return null;
		}

		// Query the available in-app torrent search sites
		Cursor cursor = context.getContentResolver().query(uri, null, null, null, null);
		if (cursor == null) {
			// The installed Torrent Search version is corrupt or incompatible
			return null;
		}
		List<SearchSite> sites = new ArrayList<>();
		if (cursor.moveToFirst()) {
			do {
				// Read the cursor fields into the SearchSite object
				sites.add(new SearchSite(cursor.getInt(CURSOR_SITE_ID), cursor.getString(CURSOR_SITE_CODE), cursor
						.getString(CURSOR_SITE_NAME), cursor.getString(CURSOR_SITE_RSSURL),
						cursor.getColumnNames().length > 4 && cursor.getInt(CURSOR_SITE_ISPRIVATE) == 1));
			} while (cursor.moveToNext());
		}

		cursor.close();
		return sites;

	}",no,no,"Yes
Leaky Resources:
ContentProviderClient, Cursor","Yes
Leaky Resources:
ContentProviderClient, Cursor"
Transdroid,android.database.Cursor,dce15b89f2,f82ba6e12b,search() @line 118,SearchHelper.java,,yes,yes,no,n/a,,yes,n/a,n/a,,,yes,no,n/a,,no,n/a,n/a,,,,no,leak on certain normal paths,,https://github.com/erickok/transdroid,app/src/main/java/org/transdroid/core/app/search/SearchHelper.java,https://github.com/erickok/transdroid/commit/dce15b89f20f2a8765703764d29c5bfc675b85cf,https://github.com/erickok/transdroid/commit/f82ba6e12b0d47ddd70f10dc0a318933be602ce0,"public ArrayList<SearchResult> search(String query, SearchSite site, SearchSortOrder sortBy) {
  // Try to query the TorrentSearchProvider to search for torrents on the web
  Uri uri = Uri.parse(""content://org.transdroid.search.torrentsearchprovider/search/"" + query);
  Cursor cursor;
  if (site == null) {
   // If no explicit site was supplied, rely on the Torrent Search package's default
   cursor = context.getContentResolver().query(uri, null, null, null, sortBy.name());
  } else {
   cursor = context.getContentResolver().query(uri, null, ""SITE = ?"", new String[] { site.getKey() },
     sortBy.name());
  }
  if (cursor == null) {
   // The content provider could not load any content (for example when there is no connection)
   return null;
  }
  if (cursor.moveToFirst()) {
   ArrayList<SearchResult> results = new ArrayList<SearchResult>();
   do {
    // Read the cursor fields into the SearchResult object
    results.add(new SearchResult(cursor.getInt(CURSOR_SEARCH_ID), cursor.getString(CURSOR_SEARCH_NAME),
      cursor.getString(CURSOR_SEARCH_TORRENTURL), cursor.getString(CURSOR_SEARCH_DETAILSURL), cursor
        .getString(CURSOR_SEARCH_SIZE), cursor.getLong(CURSOR_SEARCH_ADDED), cursor
        .getString(CURSOR_SEARCH_SEEDERS), cursor.getString(CURSOR_SEARCH_LEECHERS)));
   } while (cursor.moveToNext());
   cursor.close();
   return results;
  }

  // Torrent Search package is not yet installed

  return null;

 }
","	public ArrayList<SearchResult> search(String query, SearchSite site, SearchSortOrder sortBy) {

		// Try to query the TorrentSearchProvider to search for torrents on the web
		Uri uri = Uri.parse(""content://org.transdroid.search.torrentsearchprovider/search/"" + query);
		Cursor cursor;
		if (site == null) {
			// If no explicit site was supplied, rely on the Torrent Search package's default
			cursor = context.getContentResolver().query(uri, null, null, null, sortBy.name());
		} else {
			cursor = context.getContentResolver().query(uri, null, ""SITE = ?"", new String[] { site.getKey() },
					sortBy.name());
		}
		if (cursor == null) {
			// The content provider could not load any content (for example when there is no connection)
			return null;
		}
		if (cursor.moveToFirst()) {
			ArrayList<SearchResult> results = new ArrayList<>();
			do {
				// Read the cursor fields into the SearchResult object
				results.add(new SearchResult(cursor.getInt(CURSOR_SEARCH_ID), cursor.getString(CURSOR_SEARCH_NAME),
						cursor.getString(CURSOR_SEARCH_TORRENTURL), cursor.getString(CURSOR_SEARCH_DETAILSURL), cursor
								.getString(CURSOR_SEARCH_SIZE), cursor.getLong(CURSOR_SEARCH_ADDED), cursor
								.getString(CURSOR_SEARCH_SEEDERS), cursor.getString(CURSOR_SEARCH_LEECHERS)));
			} while (cursor.moveToNext());
			cursor.close();
			return results;
		}

		// Torrent Search package is not yet installed
		cursor.close();
		return null;

	}
",no,no,"Yes
Leaky Resources:
Cursor","Yes
Leaky Resources:
Cursor"
CSipSimple,android.database.Cursor,31838a61d9,0a2a1f1d37,getPhoneNumbers() @line 123,ContactsUtils5.java,,yes,yes,no,n/a,,yes,n/a,n/a,,,yes,no,n/a,,no,n/a,n/a,,,,no,complete leak,,https://github.com/r3gis3r/CSipSimple,src/com/csipsimple/utils/contacts/ContactsUtils5.java,https://github.com/r3gis3r/CSipSimple/commit/31838a61d9b9ef98c611e7850bff369e42659719,https://github.com/r3gis3r/CSipSimple/commit/0a2a1f1d377cb7b34f09077097a90bdb083ebf3d,"public ArrayList<Phone> getPhoneNumbers(Context ctxt, String id) {
   ArrayList<Phone> phones = new ArrayList<Phone>();
   
   Cursor pCur = ctxt.getContentResolver().query(
     ContactsContract.CommonDataKinds.Phone.CONTENT_URI, 
     null, 
     ContactsContract.CommonDataKinds.Phone.CONTACT_ID +"" = ?"", 
     new String[]{id}, null);
   while (pCur.moveToNext()) {
    phones.add(new Phone(pCur.getString(pCur.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)), 
      pCur.getString(pCur.getColumnIndex(ContactsContract.CommonDataKinds.Phone.TYPE))
    ));
 
   } 
   pCur.close();
   // Add any custom IM named 'sip' and set its type to 'sip'
        pCur = ctxt.getContentResolver().query(
                ContactsContract.Data.CONTENT_URI, 
                null, 
                ContactsContract.Data.CONTACT_ID + "" = ? AND "" + ContactsContract.Data.MIMETYPE + "" = ?"",
                new String[]{id, ContactsContract.CommonDataKinds.Im.CONTENT_ITEM_TYPE}, null);
        while (pCur.moveToNext()) {
            // Could also use some other IM type but may be confusing. Are there phones with no 'custom' IM type?
            if (pCur.getInt(pCur.getColumnIndex(ContactsContract.CommonDataKinds.Im.PROTOCOL)) == ContactsContract.CommonDataKinds.Im.PROTOCOL_CUSTOM) {
                if (pCur.getString(pCur.getColumnIndex(ContactsContract.CommonDataKinds.Im.CUSTOM_PROTOCOL)).equalsIgnoreCase(""sip"")) {
                    phones.add(new Phone(pCur.getString(pCur.getColumnIndex(ContactsContract.CommonDataKinds.Im.DATA)), ""sip""));
                }
            }
                
        } 
        pCur.close();
        
        // Add any SIP uri if android 9
        if(Compatibility.isCompatible(9)) {
          pCur = ctxt.getContentResolver().query(
                     ContactsContract.Data.CONTENT_URI, 
                     null, 
                     ContactsContract.Data.CONTACT_ID + "" = ? AND "" + ContactsContract.Data.MIMETYPE + "" = ?"",
                     new String[]{id, GINGER_SIP_TYPE}, null);
             while (pCur.moveToNext()) {
                 // Could also use some other IM type but may be confusing. Are there phones with no 'custom' IM type?
              phones.add(new Phone(pCur.getString(pCur.getColumnIndex(ContactsContract.Data.DATA1)), ""sip""));
             } 
        }

   return(phones);
  }","public ArrayList<Phone> getPhoneNumbers(Context ctxt, String id) {
 		ArrayList<Phone> phones = new ArrayList<Phone>();
 		
 		Cursor pCur = ctxt.getContentResolver().query(
 				ContactsContract.CommonDataKinds.Phone.CONTENT_URI, 
 				null, 
 				ContactsContract.CommonDataKinds.Phone.CONTACT_ID +"" = ?"", 
 				new String[]{id}, null);
 		while (pCur.moveToNext()) {
 			phones.add(new Phone(pCur.getString(pCur.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)), 
 					pCur.getString(pCur.getColumnIndex(ContactsContract.CommonDataKinds.Phone.TYPE))
 			));
 
 		} 
 		pCur.close();

 		// Add any custom IM named 'sip' and set its type to 'sip'
        pCur = ctxt.getContentResolver().query(
                ContactsContract.Data.CONTENT_URI, 
                null, 
                ContactsContract.Data.CONTACT_ID + "" = ? AND "" + ContactsContract.Data.MIMETYPE + "" = ?"",
                new String[]{id, ContactsContract.CommonDataKinds.Im.CONTENT_ITEM_TYPE}, null);
        while (pCur.moveToNext()) {
            // Could also use some other IM type but may be confusing. Are there phones with no 'custom' IM type?
            if (pCur.getInt(pCur.getColumnIndex(ContactsContract.CommonDataKinds.Im.PROTOCOL)) == ContactsContract.CommonDataKinds.Im.PROTOCOL_CUSTOM) {
                if (pCur.getString(pCur.getColumnIndex(ContactsContract.CommonDataKinds.Im.CUSTOM_PROTOCOL)).equalsIgnoreCase(""sip"")) {
                    phones.add(new Phone(pCur.getString(pCur.getColumnIndex(ContactsContract.CommonDataKinds.Im.DATA)), ""sip""));
                }
            }
                
        } 
        pCur.close();
        
        // Add any SIP uri if android 9
        if(Compatibility.isCompatible(9)) {
        	 pCur = ctxt.getContentResolver().query(
                     ContactsContract.Data.CONTENT_URI, 
                     null, 
                     ContactsContract.Data.CONTACT_ID + "" = ? AND "" + ContactsContract.Data.MIMETYPE + "" = ?"",
                     new String[]{id, GINGER_SIP_TYPE}, null);
             while (pCur.moveToNext()) {
                 // Could also use some other IM type but may be confusing. Are there phones with no 'custom' IM type?
            	 phones.add(new Phone(pCur.getString(pCur.getColumnIndex(ContactsContract.Data.DATA1)), ""sip""));
             }
             pCur.close();
        }

 		return(phones);
 	}",no,no,"No
Leaky Resources: None

The code snippet provided does not have any resource leaks. All the Cursor objects (pCur) used to query the database are properly closed after use.","No
Leaky Resources:
None

The code snippet provided does not have any resource leaks. All the Cursor objects (pCur) used to query the database are properly closed after use."
FBReaderJ,android.database.sqlite.SQLiteDatabase,7907a9a13b,39b312b0f2,onDestroy(),LibraryService.java,,yes,no,n/a,n/a,,n/a,n/a,n/a,,,no,n/a,n/a,,n/a,n/a,n/a,,,yes,yes,complete leak,,https://github.com/geometer/FBReaderJ,src/org/geometerplus/android/fbreader/libraryService/LibraryService.java,https://github.com/geometer/FBReaderJ/commit/7907a9a13bfe878787212693a0d44955043b3573,https://github.com/geometer/FBReaderJ/commit/39b312b0f2d9c45efafe059d910b31e253815f03,"	@Override
	public void onDestroy() {
		if (myLibrary != null) {
			myLibrary.deactivate();
			myLibrary = null;
		}
		super.onDestroy();
	}
","	@Override
	public void onDestroy() {
		if (myLibrary != null) {
			final LibraryImplementation l = myLibrary;
			myLibrary = null;
			l.deactivate();
			l.close();
		}
		super.onDestroy();
	}
",no,no,"No
Leaky Resources:
None","No
Leaky Resources:
None"
AnySoftKeyboard,android.database.sqlite.SQLiteDatabase,79c11f6eee,fa32c64565,closeAllResources(),AutoDictionary.java,,yes,no,n/a,n/a,,n/a,n/a,n/a,,,no,n/a,n/a,,n/a,n/a,n/a,,,,yes,complete leak,,https://github.com/AnySoftKeyboard/AnySoftKeyboard,src/com/anysoftkeyboard/dictionaries/AutoDictionary.java,https://github.com/AnySoftKeyboard/AnySoftKeyboard/commit/79c11f6eee733b9123c825949fb61b4bad9a4075,https://github.com/AnySoftKeyboard/AnySoftKeyboard/commit/fa32c64565ddfd7f236379baac35e09b4f381053,"	@Override
	protected void closeAllResources() {
	}
","	@Override
	protected void closeAllResources() {
		if (mOpenHelper != null)
			mOpenHelper.close();
	}
",no,no,"No
Leaky Resources:
None

The provided code snippet does not contain any resources to leak. It's an empty method named ""closeAllResources"".","No
Leaky Resources:
None"
SipDroid,android.hardware.Camera,10d05cb157,201646635a,releaseMediaRecorder(),VideoCamera.java,,yes,n/a,n/a,n/a,,n/a,no,no,,,n/a,n/a,n/a,,n/a,yes,no,,,,yes,leak on certain normal paths,,https://github.com/i-p-tel/sipdroid,src/org/sipdroid/sipua/ui/VideoCamera.java,https://github.com/i-p-tel/sipdroid/commit/10d05cb157708a2550d9ad487a6a21dbfa57904c,https://github.com/i-p-tel/sipdroid/commit/201646635a94757e357d20093dc30f8d59fe2fab,"    private void releaseMediaRecorder() {
        Log.v(TAG, ""Releasing media recorder."");
        if (mMediaRecorder != null) {
            mMediaRecorder.reset();
            mMediaRecorder.release();
            mMediaRecorder = null;
        }
    }
","private void releaseMediaRecorder() {
        Log.v(TAG, ""Releasing media recorder."");
        if (mMediaRecorder != null) {
            mMediaRecorder.reset();
            if (mCamera != null) {
	        	if (Integer.parseInt(Build.VERSION.SDK) >= 8)
	        		VideoCameraNew2.reconnect(mCamera);
	        	mCamera.release();
	        	mCamera = null;
            }
            mMediaRecorder.release();
            mMediaRecorder = null;
        }
    }",no,no,"No
Leaky Resources:
None","No
Leaky Resources:
None"
Ushahidi,android.location.LocationListener,337b48f5f2,9d0aa75b84,onPause() and onDestroy(),CheckinMap.java,Pull 11,yes,n/a,n/a,n/a,,n/a,yes,yes,,,n/a,n/a,n/a,,n/a,no,no,,,yes,yes,leak on certain normal paths,,https://github.com/ushahidi/Ushahidi_Android,src/com/ushahidi/android/app/checkin/CheckinMap.java,https://github.com/ushahidi/Ushahidi_Android/commit/337b48f5f2725f3e84796fab12947ffbec3c0357,https://github.com/ushahidi/Ushahidi_Android/commit/9d0aa75b84d74566727b91f5d7dcb85caff34d33,"
    public void onDestroy() {
        super.onDestroy();
        ((LocationManager)getSystemService(Context.LOCATION_SERVICE))
                .removeUpdates(new DeviceLocationListener());
    }","    public void onPause() {
        super.onPause();
        locListener.stop();
    }
    public void onDestroy() {
        super.onDestroy();
        locListener.stop();
    }",no,no,"No
Leaky Resources:
None","No
Leaky Resources:
None"
OsmDroid,android.location.LocationListener,e5c8c57cff,f6a2e34592,onPause() not overidden,SampleMapActivity.java,,yes,n/a,n/a,n/a,,n/a,yes,yes,,,n/a,n/a,n/a,,n/a,no,no,,,yes,yes,leak on certain normal paths,,https://github.com/osmdroid/osmdroid,OpenStreetMapViewer/src/org/osmdroid/samples/SampleMapActivity.java,https://github.com/osmdroid/osmdroid/commit/e5c8c57cff81cee25a9cc6882057b1731d57e69e,https://github.com/osmdroid/osmdroid/commit/f6a2e3459200bec0fca2c0c95ae9cfdbc900e429," @Override
 protected void onDestroy() {
  super.onDestroy();

  getLocationManager().removeUpdates(mLocationListener);

  if (this.mDoGPSRecordingAndContributing) {
   OSMUploader.uploadAsync(this.mRouteRecorder.getRecordedGeoPoints());
  }

 }","	@Override
	protected void onPause() {
		getLocationManager().removeUpdates(mLocationListener);

		if (this.mDoGPSRecordingAndContributing) {
			OSMUploader.uploadAsync(this.mRouteRecorder.getRecordedGeoPoints());
		}

		super.onResume();
	}
",no,no,"No
Leaky Resources:
None

The provided code snippet does not show any obvious resource leaks. It properly removes location updates on destruction and conditionally uploads recorded geopoints. However, without the full context of the code, it's impossible to definitively say there are no resource leaks. For example, if `getLocationManager()`, `mLocationListener`, `mDoGPSRecordingAndContributing`, `OSMUploader.uploadAsync()`, or `mRouteRecorder.getRecordedGeoPoints()` manage resources that aren't properly closed or released elsewhere in the code, there could be resource leaks.","No
Leaky Resources:
None"
IRCCloud,android.media.MediaPlayer,d7a441e3a6,a4f427982f,surfaceDestroyed(),ImageViewerActivity.java,,yes,n/a,n/a,n/a,,n/a,yes,yes,,,n/a,n/a,n/a,,n/a,yes,yes,,,yes,yes,leak on certain normal paths,,https://github.com/irccloud/android,src/com/irccloud/android/activity/ImageViewerActivity.java,https://github.com/irccloud/android/commit/d7a441e3a675cac30cffdfdfa94e5a6dd486b169,https://github.com/irccloud/android/commit/a4f427982f20ca7be08fddc7a0cfe975c3a89699,"                @Override
                public void surfaceDestroyed(SurfaceHolder surfaceHolder) {

                }
","                @Override
                public void surfaceDestroyed(SurfaceHolder surfaceHolder) {
                    if(player != null) {
                        player.stop();
                        player.release();
                        player = null;
                    }
                }
",no,no,"No
Leaky Resources:
None","No
Leaky Resources:
None"
IRCCloud,android.media.MediaPlayer,0cd91bc5ca,d7a441e3a6,"onPause() not overidden, surfaceDestroyed()",ImageViewerActivity.java,,yes,n/a,n/a,n/a,,n/a,yes,yes,,,n/a,n/a,n/a,,n/a,yes,no,,,yes,yes,leak on certain normal paths,,https://github.com/irccloud/android,src/com/irccloud/android/activity/ImageViewerActivity.java,https://github.com/irccloud/android/commit/0cd91bc5ca350671bcf6ae84d634d097a3602d8c,https://github.com/irccloud/android/commit/d7a441e3a675cac30cffdfdfa94e5a6dd486b169,"                 @Override
                public void surfaceDestroyed(SurfaceHolder surfaceHolder) {
                    if(player != null) {
                        player.stop();

                        player.release();
                        player = null;
                    }
                }","    @Override
    public void onPause() {
        super.onPause();
        if(player != null) {
            try {
                player.stop();
            } catch (IllegalStateException e) {
            }
            player.release();
            player = null;
        }
    } 
 @Override
                public void surfaceDestroyed(SurfaceHolder surfaceHolder) {
                    if(player != null) {
                        try {
                            player.stop();
                        } catch (IllegalStateException e) {
                        }
                        player.release();
                        player = null;
                    }
                }
",no,no,"No
Leaky Resources:
None","No
Leaky Resources:
None"
Zxing,android.net.http.AndroidHttpClient,de83fdf806,56644b1af2,getCookie() @line 283,SearchBookContentsActivity.java,,yes,n/a,n/a,n/a,,n/a,n/a,n/a,,,n/a,n/a,n/a,,n/a,n/a,n/a,,,,no,complete leak,,https://github.com/zxing/zxing,android/src/com/google/zxing/client/android/SearchBookContentsActivity.java,https://github.com/zxing/zxing/commit/de83fdf8060a4a75484a37b5fa1bb71e64852d1e,https://github.com/zxing/zxing/commit/56644b1af2f4bbd1140add053fceb47c067b5d47,"private String getCookie(String url) {
      String cookie = CookieManager.getInstance().getCookie(url);
      if (cookie == null || cookie.length() == 0) {
        Log.v(TAG, ""Book Search cookie was missing or expired"");
        HttpHead head = new HttpHead(url);
        AndroidHttpClient client = AndroidHttpClient.newInstance(mUserAgent);
        try {
          HttpResponse response = client.execute(head);
          if (response.getStatusLine().getStatusCode() == 200) {
            Header[] cookies = response.getHeaders(""set-cookie"");
            for (int x = 0; x < cookies.length; x++) {
              CookieManager.getInstance().setCookie(url, cookies[x].getValue());
            }
            CookieSyncManager.getInstance().sync();
            cookie = CookieManager.getInstance().getCookie(url);
          }
        } catch (IOException e) {
          Log.e(TAG, e.toString());
        }
      }
      return cookie;
    }","private String getCookie(String url) {
      String cookie = CookieManager.getInstance().getCookie(url);
      if (cookie == null || cookie.length() == 0) {
        Log.v(TAG, ""Book Search cookie was missing or expired"");
        HttpHead head = new HttpHead(url);
        AndroidHttpClient client = AndroidHttpClient.newInstance(mUserAgent);
        try {
          HttpResponse response = client.execute(head);
          if (response.getStatusLine().getStatusCode() == 200) {
            Header[] cookies = response.getHeaders(""set-cookie"");
            for (int x = 0; x < cookies.length; x++) {
              CookieManager.getInstance().setCookie(url, cookies[x].getValue());
            }
            CookieSyncManager.getInstance().sync();
            cookie = CookieManager.getInstance().getCookie(url);
          }
        } catch (IOException e) {
          Log.e(TAG, e.toString());
        }
        client.close();
      }
      return cookie;
    }",no,no,"Yes
Leaky Resources:
AndroidHttpClient","Yes
Leaky Resources:
AndroidHttpClient"
IRCCloud,android.net.wifi.WifiManager.WifiLock,35e0a587e3,1ab8ba96f6,removeHandler @line 1690,NetworkConnection.java,,yes,n/a,n/a,n/a,,n/a,yes,yes,,,n/a,n/a,n/a,,n/a,yes,yes,,,,yes,leak on certain normal paths,,https://github.com/irccloud/android,src/com/irccloud/android/NetworkConnection.java,https://github.com/irccloud/android/commit/35e0a587e3e9ed376b36355dfbccdeed049aae85,https://github.com/irccloud/android/commit/1ab8ba96f6569dedb0c0cad969f5e75edb96a001,"public void removeHandler(Handler handler) {
  handlers.remove(handler);
  if(handlers.isEmpty()){
   if(shutdownTimer == null) {
    shutdownTimer = new Timer();
    SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(IRCCloudApplication.getInstance().getApplicationContext());
    long timeout = Long.valueOf(prefs.getString(""timeout"", ""300000""));
    shutdownTimer.schedule( new TimerTask(){
               public void run() {
                if(handlers.isEmpty()) {
                    disconnect();
                }
                   shutdownTimer = null;
                }
             }, timeout);
   }
   if(idleTimer != null && state != STATE_CONNECTED) {
    idleTimer.cancel();
    idleTimer = null;
    state = STATE_DISCONNECTED;
   }
  }
 }","public void removeHandler(Handler handler) {
  handlers.remove(handler);
  if(handlers.isEmpty()){
   if(shutdownTimer == null) {
    shutdownTimer = new Timer();
    SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(IRCCloudApplication.getInstance().getApplicationContext());
    long timeout = Long.valueOf(prefs.getString(""timeout"", ""300000""));
    shutdownTimer.schedule( new TimerTask(){
               public void run() {
                if(handlers.isEmpty()) {
                    disconnect();
                }
                   shutdownTimer = null;
                }
             }, timeout);
   }
   if(idleTimer != null && state != STATE_CONNECTED) {
    idleTimer.cancel();
    idleTimer = null;
                failCount = 0;
                if(wifiLock.isHeld())
                    wifiLock.release();
                reconnect_timestamp = 0;
    state = STATE_DISCONNECTED;
   }
  }
 }",no,no,"No
Leaky Resources:
None","No
Leaky Resources: None

The provided code snippet does not appear to have any resource leaks. All resources such as timers and locks are properly managed and released when not needed."
Cgeo,android.os.Parcel,23bf7d5801,253c271b34,testParcel(),ImageTest.java,Pull 2,yes,n/a,no,n/a,,n/a,n/a,n/a,,,n/a,no,n/a,,n/a,n/a,n/a,,,,no,complete leak,,https://github.com/cgeo/cgeo,tests/src/cgeo/geocaching/ImageTest.java,https://github.com/cgeo/cgeo/commit/23bf7d5801aff5d29b4dd5ca818bf732d8e6a1b7,https://github.com/cgeo/cgeo/commit/253c271b345cf225afda2b2b16da2756e5e9f9d5,"public static void testParcel() throws Exception {
        final Image image1 = new Image.Builder().setUrl(FILE1).setTitle(""Title1"").setDescription(""Description1"").build();

        final Parcel parcel = Parcel.obtain();
        image1.writeToParcel(parcel, 0);
        parcel.setDataPosition(0);

        final Image image2 = Image.CREATOR.createFromParcel(parcel);

        assertThat(image1).isEqualTo(image2);
    }","public static void testParcel() throws Exception {
        final Image image1 = new Image.Builder().setUrl(FILE1).setTitle(""Title1"").setDescription(""Description1"").build();

        final Parcel parcel = Parcel.obtain();
        image1.writeToParcel(parcel, 0);
        parcel.setDataPosition(0);

        final Image image2 = Image.CREATOR.createFromParcel(parcel);

        assertThat(image1).isEqualTo(image2);
        parcel.recycle();
    }",no,no,"No
Leaky Resources:
None","No
Leaky Resources:
None"
K-9 Mail,android.os.ParcelFileDescriptor,58efee8be2,71a8ffc2b5,executeApi() @line 222,OpenPgpApi.java,,yes,no,n/a,n/a,,n/a,n/a,n/a,,,no,n/a,n/a,,n/a,n/a,n/a,,,,yes,complete leak,,https://github.com/k9mail/k-9,plugins/openpgp-api-library/src/org/openintents/openpgp/util/OpenPgpApi.java,https://github.com/k9mail/k-9/commit/58efee8be21f2c21b1cf2db34e15cf9d163fcbed,https://github.com/k9mail/k-9/commit/71a8ffc2b55e5375368ec2509197437f8c052c6e,"public Intent executeApi(Intent data, InputStream is, OutputStream os) {

        try {
            data.putExtra(EXTRA_API_VERSION, OpenPgpApi.API_VERSION);

            Intent result = null;
            if (ACTION_GET_KEY_IDS.equals(data.getAction())) {
                result = mService.execute(data, null, null);
                return result;
            } else {
                // pipe the input and output
                ParcelFileDescriptor input = ParcelFileDescriptorUtil.pipeFrom(is,
    
                        new ParcelFileDescriptorUtil.IThreadListener() {

                            @Override
                            public void onThreadFinished(Thread thread) {
                                //Log.d(OpenPgpApi.TAG, ""Copy to service finished"");
                            }
                        });
                ParcelFileDescriptor output = ParcelFileDescriptorUtil.pipeTo(os,
                        new ParcelFileDescriptorUtil.IThreadListener() {
                            @Override
                            public void onThreadFinished(Thread thread) {
                                //Log.d(OpenPgpApi.TAG, ""Service finished writing!"");
                            }
                        });
                // blocks until result is ready
                result = mService.execute(data, input, output);
                // close() is required to halt the TransferThread
                output.close();
                // set class loader to current context to allow unparcelling
                // of OpenPgpError and OpenPgpSignatureResult
                // http://stackoverflow.com/a/3806769
                result.setExtrasClassLoader(mContext.getClassLoader());
                return result;
            }
        } catch (Exception e) {
            Log.e(OpenPgpApi.TAG, ""Exception"", e);
            Intent result = new Intent();
            result.putExtra(RESULT_CODE, RESULT_CODE_ERROR);
            result.putExtra(RESULT_ERROR,
                    new OpenPgpError(OpenPgpError.CLIENT_SIDE_ERROR, e.getMessage()));
            return result;
        }
    }","public Intent executeApi(Intent data, InputStream is, OutputStream os) {
        ParcelFileDescriptor input = null;
        try {
            data.putExtra(EXTRA_API_VERSION, OpenPgpApi.API_VERSION);

            Intent result = null;

            if (ACTION_GET_KEY_IDS.equals(data.getAction())) {
                result = mService.execute(data, null, null);
                return result;
            } else {
                // pipe the input and output
                input = ParcelFileDescriptorUtil.pipeFrom(is,
                        new ParcelFileDescriptorUtil.IThreadListener() {

                            @Override
                            public void onThreadFinished(Thread thread) {
                                //Log.d(OpenPgpApi.TAG, ""Copy to service finished"");
                            }
                        });
                ParcelFileDescriptor output = ParcelFileDescriptorUtil.pipeTo(os,
                        new ParcelFileDescriptorUtil.IThreadListener() {

                            @Override
                            public void onThreadFinished(Thread thread) {
                                //Log.d(OpenPgpApi.TAG, ""Service finished writing!"");
                            }
                        });

                // blocks until result is ready
                result = mService.execute(data, input, output);
                // close() is required to halt the TransferThread
                output.close();

                // set class loader to current context to allow unparcelling
                // of OpenPgpError and OpenPgpSignatureResult
                // http://stackoverflow.com/a/3806769
                result.setExtrasClassLoader(mContext.getClassLoader());

                return result;
            }
        } catch (Exception e) {
            Log.e(OpenPgpApi.TAG, ""Exception"", e);
            Intent result = new Intent();
            result.putExtra(RESULT_CODE, RESULT_CODE_ERROR);
            result.putExtra(RESULT_ERROR,
                    new OpenPgpError(OpenPgpError.CLIENT_SIDE_ERROR, e.getMessage()));
            return result;
        } finally {
            if (input != null) {
                try {
                    input.close();
                } catch (IOException e) {
                    Log.e(OpenPgpApi.TAG, ""Failed to close input file descriptor"", e);
                }
            }
        }
    }",no,no,"Yes
Leaky Resources:
InputStream, OutputStream

Explanation:
The InputStream 'is' and OutputStream 'os' are opened but not properly closed in a finally block. If an exception occurs before the output.close() statement on line 31, the streams will not be closed, leading to a resource leak.","Yes
Leaky Resources:
InputStream, OutputStream"
K-9 Mail,android.os.PowerManager.WakeLock,f1232a119a,e6132286a0,checkMail(),MessagingController.java,,yes,n/a,n/a,n/a,,n/a,yes,yes,no,yes,n/a,n/a,n/a,,n/a,yes,yes,no,yes,,yes,complete leak,,https://github.com/k9mail/k-9,src/com/android/email/MessagingController.java,https://github.com/k9mail/k-9/commit/f1232a119aedee26d41f21e200a44d7716e77ac2,https://github.com/k9mail/k-9/commit/e6132286a00ce2676a0ad79ffc9f8c87e4cf7e6e,"public void checkMail(final Context context, final Account account, 
            final boolean ignoreLastCheckedTime,
            final boolean useManualWakeLock,
            final MessagingListener listener) {
    	
      if (useManualWakeLock) {
        PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
        WakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""Email"");
        wakeLock.setReferenceCounted(false);
        wakeLock.acquire(Email.MANUAL_WAKE_LOCK_TIMEOUT);
      }
      
      
        for (MessagingListener l : getListeners()) {
            l.checkMailStarted(context, account);
        }
        put(""checkMail"", listener, new Runnable() {
            public void run() {

                final NotificationManager notifMgr = (NotificationManager)context
                  .getSystemService(Context.NOTIFICATION_SERVICE);
            	  try
            	  {
	              	Log.i(Email.LOG_TAG, ""Starting mail check"");
          				Preferences prefs = Preferences.getPreferences(context);

	                Account[] accounts;
	                if (account != null) {
	                    accounts = new Account[] {
	                        account
	                    };
	                } else {
	                    accounts = prefs.getAccounts();
	                }

	                for (final Account account : accounts) {
	                  	final long accountInterval = account.getAutomaticCheckIntervalMinutes() * 60 * 1000;
	                  	if (ignoreLastCheckedTime == false && accountInterval <= 0)
	                  	{
		                  	if (Config.LOGV || true)
		                  	{
		                  		Log.v(Email.LOG_TAG, ""Skipping synchronizing account "" + account.getDescription());
		                  	}

	                  		continue;
	                  	}

	                  	if (Config.LOGV || true)
	                  	{
	                  		Log.v(Email.LOG_TAG, ""Synchronizing account "" + account.getDescription());
	                  	}
                    	putBackground(""sendPending "" + account.getDescription(), null, new Runnable() {
                        public void run() {
                          if (account.isShowOngoing()) {
                            Notification notif = new Notification(R.drawable.ic_menu_refresh, 
                                context.getString(R.string.notification_bg_send_ticker, account.getDescription()), System.currentTimeMillis());                         
                            // JRV XXX TODO - do we want to notify MessageList too? 
                            Intent intent = FolderList.actionHandleAccountIntent(context, account, Email.INBOX);
                            PendingIntent pi = PendingIntent.getActivity(context, 0, intent, 0);
                              notif.setLatestEventInfo(context, context.getString(R.string.notification_bg_send_title), 
                                  account.getDescription() , pi);
                              notif.flags = Notification.FLAG_ONGOING_EVENT;
                              
                              if (Email.NOTIFICATION_LED_WHILE_SYNCING) {
                                notif.flags |= Notification.FLAG_SHOW_LIGHTS;
                                notif.ledARGB = Email.NOTIFICATION_LED_DIM_COLOR;
                                notif.ledOnMS = Email.NOTIFICATION_LED_FAST_ON_TIME;
                                notif.ledOffMS = Email.NOTIFICATION_LED_FAST_OFF_TIME;
                              }
                              
                              notifMgr.notify(Email.FETCHING_EMAIL_NOTIFICATION_ID, notif);
                          }
                          try
                          {
                            sendPendingMessagesSynchronous(account);
                          }
                        	finally {
                        	  if (account.isShowOngoing()) {
                        	    notifMgr.cancel(Email.FETCHING_EMAIL_NOTIFICATION_ID);
                        	  }
                          }
                        }
                    	}
                    	);
	                    try
	                    {
	                    	Account.FolderMode aDisplayMode = account.getFolderDisplayMode();
	                    	Account.FolderMode aSyncMode = account.getFolderSyncMode();

		                    Store localStore = Store.getInstance(account.getLocalStoreUri(), mApplication);
		                    for (final Folder folder : localStore.getPersonalNamespaces())
		                    {
		                    	
		                    	folder.open(Folder.OpenMode.READ_WRITE);
		                    	folder.refresh(prefs);
		                    	
		                    	Folder.FolderClass fDisplayMode = folder.getDisplayClass();
		                    	Folder.FolderClass fSyncMode = folder.getSyncClass();

		                    	if ((aDisplayMode == Account.FolderMode.FIRST_CLASS && 
		                    					fDisplayMode != Folder.FolderClass.FIRST_CLASS) 
		                    			|| (aDisplayMode == Account.FolderMode.FIRST_AND_SECOND_CLASS &&
		                      					fDisplayMode != Folder.FolderClass.FIRST_CLASS &&
		                      					fDisplayMode != Folder.FolderClass.SECOND_CLASS) 
		                      		|| (aDisplayMode == Account.FolderMode.NOT_SECOND_CLASS &&
		                      					fDisplayMode == Folder.FolderClass.SECOND_CLASS))
		                      {
		                    		// Never sync a folder that isn't displayed
			                    	if (Config.LOGV) {
			                    		Log.v(Email.LOG_TAG, ""Not syncing folder "" + folder.getName() + 
			                    				"" which is in display mode "" + fDisplayMode + "" while account is in display mode "" + aDisplayMode);
			                    	}

		                       	continue;
		                      }

		                    	if ((aSyncMode == Account.FolderMode.FIRST_CLASS && 
		                    			fSyncMode != Folder.FolderClass.FIRST_CLASS)
		                    			|| (aSyncMode == Account.FolderMode.FIRST_AND_SECOND_CLASS &&
		                      					fSyncMode != Folder.FolderClass.FIRST_CLASS &&
		                      					fSyncMode != Folder.FolderClass.SECOND_CLASS) 
		                    			|| (aSyncMode == Account.FolderMode.NOT_SECOND_CLASS &&
		                    					fSyncMode == Folder.FolderClass.SECOND_CLASS))
		                      {
		                    		// Do not sync folders in the wrong class
			                    	if (Config.LOGV) {
			                    		Log.v(Email.LOG_TAG, ""Not syncing folder "" + folder.getName() + 
			                    				"" which is in sync mode "" + fSyncMode + "" while account is in sync mode "" + aSyncMode);
			                    	}

		                       	continue;
		                      }
	                    	
		                    	
	
		                    	if (Config.LOGV) {
		                    		Log.v(Email.LOG_TAG, ""Folder "" + folder.getName() + "" was last synced @ "" +
		                    				new Date(folder.getLastChecked()));
		                    	}
		                    	
		                    	if (ignoreLastCheckedTime == false && folder.getLastChecked() > 
		                    		(System.currentTimeMillis() - accountInterval))
		                    	{
			                    		if (Config.LOGV) {
			                    			Log.v(Email.LOG_TAG, ""Not syncing folder "" + folder.getName()
			                    					+ "", previously synced @ "" + new Date(folder.getLastChecked())
			                    							+ "" which would be too recent for the account period"");
			                    		}					

		                    			continue;
		                    	}
		                    	putBackground(""sync"" + folder.getName(), null, new Runnable() {
		                        public void run() {
				                    	try {
				                    		// In case multiple Commands get enqueued, don't run more than
				                    		// once
				                    		final LocalStore localStore =
				                          (LocalStore) Store.getInstance(account.getLocalStoreUri(), mApplication);
				                    		LocalFolder tLocalFolder = (LocalFolder) localStore.getFolder(folder.getName());
				                    		tLocalFolder.open(Folder.OpenMode.READ_WRITE);
				                    						                    		
				                    		if (ignoreLastCheckedTime == false && tLocalFolder.getLastChecked() > 
				                    			    (System.currentTimeMillis() - accountInterval))
				                    		{
				                    			if (Config.LOGV) {
					                    			Log.v(Email.LOG_TAG, ""Not running Command for folder "" + folder.getName()
					                    					+ "", previously synced @ "" + new Date(folder.getLastChecked())
					                    							+ "" which would be too recent for the account period"");
				                    			}
				                    			return;
				                    		}
				                    		if (account.isShowOngoing()) {
  				                    		Notification notif = new Notification(R.drawable.ic_menu_refresh, 
  				                    		    context.getString(R.string.notification_bg_sync_ticker, account.getDescription(), folder.getName()), 
  				                    		    System.currentTimeMillis());                         
                                      // JRV XXX TODO - do we want to notify MessageList too? 
  			                          Intent intent = FolderList.actionHandleAccountIntent(context, account, Email.INBOX);
  			                          PendingIntent pi = PendingIntent.getActivity(context, 0, intent, 0);
  			                            notif.setLatestEventInfo(context, context.getString(R.string.notification_bg_sync_title), account.getDescription()
  			                                + context.getString(R.string.notification_bg_title_separator) + folder.getName(), pi);
  			                            notif.flags = Notification.FLAG_ONGOING_EVENT;
  			                            if (Email.NOTIFICATION_LED_WHILE_SYNCING) {
    			                            notif.flags |= Notification.FLAG_SHOW_LIGHTS;
    			                            notif.ledARGB = Email.NOTIFICATION_LED_DIM_COLOR;
    			                            notif.ledOnMS = Email.NOTIFICATION_LED_FAST_ON_TIME;
    			                            notif.ledOffMS = Email.NOTIFICATION_LED_FAST_OFF_TIME;
  			                            }
  
  			                            notifMgr.notify(Email.FETCHING_EMAIL_NOTIFICATION_ID, notif);
				                    		}
			                          try
			                          {
			                            synchronizeMailboxSynchronous(account, folder.getName());
			                          }
				                    	  
		                            finally {
		                              if (account.isShowOngoing()) {
		                                notifMgr.cancel(Email.FETCHING_EMAIL_NOTIFICATION_ID);
		                              }
		                            }
				                    	}
				                    	catch (Exception e)
				                    	{
				                    		
				                    		Log.e(Email.LOG_TAG, ""Exception while processing folder "" + 
				                    				account.getDescription() + "":"" + folder.getName(), e);
				                    		addErrorMessage(account, e);
				                    	}
		                        }
		                    	}
		                    	);
		                    } 
	                    }
	                    catch (MessagingException e) {
	                      Log.e(Email.LOG_TAG, ""Unable to synchronize account "" + account.getName(), e);
	                      addErrorMessage(account, e);
	                    }
	                }
            	  }
            	  catch (Exception e)
            	  {
            	  	 Log.e(Email.LOG_TAG, ""Unable to synchronize mail"", e);
            	  	 addErrorMessage(account, e);
            	  }
              	putBackground(""finalize sync"", null, new Runnable() {
                  public void run() {

		            	  Log.i(Email.LOG_TAG, ""Finished mail sync"");
		             	 
		                for (MessagingListener l : getListeners()) {
		                    l.checkMailFinished(context, account);
		                }
		                
                  }
              	}
              	);
            }
        });
    }","public void checkMail(final Context context, final Account account, 
            final boolean ignoreLastCheckedTime,
            final boolean useManualWakeLock,
            final MessagingListener listener) {
        
      WakeLock twakeLock = null;
      if (useManualWakeLock) {
        PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
        twakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""Email"");
        twakeLock.setReferenceCounted(false);
        twakeLock.acquire(Email.MANUAL_WAKE_LOCK_TIMEOUT);
      }
      final WakeLock wakeLock = twakeLock;
      
        for (MessagingListener l : getListeners()) {
            l.checkMailStarted(context, account);
        }
        put(""checkMail"", listener, new Runnable() {
            public void run() {

                final NotificationManager notifMgr = (NotificationManager)context
                  .getSystemService(Context.NOTIFICATION_SERVICE);
            	  try
            	  {
	              	Log.i(Email.LOG_TAG, ""Starting mail check"");
          				Preferences prefs = Preferences.getPreferences(context);

	                Account[] accounts;
	                if (account != null) {
	                    accounts = new Account[] {
	                        account
	                    };
	                } else {
	                    accounts = prefs.getAccounts();
	                }

	                for (final Account account : accounts) {
	                  	final long accountInterval = account.getAutomaticCheckIntervalMinutes() * 60 * 1000;
	                  	if (ignoreLastCheckedTime == false && accountInterval <= 0)
	                  	{
		                  	if (Config.LOGV || true)
		                  	{
		                  		Log.v(Email.LOG_TAG, ""Skipping synchronizing account "" + account.getDescription());
		                  	}

	                  		continue;
	                  	}

	                  	if (Config.LOGV || true)
	                  	{
	                  		Log.v(Email.LOG_TAG, ""Synchronizing account "" + account.getDescription());
	                  	}
                    	putBackground(""sendPending "" + account.getDescription(), null, new Runnable() {
                        public void run() {
                          if (account.isShowOngoing()) {
                            Notification notif = new Notification(R.drawable.ic_menu_refresh, 
                                context.getString(R.string.notification_bg_send_ticker, account.getDescription()), System.currentTimeMillis());                         
                            // JRV XXX TODO - do we want to notify MessageList too? 
                            Intent intent = FolderList.actionHandleAccountIntent(context, account, Email.INBOX);
                            PendingIntent pi = PendingIntent.getActivity(context, 0, intent, 0);
                              notif.setLatestEventInfo(context, context.getString(R.string.notification_bg_send_title), 
                                  account.getDescription() , pi);
                              notif.flags = Notification.FLAG_ONGOING_EVENT;
                              
                              if (Email.NOTIFICATION_LED_WHILE_SYNCING) {
                                notif.flags |= Notification.FLAG_SHOW_LIGHTS;
                                notif.ledARGB = Email.NOTIFICATION_LED_DIM_COLOR;
                                notif.ledOnMS = Email.NOTIFICATION_LED_FAST_ON_TIME;
                                notif.ledOffMS = Email.NOTIFICATION_LED_FAST_OFF_TIME;
                              }
                              
                              notifMgr.notify(Email.FETCHING_EMAIL_NOTIFICATION_ID, notif);
                          }
                          try
                          {
                            sendPendingMessagesSynchronous(account);
                          }
                        	finally {
                        	  if (account.isShowOngoing()) {
                        	    notifMgr.cancel(Email.FETCHING_EMAIL_NOTIFICATION_ID);
                        	  }
                          }
                        }
                    	}
                    	);
	                    try
	                    {
	                    	Account.FolderMode aDisplayMode = account.getFolderDisplayMode();
	                    	Account.FolderMode aSyncMode = account.getFolderSyncMode();

		                    Store localStore = Store.getInstance(account.getLocalStoreUri(), mApplication);
		                    for (final Folder folder : localStore.getPersonalNamespaces())
		                    {
		                    	
		                    	folder.open(Folder.OpenMode.READ_WRITE);
		                    	folder.refresh(prefs);
		                    	
		                    	Folder.FolderClass fDisplayMode = folder.getDisplayClass();
		                    	Folder.FolderClass fSyncMode = folder.getSyncClass();

		                    	if ((aDisplayMode == Account.FolderMode.FIRST_CLASS && 
		                    					fDisplayMode != Folder.FolderClass.FIRST_CLASS) 
		                    			|| (aDisplayMode == Account.FolderMode.FIRST_AND_SECOND_CLASS &&
		                      					fDisplayMode != Folder.FolderClass.FIRST_CLASS &&
		                      					fDisplayMode != Folder.FolderClass.SECOND_CLASS) 
		                      		|| (aDisplayMode == Account.FolderMode.NOT_SECOND_CLASS &&
		                      					fDisplayMode == Folder.FolderClass.SECOND_CLASS))
		                      {
		                    		// Never sync a folder that isn't displayed
			                    	if (Config.LOGV) {
			                    		Log.v(Email.LOG_TAG, ""Not syncing folder "" + folder.getName() + 
			                    				"" which is in display mode "" + fDisplayMode + "" while account is in display mode "" + aDisplayMode);
			                    	}

		                       	continue;
		                      }

		                    	if ((aSyncMode == Account.FolderMode.FIRST_CLASS && 
		                    			fSyncMode != Folder.FolderClass.FIRST_CLASS)
		                    			|| (aSyncMode == Account.FolderMode.FIRST_AND_SECOND_CLASS &&
		                      					fSyncMode != Folder.FolderClass.FIRST_CLASS &&
		                      					fSyncMode != Folder.FolderClass.SECOND_CLASS) 
		                    			|| (aSyncMode == Account.FolderMode.NOT_SECOND_CLASS &&
		                    					fSyncMode == Folder.FolderClass.SECOND_CLASS))
		                      {
		                    		// Do not sync folders in the wrong class
			                    	if (Config.LOGV) {
			                    		Log.v(Email.LOG_TAG, ""Not syncing folder "" + folder.getName() + 
			                    				"" which is in sync mode "" + fSyncMode + "" while account is in sync mode "" + aSyncMode);
			                    	}

		                       	continue;
		                      }
	                    	
		                    	
	
		                    	if (Config.LOGV) {
		                    		Log.v(Email.LOG_TAG, ""Folder "" + folder.getName() + "" was last synced @ "" +
		                    				new Date(folder.getLastChecked()));
		                    	}
		                    	
		                    	if (ignoreLastCheckedTime == false && folder.getLastChecked() > 
		                    		(System.currentTimeMillis() - accountInterval))
		                    	{
			                    		if (Config.LOGV) {
			                    			Log.v(Email.LOG_TAG, ""Not syncing folder "" + folder.getName()
			                    					+ "", previously synced @ "" + new Date(folder.getLastChecked())
			                    							+ "" which would be too recent for the account period"");
			                    		}					

		                    			continue;
		                    	}
		                    	putBackground(""sync"" + folder.getName(), null, new Runnable() {
		                        public void run() {
				                    	try {
				                    		// In case multiple Commands get enqueued, don't run more than
				                    		// once
				                    		final LocalStore localStore =
				                          (LocalStore) Store.getInstance(account.getLocalStoreUri(), mApplication);
				                    		LocalFolder tLocalFolder = (LocalFolder) localStore.getFolder(folder.getName());
				                    		tLocalFolder.open(Folder.OpenMode.READ_WRITE);
				                    						                    		
				                    		if (ignoreLastCheckedTime == false && tLocalFolder.getLastChecked() > 
				                    			    (System.currentTimeMillis() - accountInterval))
				                    		{
				                    			if (Config.LOGV) {
					                    			Log.v(Email.LOG_TAG, ""Not running Command for folder "" + folder.getName()
					                    					+ "", previously synced @ "" + new Date(folder.getLastChecked())
					                    							+ "" which would be too recent for the account period"");
				                    			}
				                    			return;
				                    		}
				                    		if (account.isShowOngoing()) {
  				                    		Notification notif = new Notification(R.drawable.ic_menu_refresh, 
  				                    		    context.getString(R.string.notification_bg_sync_ticker, account.getDescription(), folder.getName()), 
  				                    		    System.currentTimeMillis());                         
                                      // JRV XXX TODO - do we want to notify MessageList too? 
  			                          Intent intent = FolderList.actionHandleAccountIntent(context, account, Email.INBOX);
  			                          PendingIntent pi = PendingIntent.getActivity(context, 0, intent, 0);
  			                            notif.setLatestEventInfo(context, context.getString(R.string.notification_bg_sync_title), account.getDescription()
  			                                + context.getString(R.string.notification_bg_title_separator) + folder.getName(), pi);
  			                            notif.flags = Notification.FLAG_ONGOING_EVENT;
  			                            if (Email.NOTIFICATION_LED_WHILE_SYNCING) {
    			                            notif.flags |= Notification.FLAG_SHOW_LIGHTS;
    			                            notif.ledARGB = Email.NOTIFICATION_LED_DIM_COLOR;
    			                            notif.ledOnMS = Email.NOTIFICATION_LED_FAST_ON_TIME;
    			                            notif.ledOffMS = Email.NOTIFICATION_LED_FAST_OFF_TIME;
  			                            }
  
  			                            notifMgr.notify(Email.FETCHING_EMAIL_NOTIFICATION_ID, notif);
				                    		}
			                          try
			                          {
			                            synchronizeMailboxSynchronous(account, folder.getName());
			                          }
				                    	  
		                            finally {
		                              if (account.isShowOngoing()) {
		                                notifMgr.cancel(Email.FETCHING_EMAIL_NOTIFICATION_ID);
		                              }
		                            }
				                    	}
				                    	catch (Exception e)
				                    	{
				                    		
				                    		Log.e(Email.LOG_TAG, ""Exception while processing folder "" + 
				                    				account.getDescription() + "":"" + folder.getName(), e);
				                    		addErrorMessage(account, e);
				                    	}
		                        }
		                    	}
		                    	);
		                    } 
	                    }
	                    catch (MessagingException e) {
	                      Log.e(Email.LOG_TAG, ""Unable to synchronize account "" + account.getName(), e);
	                      addErrorMessage(account, e);
	                    }
	                }
            	  }
            	  catch (Exception e)
            	  {
            	  	 Log.e(Email.LOG_TAG, ""Unable to synchronize mail"", e);
            	  	 addErrorMessage(account, e);
            	  }
              	putBackground(""finalize sync"", null, new Runnable() {
                  public void run() {

		            	  Log.i(Email.LOG_TAG, ""Finished mail sync"");
		            	  if (wakeLock != null)
		            	  {
		            	      wakeLock.release();
		            	  }
		                for (MessagingListener l : getListeners()) {
		                    l.checkMailFinished(context, account);
		                }
		                
                  }
              	}
              	);
            }
        });
    }",no,no,"Yes
Leaky Resources:
WakeLock, Folder

In the provided code snippet, there are two potential resource leaks:

1. WakeLock: The WakeLock is acquired at line 10 but it is never released. This can cause a resource leak as the WakeLock will keep the CPU running even when it's not needed anymore.

2. Folder: The Folder resource is opened at line 94 and line 160 but it is never closed. This can cause a resource leak as the opened Folder will keep the resources occupied even when it's not needed anymore.","Yes
Leaky Resources:
WakeLock"
CallMeter,android.os.PowerManager.WakeLock,4e9106ccf2,10729ea13b,onHandleIntent() ,LogRunnerService.java,,yes,n/a,n/a,n/a,,n/a,yes,no,yes,yes,n/a,n/a,n/a,,n/a,no,no,yes,no,,yes,leak on certain normal paths,,https://github.com/felixb/callmeter,src/de/ub0r/android/callmeter/data/LogRunnerService.java,https://github.com/felixb/callmeter/commit/4e9106ccf2510d29ec0f0024378db92ddab965ab,https://github.com/felixb/callmeter/commit/10729ea13bab0c4dadfa7fe765fc743ef1385fa0,"@Override
	protected void onHandleIntent(final Intent intent) {
		if (intent == null) {
			Log.w(TAG, ""onHandleIntent(null)"");
			return;
		}
		final String a = intent.getAction();
		Log.d(TAG, ""onHandleIntent("" + a + "")"");

		final PowerManager pm = (PowerManager) this
				.getSystemService(Context.POWER_SERVICE);
		final PowerManager.WakeLock wakelock = pm.newWakeLock(
				PowerManager.PARTIAL_WAKE_LOCK, TAG);
		wakelock.acquire();
		Log.i(TAG, ""got wakelock"");

		if (a != null && (// .
				a.equals(TelephonyManager.ACTION_PHONE_STATE_CHANGED) // .
				|| a.equals(ACTION_SMS))) {
			Log.i(TAG, ""sleep for "" + WAIT_FOR_LOGS + ""ms"");
			try {
				Thread.sleep(WAIT_FOR_LOGS);
			} catch (InterruptedException e) {
				Log.e(TAG, ""interrupted while waiting for logs"", e);
			}
		}

		final Handler h = Plans.getHandler();
		if (h != null) {
			h.sendEmptyMessage(Plans.MSG_BACKGROUND_START_MATCHER);
		}

		// update roaming info
		roaming = ((TelephonyManager) this
				.getSystemService(Context.TELEPHONY_SERVICE))
				.isNetworkRoaming();
		Log.d(TAG, ""roaming: "" + roaming);
		final SharedPreferences p = PreferenceManager
				.getDefaultSharedPreferences(this);
		if (System.currentTimeMillis() - // .
				p.getLong(PREFS_LASTBACKUP, 0L) > BACKUP_PERIOD) {
			if (DataProvider.doBackup(this)) {
				p.edit().putLong(PREFS_LASTBACKUP, System.currentTimeMillis())
						.commit();
			}
		}
		dateStart = p.getLong(Preferences.PREFS_DATE_BEGIN,
				DatePreference.DEFAULT_VALUE);
		deleteBefore = Preferences.getDeleteLogsBefore(p);
		splitAt160 = p.getBoolean(Preferences.PREFS_SPLIT_SMS_AT_160, false);
		final boolean showCallInfo = p.getBoolean(
				Preferences.PREFS_SHOWCALLINFO, false);
		final boolean askForPlan = p.getBoolean(Preferences.PREFS_ASK_FOR_PLAN,
				false);

		final boolean runMatcher = a == ACTION_RUN_MATCHER;
		boolean shortRun = runMatcher
				|| a != null
				&& (a.equals(Intent.ACTION_BOOT_COMPLETED)
						|| a.equals(Intent.ACTION_SHUTDOWN) // .
						|| a.equals(Intent.ACTION_REBOOT) // .
				|| a.equals(Intent.ACTION_DATE_CHANGED));

		if (!shortRun && a != null
				&& a.equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
			if (intent.getBooleanExtra(ConnectivityManager.EXTRA_IS_FAILOVER,
					false)) {
				return;
			}
			shortRun = true;
		}

		final ContentResolver cr = this.getContentResolver();
		boolean showDialog = false;
		if (!shortRun && h != null) {
			final Cursor c = cr.query(DataProvider.Logs.CONTENT_URI,
					new String[] { DataProvider.Logs.PLAN_ID },
					DataProvider.Logs.RULE_ID + "" != "" + DataProvider.NO_ID
							+ "" AND "" + DataProvider.Logs.TYPE + "" != ""
							+ DataProvider.TYPE_DATA, null, null);
			if (c.getCount() < UNMATHCEDLOGS_TO_SHOW_DIALOG) {
				showDialog = true;
				// skip if no plan is set up
				Cursor c1 = cr.query(DataProvider.Plans.CONTENT_URI,
						new String[] { DataProvider.Plans.ID }, null, null,
						null);
				if (c1.getCount() <= 0) {
					shortRun = true;
					showDialog = false;
				}
				c1.close();
				// skip if no rule is set up
				c1 = cr.query(DataProvider.Rules.CONTENT_URI,
						new String[] { DataProvider.Rules.ID }, null, null,
						null);
				if (c1.getCount() <= 0) {
					shortRun = true;
					showDialog = false;
				}
				c1.close();
				if (showDialog) {
					h.sendEmptyMessage(Plans.MSG_BACKGROUND_START_RUNNER);
				}
			}
			c.close();
		}
		updateData(this, shortRun && !runMatcher);
		if (!shortRun || runMatcher) {
			if (deleteBefore > 0L) {
				deleteOldLogs(cr);
			}
			updateCalls(cr);
			updateSMS(cr, DataProvider.DIRECTION_IN);
			updateSMS(cr, DataProvider.DIRECTION_OUT);
			updateMMS(this);
			if (RuleMatcher.match(this, showDialog)) {
				StatsAppWidgetProvider.updateWidgets(this);
			}
		} else if (roaming) {
			updateCalls(cr);
			updateSMS(cr, DataProvider.DIRECTION_IN);
			updateSMS(cr, DataProvider.DIRECTION_OUT);
			updateMMS(this);
		}

		if (showDialog) {
			h.sendEmptyMessage(Plans.MSG_BACKGROUND_STOP_RUNNER);
		}

		if ((showCallInfo || askForPlan) && a != null && a.equals(// .
				TelephonyManager.ACTION_PHONE_STATE_CHANGED)) {
			final Cursor c = cr.query(DataProvider.Logs.CONTENT_URI,
					DataProvider.Logs.PROJECTION, DataProvider.Logs.TYPE
							+ "" = "" + DataProvider.TYPE_CALL, null,
					DataProvider.Logs.DATE + "" DESC"");
			if (c != null && c.moveToFirst()) {
				final long id = c.getLong(DataProvider.Logs.INDEX_ID);
				final long date = c.getLong(DataProvider.Logs.INDEX_DATE);
				final long amount = c.getLong(DataProvider.Logs.INDEX_AMOUNT);

				final long now = System.currentTimeMillis();
				if (amount > 0L
						&& date + amount * CallMeter.MILLIS + GAP_FOR_LOGS // .
						>= now) {
					// only show real calls
					// only show calls made just now
					final float cost = c.getFloat(DataProvider.Logs.INDEX_COST);
					final String planname = DataProvider.Plans.getName(cr,
							c.getLong(DataProvider.Logs.INDEX_PLAN_ID));
					StringBuffer sb = new StringBuffer();
					sb.append(Common.prettySeconds(amount, false));
					if (cost > 0) {
						String currencyFormat = Preferences
								.getCurrencyFormat(this);
						sb.append("" | "" // FIXME
								+ String.format(currencyFormat, cost));
					}
					if (planname != null) {
						sb.insert(0, planname + "": "");
					} else if (askForPlan) {
						this.handler.post(new Runnable() {
							@Override
							public void run() {
								Log.i(TAG, ""launching ask for plan dialog"");
								final Intent i = new Intent(
										LogRunnerService.this, // .
										AskForPlan.class);
								i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
								i.putExtra(AskForPlan.EXTRA_ID, id);
								i.putExtra(AskForPlan.EXTRA_DATE, date);
								i.putExtra(AskForPlan.EXTRA_AMOUNT, amount);
								LogRunnerService.this.startActivity(i);
							}
						});
					}
					if (showCallInfo) {
						final String s = sb.toString();
						Log.i(TAG, ""Toast: "" + s);
						this.handler.post(new Runnable() {
							@Override
							public void run() {
								final Toast toast = Toast.makeText(
										LogRunnerService.this, s,
										Toast.LENGTH_LONG);
								toast.show();
							}
						});
					}
				} else {
					Log.i(TAG, ""skip Toast: amount="" + amount);
					Log.i(TAG, ""skip Toast: date+amount+gap="" + (// .
							date + amount * CallMeter.MILLIS + GAP_FOR_LOGS));
					Log.i(TAG, ""skip Toast: now            ="" + now);
				}
			}
			if (c != null && !c.isClosed()) {
				c.close();
			}
		}

		// schedule next update
		LogRunnerReceiver.schedNext(this);
		if (h != null) {
			h.sendEmptyMessage(Plans.MSG_BACKGROUND_STOP_MATCHER);
		}
		wakelock.release();
		Log.i(TAG, ""wakelock released"");
	}","@Override
	protected void onHandleIntent(final Intent intent) {
		if (intent == null) {
			Log.w(TAG, ""onHandleIntent(null)"");
			return;
		}
		final String a = intent.getAction();
		Log.d(TAG, ""onHandleIntent(action="" + a + "")"");

		final WakeLock wakelock = this.acquire(a);

		final Handler h = Plans.getHandler();
		if (h != null) {
			h.sendEmptyMessage(Plans.MSG_BACKGROUND_START_MATCHER);
		}

		final SharedPreferences p = PreferenceManager
				.getDefaultSharedPreferences(this);
		if (System.currentTimeMillis() - // .
				p.getLong(PREFS_LASTBACKUP, 0L) > BACKUP_PERIOD) {
			if (DataProvider.doBackup(this)) {
				p.edit().putLong(PREFS_LASTBACKUP, System.currentTimeMillis())
						.commit();
			}
		}
		dateStart = p.getLong(Preferences.PREFS_DATE_BEGIN,
				DatePreference.DEFAULT_VALUE);
		deleteBefore = Preferences.getDeleteLogsBefore(p);
		splitAt160 = p.getBoolean(Preferences.PREFS_SPLIT_SMS_AT_160, false);
		final boolean showCallInfo = p.getBoolean(
				Preferences.PREFS_SHOWCALLINFO, false);
		final boolean askForPlan = p.getBoolean(Preferences.PREFS_ASK_FOR_PLAN,
				false);
		final String deleimter = p
				.getString(Preferences.PREFS_DELIMITER, "" | "");

		final boolean runMatcher = a == ACTION_RUN_MATCHER;
		boolean shortRun = runMatcher
				|| a != null
				&& (a.equals(Intent.ACTION_BOOT_COMPLETED)
						|| a.equals(Intent.ACTION_SHUTDOWN) // .
						|| a.equals(Intent.ACTION_REBOOT) // .
				|| a.equals(Intent.ACTION_DATE_CHANGED));

		if (!shortRun && a != null
				&& a.equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
			if (intent.getBooleanExtra(ConnectivityManager.EXTRA_IS_FAILOVER,
					false)) {
				this.release(wakelock, h);
				return;
			}
			shortRun = true;
		}

		final ContentResolver cr = this.getContentResolver();
		boolean showDialog = false;
		if (!shortRun && h != null) {
			final Cursor c = cr.query(DataProvider.Logs.CONTENT_URI,
					new String[] { DataProvider.Logs.PLAN_ID },
					DataProvider.Logs.RULE_ID + "" != "" + DataProvider.NO_ID
							+ "" AND "" + DataProvider.Logs.TYPE + "" != ""
							+ DataProvider.TYPE_DATA, null, null);
			if (c.getCount() < UNMATHCEDLOGS_TO_SHOW_DIALOG) {
				showDialog = true;
				// skip if no plan is set up
				Cursor c1 = cr.query(DataProvider.Plans.CONTENT_URI,
						new String[] { DataProvider.Plans.ID }, null, null,
						null);
				if (c1.getCount() <= 0) {
					shortRun = true;
					showDialog = false;
				}
				c1.close();
				// skip if no rule is set up
				c1 = cr.query(DataProvider.Rules.CONTENT_URI,
						new String[] { DataProvider.Rules.ID }, null, null,
						null);
				if (c1.getCount() <= 0) {
					shortRun = true;
					showDialog = false;
				}
				c1.close();
				if (showDialog) {
					h.sendEmptyMessage(Plans.MSG_BACKGROUND_START_RUNNER);
				}
			}
			c.close();
		}

		updateData(this, shortRun && !runMatcher);
		if (!shortRun || runMatcher) {
			if (deleteBefore > 0L) {
				deleteOldLogs(cr);
			}
			updateCalls(cr);
			updateSMS(cr, DataProvider.DIRECTION_IN);
			updateSMS(cr, DataProvider.DIRECTION_OUT);
			updateMMS(this);
			if (RuleMatcher.match(this, showDialog)) {
				StatsAppWidgetProvider.updateWidgets(this);
			}
		} else if (roaming) {
			updateCalls(cr);
			updateSMS(cr, DataProvider.DIRECTION_IN);
			updateSMS(cr, DataProvider.DIRECTION_OUT);
			updateMMS(this);
		}

		if (showDialog) {
			h.sendEmptyMessage(Plans.MSG_BACKGROUND_STOP_RUNNER);
		}

		if ((showCallInfo || askForPlan) && a != null && a.equals(// .
				TelephonyManager.ACTION_PHONE_STATE_CHANGED)) {
			final Cursor c = cr.query(DataProvider.Logs.CONTENT_URI,
					DataProvider.Logs.PROJECTION, DataProvider.Logs.TYPE
							+ "" = "" + DataProvider.TYPE_CALL, null,
					DataProvider.Logs.DATE + "" DESC"");
			if (c != null && c.moveToFirst()) {
				final long id = c.getLong(DataProvider.Logs.INDEX_ID);
				final long date = c.getLong(DataProvider.Logs.INDEX_DATE);
				final long amount = c.getLong(DataProvider.Logs.INDEX_AMOUNT);

				final long now = System.currentTimeMillis();
				if (amount > 0L
						&& date + amount * CallMeter.MILLIS + GAP_FOR_LOGS // .
						>= now) {
					// only show real calls
					// only show calls made just now
					final float cost = c.getFloat(DataProvider.Logs.INDEX_COST);
					final String planname = DataProvider.Plans.getName(cr,
							c.getLong(DataProvider.Logs.INDEX_PLAN_ID));
					StringBuffer sb = new StringBuffer();
					sb.append(Common.prettySeconds(amount, false));
					if (cost > 0) {
						String currencyFormat = Preferences
								.getCurrencyFormat(this);
						sb.append(deleimter
								+ String.format(currencyFormat, cost));
					}
					if (planname != null) {
						sb.insert(0, planname + "": "");
					} else if (askForPlan) {
						this.handler.post(new Runnable() {
							@Override
							public void run() {
								Log.i(TAG, ""launching ask for plan dialog"");
								final Intent i = new Intent(
										LogRunnerService.this, // .
										AskForPlan.class);
								i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
								i.putExtra(AskForPlan.EXTRA_ID, id);
								i.putExtra(AskForPlan.EXTRA_DATE, date);
								i.putExtra(AskForPlan.EXTRA_AMOUNT, amount);
								LogRunnerService.this.startActivity(i);
							}
						});
					}
					if (showCallInfo) {
						final String s = sb.toString();
						Log.i(TAG, ""Toast: "" + s);
						this.handler.post(new Runnable() {
							@Override
							public void run() {
								final Toast toast = Toast.makeText(
										LogRunnerService.this, s,
										Toast.LENGTH_LONG);
								toast.show();
							}
						});
					}
				} else {
					Log.i(TAG, ""skip Toast: amount="" + amount);
					Log.i(TAG, ""skip Toast: date+amount+gap="" + (// .
							date + amount * CallMeter.MILLIS + GAP_FOR_LOGS));
					Log.i(TAG, ""skip Toast: now            ="" + now);
				}
			}
			if (c != null && !c.isClosed()) {
				c.close();
			}
		}

		this.release(wakelock, h);
	}",no,no,"No
Leaky Resources: None

The code snippet provided does not seem to have any resource leaks. All acquired resources such as WakeLock and Cursors are properly released or closed after use.","No
Leaky Resources: None

The code snippet does not appear to have any resource leaks. All acquired resources such as WakeLock and Cursors are properly released or closed after use."
ConnectBot,android.os.PowerManager.WakeLock,f5d392e3a3,76c4f80e47,onPause(),ConsoleActivity.java,,yes,n/a,n/a,n/a,,n/a,yes,yes,yes,yes,,,,,,yes,no,no,yes,yes,yes,leak on certain normal paths,,https://github.com/connectbot/connectbot,src/org/connectbot/ConsoleActivity.java,https://github.com/connectbot/connectbot/commit/f5d392e3a334d230fb782a1faff37bda8153750f,https://github.com/connectbot/connectbot/commit/76c4f80e47f21bffe4d467ea80de0284e1a9f156,"	@Override
	public void onPause() {
		super.onPause();
		Log.d(TAG, ""onPause called"");

		if (forcedOrientation && bound != null)
			bound.setResizeAllowed(false);
	}
","	@Override
	public void onPause() {
		super.onPause();
		Log.d(TAG, ""onPause called"");

		// Allow the screen to dim and fall asleep.
		if (wakelock != null && wakelock.isHeld())
			wakelock.release();

		if (forcedOrientation && bound != null)
			bound.setResizeAllowed(false);
	}
",no,no,"No
Leaky Resources:
None","No
Leaky Resources:
None"
Open-GPSTracker,android.os.PowerManager.,763b11eaf2,8ac7905a5a,updateWakeLock(),GPSLoggerService.java,,yes,n/a,n/a,n/a,,n/a,yes,no,no,yes,n/a,n/a,n/a,,n/a,yes,no,no,yes,,yes,complete leak,,https://github.com/rcgroot/open-gpstracker,application/src/nl/sogeti/android/gpstracker/logger/GPSLoggerService.java,https://github.com/rcgroot/open-gpstracker/commit/763b11eaf2bb6f7287866421fc4f567b23ee8f00,https://github.com/rcgroot/open-gpstracker/commit/8ac7905a5ac78520c63adb864eb0765eca08cc56,"   private void updateWakeLock()
   {
      if( this.mLoggingState == Constants.LOGGING )
      {
         PreferenceManager.getDefaultSharedPreferences( this ).registerOnSharedPreferenceChangeListener( mSharedPreferenceChangeListener );

         PowerManager pm = (PowerManager) this.getSystemService( Context.POWER_SERVICE );
         this.mWakeLock = pm.newWakeLock( PowerManager.PARTIAL_WAKE_LOCK, TAG );
         this.mWakeLock.acquire();
      }
      else
      {
         if( this.mWakeLock != null )
         {
            this.mWakeLock.release();
            this.mWakeLock = null;
         }
      }
   }
","   private void updateWakeLock()
   {
      if( this.mLoggingState == Constants.LOGGING )
      {
         PreferenceManager.getDefaultSharedPreferences( this ).registerOnSharedPreferenceChangeListener( mSharedPreferenceChangeListener );

         PowerManager pm = (PowerManager) this.getSystemService( Context.POWER_SERVICE );
         if( this.mWakeLock != null )
         {
            this.mWakeLock.release();
            this.mWakeLock = null;
         }
         this.mWakeLock = pm.newWakeLock( PowerManager.PARTIAL_WAKE_LOCK, TAG );
         this.mWakeLock.acquire();
      }
      else
      {
         if( this.mWakeLock != null )
         {
            this.mWakeLock.release();
            this.mWakeLock = null;
         }
      }
   }
",no,no,"Yes
Leaky Resources:
1. Shared Preferences Listener
2. Wake Lock

Explanation:
In the provided code snippet, there are two potential resource leaks.

1. Shared Preferences Listener: On line 5, a Shared Preference Change Listener is registered but it is never unregistered. This can lead to a memory leak if the listener is not unregistered when it's no longer needed.

2. Wake Lock: The Wake Lock is acquired on line 9 but it is only released if the logging state is not LOGGING. If the method updateWakeLock() is called again while the logging state is still LOGGING, a new Wake Lock is created and the old one is not released, which can lead to a battery drain.","No
Leaky Resources:
None"
CSipSimple,android.os.PowerManager.WakeLock,475ff206ee,eac20442bb,on_incoming_call(),UAStateReceiver.java,,yes,n/a,n/a,n/a,,n/a,yes,no,no,yes,n/a,n/a,n/a,,n/a,yes,no,no,no,,yes,leak on certain normal paths,,https://github.com/r3gis3r/CSipSimple,src/com/csipsimple/pjsip/UAStateReceiver.java,https://github.com/r3gis3r/CSipSimple/commit/475ff206ee9319c46ccfed0b5eca6820bf98db7f,https://github.com/r3gis3r/CSipSimple/commit/eac20442bbde3b03652cd958202baef34aee5d2e,"@Override
	public void on_incoming_call(final int acc_id, final int callId, SWIGTYPE_p_pjsip_rx_data rdata) {
		lockCpu();
		
		//Check if we have not already an ongoing call
		if(pjService != null && pjService.service != null && !pjService.service.supportMultipleCalls) {
			SipCallSession[] calls = getCalls();
			if(calls != null && calls.length > 0) {
				for( SipCallSession existingCall : calls) {
					if(!existingCall.isAfterEnded()) {
						Log.e(THIS_FILE, ""For now we do not support two call at the same time !!!"");
						//If there is an ongoing call and we do not support multiple calls
						//Send busy here
						pjsua.call_hangup(callId, 486, null, null);
						return;
					}
				}
			}
		}
		pjService.service.getExecutor().execute(pjService.service.new SipRunnable() {
			@Override
			public void doRun() throws SameThreadException {
				SipCallSession callInfo = updateCallInfoFromStack(callId);
				Log.d(THIS_FILE, ""Incoming call <<"");
				IncomingCallInfos iCInfo = new IncomingCallInfos();
				iCInfo.accId = acc_id;
				iCInfo.callInfo = callInfo;
				msgHandler.sendMessage(msgHandler.obtainMessage(ON_INCOMING_CALL, iCInfo));
				Log.d(THIS_FILE, ""Incoming call >>"");
			}
		});
		unlockCpu();
		
		
	}","@Override
	public void on_incoming_call(final int acc_id, final int callId, SWIGTYPE_p_pjsip_rx_data rdata) {
		lockCpu();
		
		//Check if we have not already an ongoing call
		if(pjService != null && pjService.service != null && !pjService.service.supportMultipleCalls) {
			SipCallSession[] calls = getCalls();
			if(calls != null && calls.length > 0) {
				for( SipCallSession existingCall : calls) {
					if(!existingCall.isAfterEnded()) {
						Log.e(THIS_FILE, ""Settings to not support two call at the same time !!!"");
						//If there is an ongoing call and we do not support multiple calls
						//Send busy here
						pjsua.call_hangup(callId, 486, null, null);
						unlockCpu();
						return;
					}
				}
			}
		}
		pjService.service.getExecutor().execute(pjService.service.new SipRunnable() {
			@Override
			public void doRun() throws SameThreadException {
				SipCallSession callInfo = updateCallInfoFromStack(callId);
				Log.d(THIS_FILE, ""Incoming call <<"");
				IncomingCallInfos iCInfo = new IncomingCallInfos();
				iCInfo.accId = acc_id;
				iCInfo.callInfo = callInfo;
				msgHandler.sendMessage(msgHandler.obtainMessage(ON_INCOMING_CALL, iCInfo));
				Log.d(THIS_FILE, ""Incoming call >>"");
			}
		});
		unlockCpu();
		
		
	}",no,no,"No
Leaky Resources:
None

The provided code snippet does not seem to have any resource leaks. All resources such as threads or database connections appear to be properly managed and closed where necessary. However, without the full context or the rest of the code, it's hard to say definitively.","No
Leaky Resources: None

The provided code snippet does not seem to have any resource leaks. It appears to be managing its resources properly. The lockCpu() and unlockCpu() methods are called in pairs, which suggests that the CPU lock is being released correctly. There are no database connections, file streams, or other resources that are opened without being closed."
CSipSimple,android.os.PowerManager.WakeLock,da248d1132,bf79346fcb,onChanged() @line 597,SipService.java,,yes,n/a,n/a,n/a,,n/a,yes,yes,no,yes,n/a,n/a,n/a,,n/a,yes,yes,no,yes,yes,yes,leak on certain normal paths,,https://github.com/r3gis3r/CSipSimple,src/com/csipsimple/service/SipService.java,https://github.com/r3gis3r/CSipSimple/commit/da248d11320db54727be9e6021aad249234ffa8d,https://github.com/r3gis3r/CSipSimple/commit/bf79346fcb96018771ece931f89e266ba06e7133,"protected void onChanged(String type, boolean connected) {
			synchronized (SipService.this) {
				// When turning on WIFI, it needs some time for network
				// connectivity to get stabile so we defer good news (because
				// we want to skip the interim ones) but deliver bad news
				// immediately
				if (connected) {
					if (mTask != null) {
						mTask.cancel();
					}
					mTask = new MyTimerTask(type, connected);
					if(mTimer == null) {
						mTimer = new Timer();
					}
					mTimer.schedule(mTask, 2 * 1000L);
					// hold wakup lock so that we can finish changes before the
					// device goes to sleep
					sipWakeLock.acquire(mTask);
				} else {
					if ((mTask != null) && mTask.mNetworkType.equals(type)) {
						mTask.cancel();
						sipWakeLock.release(mTask);
					}
					// onConnectivityChanged(type, false);
					dataConnectionChanged();
				}
			}
		}","protected void onChanged(String type, boolean connected) {
			synchronized (SipService.this) {
				// When turning on WIFI, it needs some time for network
				// connectivity to get stabile so we defer good news (because
				// we want to skip the interim ones) but deliver bad news
				// immediately
				if (connected) {
					if (mTask != null) {
						Log.d(THIS_FILE, ""We already have a current task in stack"");
						mTask.cancel();
						sipWakeLock.release(mTask);
					}
					mTask = new MyTimerTask(type, connected);
					if(mTimer == null) {
						mTimer = new Timer();
					}
					mTimer.schedule(mTask, 2 * 1000L);
					// hold wakup lock so that we can finish changes before the
					// device goes to sleep
					sipWakeLock.acquire(mTask);
				} else {
					if ((mTask != null) && mTask.mNetworkType.equals(type)) {
						mTask.cancel();
						sipWakeLock.release(mTask);
					}
					// onConnectivityChanged(type, false);
					dataConnectionChanged();
				}
			}
		}",no,no,"No
Leaky Resources:","No
Leaky Resources:
None

The provided code snippet does not seem to have any resource leaks. All resources such as TimerTask and WakeLock are properly managed and released when not needed."
CSipSimple,android.os.PowerManager.WakeLock,686620ba55,88d62bc951,realRun() @line 803,SipService.java,,yes,n/a,n/a,n/a,,n/a,no,no,yes,no,n/a,n/a,n/a,,n/a,no,no,yes,no,,yes,leak on certain normal paths,,https://github.com/r3gis3r/CSipSimple,src/com/csipsimple/service/SipService.java,https://github.com/r3gis3r/CSipSimple/commit/686620ba55f584c16388f4c1052a336ee6896bcb,https://github.com/r3gis3r/CSipSimple/commit/88d62bc9510809ab6d9750b0a0b761ef08c85948,"			private void realRun() {
				synchronized (createLock) {
					if (mTask != this) {
						Log.w(THIS_FILE, ""  unexpected task: "" + mNetworkType + (mConnected ? "" CONNECTED"" : ""DISCONNECTED""));
						return;
					}
					mTask = null;
					Log.d(THIS_FILE, "" deliver change for "" + mNetworkType + (mConnected ? "" CONNECTED"" : ""DISCONNECTED""));
					// onConnectivityChanged(mNetworkType, mConnected);
					dataConnectionChanged(mNetworkType, true);
					sipWakeLock.release(this);
				}
			}
","			private void realRun() {
				synchronized (createLock) {
					if (mTask != this) {
						Log.w(THIS_FILE, ""  unexpected task: "" + mNetworkType + (mConnected ? "" CONNECTED"" : ""DISCONNECTED""));
						sipWakeLock.release(this);
						return;
					}
					mTask = null;
					Log.d(THIS_FILE, "" deliver change for "" + mNetworkType + (mConnected ? "" CONNECTED"" : ""DISCONNECTED""));
					// onConnectivityChanged(mNetworkType, mConnected);
					dataConnectionChanged(mNetworkType, true);
					sipWakeLock.release(this);
				}
			}
",no,no,"No
Leaky Resources:
None","No
Leaky Resources:
None"
Xabber,android.view.MotionEvent,4cf5f2db9a,926f4ca93e,stopMovement(),ContactListFragment.java,,yes,n/a,no,n/a,,n/a,n/a,n/a,,,n/a,no,n/a,,n/a,n/a,n/a,,,,yes,complete leak,,https://github.com/redsolution/xabber-android,src/com/xabber/android/ui/ContactListFragment.java,https://github.com/redsolution/xabber-android/commit/4cf5f2db9a67189b8990899651f1618bd1b0fd1e,https://github.com/redsolution/xabber-android/commit/926f4ca93ecaebf2c614dd65a8aab39de8757218,"private void stopMovement() {
		listView.onTouchEvent(MotionEvent.obtain(SystemClock.uptimeMillis(),
				SystemClock.uptimeMillis(), MotionEvent.ACTION_CANCEL, 0, 0, 0));
	}","private void stopMovement() {
		MotionEvent event = MotionEvent.obtain(SystemClock.uptimeMillis(),
				SystemClock.uptimeMillis(), MotionEvent.ACTION_CANCEL, 0, 0, 0);
		listView.onTouchEvent(event);
		event.recycle();
	}",no,no,"No
Leaky Resources:
None","No
Leaky Resources:
None"
Quran for Android,java.io.BufferedOutputStream,4e4a60249a,121cd5803b,resumeDownload(),QuranDataService.java,,yes,yes,n/a,yes,,n/a,n/a,n/a,,,yes,n/a,no,,n/a,n/a,n/a,,,,no,complete leak,,https://github.com/quran/quran_android,src/com/quran/labs/androidquran/service/QuranDataService.java,https://github.com/quran/quran_android/commit/4e4a60249a27cbf834d59db4611eb9f1843240c0,https://github.com/quran/quran_android/commit/121cd5803b610eeb79bd42c78ece53df7043cc16,"private boolean resumeDownload() {
   BufferedInputStream in = null;
   FileOutputStream fos = null;
   BufferedOutputStream bout = null;

   try {
    for (; downloadIndex < fileNames.length; downloadIndex++) {
     int downloaded = 0; ;
     File f = new File(saveToDirectories[downloadIndex]);
     f.mkdirs();
     File file = new File(saveToDirectories[downloadIndex],
       fileNames[downloadIndex] + DOWNLOAD_EXT);
     URL url = new URL(downloadUrls[downloadIndex]);
     URLConnection conn = url.openConnection();
     int total = conn.getContentLength();
     Log.d(""quran_srv"", ""File to download: "" + file.getName()
       + "" - total length: "" + total);
     HttpURLConnection connection = (HttpURLConnection) url
       .openConnection();
     if (file.exists()) {
      downloaded = (int) file.length();
      connection.setRequestProperty(""Range"", ""bytes=""
        + (file.length()) + ""-"");
      Log.d(""quran_srv"", ""Resuming from "" + downloaded);
      if (downloaded == total)
       continue;
     }
     connection.setRequestProperty(""Range"", ""bytes=""
       + downloaded + ""-"");
     connection.setDoInput(true);
     in = new BufferedInputStream(connection.getInputStream());
     fos = (downloaded == 0) ? new FileOutputStream(file
       .getAbsolutePath()) : new FileOutputStream(file
       .getAbsolutePath(), true);
     bout = new BufferedOutputStream(fos, DOWNLOAD_BUFFER_SIZE);
     byte[] data = new byte[DOWNLOAD_BUFFER_SIZE];
     int x = 0;
     while (isRunning && (x = in.read(data, 0, DOWNLOAD_BUFFER_SIZE)) >= 0) {
      bout.write(data, 0, x);
      downloaded += x;
      double percent = 100.0 * ((1.0 * downloaded) / (1.0 * total));
      updateProgress((int) percent, fileNames.length, downloadIndex);
     }
     if (isRunning) {
      file.renameTo(new File(saveToDirectories[downloadIndex], fileNames[downloadIndex]));
 
      if (zipped || fileNames[downloadIndex].endsWith("".zip""))
       unzipFile(saveToDirectories[downloadIndex], fileNames[downloadIndex]);
 
      Log.d(""quran_srv"", ""Download Completed ["" + downloadUrls[downloadIndex] + ""]"");
     } else 
      return false;
    }
   } catch (FileNotFoundException e) {
    Log.e(""quran_srv"", ""File not found: IO Exception"", e);
   } catch (IOException e) {
    Log.e(""quran_srv"", ""Download paused: IO Exception"", e);
    return false;
   } catch (Exception e) {
    Log.e(""quran_srv"", ""Download paused: Exception"", e);
    return false;
   }
   return true;
  }","private boolean resumeDownload() {
   BufferedInputStream in = null;
   FileOutputStream fos = null;
   BufferedOutputStream bout = null;

   try {
    for (; downloadIndex < fileNames.length; downloadIndex++) {
     int downloaded = 0;
     File f = new File(saveToDirectories[downloadIndex]);
     f.mkdirs();
     File file = new File(saveToDirectories[downloadIndex],
       fileNames[downloadIndex] + DOWNLOAD_EXT);
     URL url = new URL(downloadUrls[downloadIndex]);
     URLConnection conn = url.openConnection();
     int total = conn.getContentLength();
     Log.d(""quran_srv"", ""File to download: "" + file.getName()
       + "" - total length: "" + total);
     HttpURLConnection connection = (HttpURLConnection) url
       .openConnection();
     if (file.exists()) {
      downloaded = (int) file.length();
      connection.setRequestProperty(""Range"", ""bytes=""
        + (file.length()) + ""-"");
      Log.d(""quran_srv"", ""Resuming from "" + downloaded);
      if (downloaded == total)
       continue;
     }
     connection.setRequestProperty(""Range"", ""bytes=""
       + downloaded + ""-"");
     connection.setDoInput(true);
     in = new BufferedInputStream(connection.getInputStream(), DOWNLOAD_BUFFER_SIZE);
     fos = (downloaded == 0) ? new FileOutputStream(file
       .getAbsolutePath()) : new FileOutputStream(file
       .getAbsolutePath(), true);
     bout = new BufferedOutputStream(fos, DOWNLOAD_BUFFER_SIZE);
     byte[] data = new byte[DOWNLOAD_BUFFER_SIZE];
     int x = 0;
     while (isRunning && (x = in.read(data, 0, DOWNLOAD_BUFFER_SIZE)) >= 0) {
      bout.write(data, 0, x);
      downloaded += x;
      double percent = 100.0 * ((1.0 * downloaded) / (1.0 * total));
      updateProgress((int) percent, fileNames.length, downloadIndex);
     }
     bout.flush();
     bout.close();
     fos.close();

     if (isRunning) {
      file.renameTo(new File(saveToDirectories[downloadIndex], fileNames[downloadIndex]));
 
      if (zipped || fileNames[downloadIndex].endsWith("".zip""))
       unzipFile(saveToDirectories[downloadIndex], fileNames[downloadIndex]);
 
      Log.d(""quran_srv"", ""Download Completed ["" + downloadUrls[downloadIndex] + ""]"");
     } else 
      return false;
    }
   } catch (FileNotFoundException e) {
    Log.e(""quran_srv"", ""File not found: IO Exception"", e);
   } catch (IOException e) {
    Log.e(""quran_srv"", ""Download paused: IO Exception"", e);
    return false;
   } catch (Exception e) {
    Log.e(""quran_srv"", ""Download paused: Exception"", e);
    return false;
   }
   return true;
  }",no,no,"Yes
Leaky Resources:
BufferedInputStream (in)
FileOutputStream (fos)
BufferedOutputStream (bout)

Explanation:
The resources 'in', 'fos', and 'bout' are opened within the try block but are not closed in a finally block. This can lead to resource leaks if an exception is thrown before the resources are closed. It's a good practice to close such resources in a finally block or use try-with-resources statement to ensure they are closed automatically.","Yes
Leaky Resources:
BufferedInputStream, FileOutputStream, BufferedOutputStream

Explanation:
The resources BufferedInputStream (in), FileOutputStream (fos), and BufferedOutputStream (bout) are opened within the try block but are only closed within the same block. If an exception occurs before reaching the lines where these resources are closed (lines 45 and 46), these resources will remain open, causing a resource leak. 

To fix this, these resources should be closed in a finally block to ensure they are closed regardless of whether an exception occurs."
CycleStreets,java.io.FileInputStream,68598b254d,1c9a3064f4,fetch() @line 79,ApiCallCache.java,Pull 72,yes,yes,n/a,yes,,yes,n/a,n/a,,,yes,n/a,no,,yes,n/a,n/a,,,,no,complete leak,,https://github.com/cyclestreets/android,src/net/cyclestreets/api/ApiCallCache.java,https://github.com/cyclestreets/android/commit/68598b254dcfd89c03316bc41d58fc422157d912,https://github.com/cyclestreets/android/commit/1c9a3064f423d7be6b31f21b9d09bf85bb4bec7a,"byte[] fetch(final String name, int maxAgeInDays)
  {
    if(!isAvailable())
      return null;
    
    final File file = dataFileName(name);
    if(!file.exists())
      return null;
    
    if(expired(file, maxAgeInDays))
      return null;
    
    final ByteArrayOutputStream output = new ByteArrayOutputStream();
    try 
    {
      final FileInputStream fis = new FileInputStream(file);
      byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
    
      int n = 0;
      while ((n = fis.read(buffer)) != -1)
        output.write(buffer, 0, n);            

    } // try
    catch(IOException e)
    {
      return null;
    } // catch
    
    return output.toByteArray();    
  } // fetch","byte[] fetch(final String name, int maxAgeInDays)
  {
    if(!isAvailable())
      return null;
    
    final File file = dataFileName(name);
    if(!file.exists())
      return null;
    
    if(expired(file, maxAgeInDays))
      return null;
    
    final ByteArrayOutputStream output = new ByteArrayOutputStream();
    try 
    {
      final FileInputStream fis = new FileInputStream(file);
      byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
    
      int n = 0;
      while ((n = fis.read(buffer)) != -1)
        output.write(buffer, 0, n);            
      fis.close();
    } // try
    catch(IOException e)
    {
      return null;
    } // catch
    
    return output.toByteArray();    
  } // fetch",no,no,"Yes
Leaky Resources:
FileInputStream

Explanation: The FileInputStream 'fis' is opened at line 16 but it is never closed. This can lead to a resource leak as the file handle remains open. It should be closed in a finally block or use try-with-resources to ensure it gets closed even if an exception is thrown.","Yes
Leaky Resources:
FileInputStream

Explanation:
In the provided code snippet, the FileInputStream (fis) is opened at line 16 but it is only closed at line 22. If an exception occurs between these lines (16-22), the fis.close() at line 22 will not be executed, causing a resource leak. The FileInputStream should be closed in a finally block or use try-with-resources to ensure it is closed even if an exception occurs."
Quran for Android,java.io.FileOutputStream,4e4a60249a,121cd5803b,resumeDownload(),QuranDataService.java,,yes,yes,n/a,no,,no,n/a,n/a,,,yes,n/a,no,,no,n/a,n/a,,,,no,complete leak,,https://github.com/quran/quran_android,src/com/quran/labs/androidquran/service/QuranDataService.java,https://github.com/quran/quran_android/commit/4e4a60249a27cbf834d59db4611eb9f1843240c0,https://github.com/quran/quran_android/commit/121cd5803b610eeb79bd42c78ece53df7043cc16,"private boolean resumeDownload() {
   BufferedInputStream in = null;
   FileOutputStream fos = null;
   BufferedOutputStream bout = null;

   try {
    for (; downloadIndex < fileNames.length; downloadIndex++) {
     int downloaded = 0; ;
     File f = new File(saveToDirectories[downloadIndex]);
     f.mkdirs();
     File file = new File(saveToDirectories[downloadIndex],
       fileNames[downloadIndex] + DOWNLOAD_EXT);
     URL url = new URL(downloadUrls[downloadIndex]);
     URLConnection conn = url.openConnection();
     int total = conn.getContentLength();
     Log.d(""quran_srv"", ""File to download: "" + file.getName()
       + "" - total length: "" + total);
     HttpURLConnection connection = (HttpURLConnection) url
       .openConnection();
     if (file.exists()) {
      downloaded = (int) file.length();
      connection.setRequestProperty(""Range"", ""bytes=""
        + (file.length()) + ""-"");
      Log.d(""quran_srv"", ""Resuming from "" + downloaded);
      if (downloaded == total)
       continue;
     }
     connection.setRequestProperty(""Range"", ""bytes=""
       + downloaded + ""-"");
     connection.setDoInput(true);
     in = new BufferedInputStream(connection.getInputStream());
  
     fos = (downloaded == 0) ? new FileOutputStream(file
       .getAbsolutePath()) : new FileOutputStream(file
       .getAbsolutePath(), true);
     bout = new BufferedOutputStream(fos, DOWNLOAD_BUFFER_SIZE);
     byte[] data = new byte[DOWNLOAD_BUFFER_SIZE];
     int x = 0;
     while (isRunning && (x = in.read(data, 0, DOWNLOAD_BUFFER_SIZE)) >= 0) {
      bout.write(data, 0, x);
      downloaded += x;
      double percent = 100.0 * ((1.0 * downloaded) / (1.0 * total));
      updateProgress((int) percent, fileNames.length, downloadIndex);
     }
 

     if (isRunning) {
      file.renameTo(new File(saveToDirectories[downloadIndex], fileNames[downloadIndex]));
 
      if (zipped || fileNames[downloadIndex].endsWith("".zip""))
       unzipFile(saveToDirectories[downloadIndex], fileNames[downloadIndex]);
 
      Log.d(""quran_srv"", ""Download Completed ["" + downloadUrls[downloadIndex] + ""]"");
     } else 
      return false;
    }
   } catch (FileNotFoundException e) {
    Log.e(""quran_srv"", ""File not found: IO Exception"", e);
   } catch (IOException e) {
    Log.e(""quran_srv"", ""Download paused: IO Exception"", e);
    return false;
   } catch (Exception e) {
    Log.e(""quran_srv"", ""Download paused: Exception"", e);
    return false;
   }
   return true;
  }","private boolean resumeDownload() {
   BufferedInputStream in = null;
   FileOutputStream fos = null;
   BufferedOutputStream bout = null;

   try {
    for (; downloadIndex < fileNames.length; downloadIndex++) {
     int downloaded = 0;
     File f = new File(saveToDirectories[downloadIndex]);
     f.mkdirs();
     File file = new File(saveToDirectories[downloadIndex],
       fileNames[downloadIndex] + DOWNLOAD_EXT);
     URL url = new URL(downloadUrls[downloadIndex]);
     URLConnection conn = url.openConnection();
     int total = conn.getContentLength();
     Log.d(""quran_srv"", ""File to download: "" + file.getName()
       + "" - total length: "" + total);
     HttpURLConnection connection = (HttpURLConnection) url
       .openConnection();
     if (file.exists()) {
      downloaded = (int) file.length();
      connection.setRequestProperty(""Range"", ""bytes=""
        + (file.length()) + ""-"");
      Log.d(""quran_srv"", ""Resuming from "" + downloaded);
      if (downloaded == total)
       continue;
     }
     connection.setRequestProperty(""Range"", ""bytes=""
       + downloaded + ""-"");
     connection.setDoInput(true);

     in = new BufferedInputStream(connection.getInputStream(), DOWNLOAD_BUFFER_SIZE);
     fos = (downloaded == 0) ? new FileOutputStream(file
       .getAbsolutePath()) : new FileOutputStream(file
       .getAbsolutePath(), true);
     bout = new BufferedOutputStream(fos, DOWNLOAD_BUFFER_SIZE);
     byte[] data = new byte[DOWNLOAD_BUFFER_SIZE];
     int x = 0;
     while (isRunning && (x = in.read(data, 0, DOWNLOAD_BUFFER_SIZE)) >= 0) {
      bout.write(data, 0, x);
      downloaded += x;
      double percent = 100.0 * ((1.0 * downloaded) / (1.0 * total));
      updateProgress((int) percent, fileNames.length, downloadIndex);
     }
     bout.flush();
     bout.close();
     fos.close();

     if (isRunning) {
      file.renameTo(new File(saveToDirectories[downloadIndex], fileNames[downloadIndex]));
 
      if (zipped || fileNames[downloadIndex].endsWith("".zip""))
       unzipFile(saveToDirectories[downloadIndex], fileNames[downloadIndex]);
 
      Log.d(""quran_srv"", ""Download Completed ["" + downloadUrls[downloadIndex] + ""]"");
     } else 
      return false;
    }
   } catch (FileNotFoundException e) {
    Log.e(""quran_srv"", ""File not found: IO Exception"", e);
   } catch (IOException e) {
    Log.e(""quran_srv"", ""Download paused: IO Exception"", e);
    return false;
   } catch (Exception e) {
    Log.e(""quran_srv"", ""Download paused: Exception"", e);
    return false;
   }
   return true;
  }",no,no,"Yes
Leaky Resources:
BufferedInputStream (in)
FileOutputStream (fos)
BufferedOutputStream (bout)

The resources 'in', 'fos', and 'bout' are opened but not properly closed in a finally block. This can lead to resource leaks if an exception is thrown before the resources are closed.","Yes
Leaky Resources:
BufferedInputStream, FileOutputStream, BufferedOutputStream

Explanation:
The resources BufferedInputStream (in), FileOutputStream (fos), and BufferedOutputStream (bout) are opened within the try block but are only closed within the same block. If an exception occurs after these resources are opened but before they are closed, the catch blocks will be executed and the method will return without closing these resources, leading to a resource leak. 

To fix this, these resources should be closed in a finally block or use try-with-resources statement which ensures that each resource is closed at the end of the statement."
ChatSecure,java.io.OtrInputStream,6ae9dfca45,ba1ae18409,unserialize() @line 164,SM.java,Pull 591,yes,yes,n/a,no,,yes,n/a,n/a,,,yes,n/a,no,,yes,n/a,n/a,,,,no,leak in erroneous conditions,,https://github.com/guardianproject/ChatSecureAndroid,src/net/java/otr4j/crypto/SM.java,https://github.com/guardianproject/ChatSecureAndroid/commit/6ae9dfca4504793dc7c9db972e1a8bb4dd52ee19,https://github.com/guardianproject/ChatSecureAndroid/commit/ba1ae1840930282bd2bb0353f184981e1ef26046,"public static BigInteger[] unserialize(byte[] bytes) throws SMException {
        try {
            ByteArrayInputStream in = new ByteArrayInputStream(bytes);
            OtrInputStream ois = new OtrInputStream(in);
            int len = ois.readInt();
            if (len > 100);
          
            BigInteger[] ints = new BigInteger[len];
            for (int i = 0; i < len; i++) {
                ints[i] = ois.readBigInt();
            }
            ois.close();
            return ints;
        } catch (IOException ex) {
            throw new SMException(""cannot unserialize bigints"");
        }
    }","public static BigInteger[] unserialize(byte[] bytes) throws SMException {
        try {
            ByteArrayInputStream in = new ByteArrayInputStream(bytes);
            OtrInputStream ois = new OtrInputStream(in);
            int len = ois.readInt();
            if (len > 100) {
                ois.close();
                throw new SMException(""Too many ints"");
            }
            BigInteger[] ints = new BigInteger[len];
            for (int i = 0; i < len; i++) {
                ints[i] = ois.readBigInt();
            }
            ois.close();
            return ints;
        } catch (IOException ex) {
            throw new SMException(""cannot unserialize bigints"");
        }
    }",no,no,"Yes
Leaky Resources:
InputStreams

Explanation:
In the provided code snippet, the InputStreams 'in' and 'ois' are opened but not properly closed in a finally block. If an exception is thrown before line 12, the 'ois' stream will not be closed, leading to a resource leak. It's a good practice to close such resources in a finally block or use a try-with-resources statement to ensure they are closed properly under all circumstances.","Yes
Leaky Resources:
OtrInputStream

Explanation:
The OtrInputStream is not closed in the catch block. If an IOException occurs before line 14, the OtrInputStream will not be closed, leading to a resource leak. It's recommended to use a finally block or try-with-resources statement to ensure that resources are always closed."
ChatSecure,java.io.OtrInputStream,6ae9dfca45,ba1ae18409,testIOShort() @line 53,IOTest.java,Pull 591,yes,yes,n/a,no,,yes,n/a,n/a,,,yes,n/a,no,,yes,n/a,n/a,,,,no,complete leak,,https://github.com/guardianproject/ChatSecureAndroid,src/net/java/otr4j/test/io/IOTest.java,https://github.com/guardianproject/ChatSecureAndroid/commit/6ae9dfca4504793dc7c9db972e1a8bb4dd52ee19,https://github.com/guardianproject/ChatSecureAndroid/commit/ba1ae1840930282bd2bb0353f184981e1ef26046,"public void testIOShort() throws Exception {
        int source = 10;
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeShort(source);


        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        int result = ois.readShort();


        assertEquals(source, result);
    }","public void testIOShort() throws Exception {
        int source = 10;

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeShort(source);
        oos.close();

        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        int result = ois.readShort();
        ois.close();

        assertEquals(source, result);
    }",no,no,"No
Leaky Resources:
None","No
Leaky Resources:
None"
ChatSecure,java.io.OtrInputStream,6ae9dfca45,ba1ae18409,testIOData() @line 69,IOTest.java,Pull 591,yes,yes,n/a,no,,yes,n/a,n/a,,,yes,n/a,no,,yes,n/a,n/a,,,,no,complete leak,,https://github.com/guardianproject/ChatSecureAndroid,src/net/java/otr4j/test/io/IOTest.java,https://github.com/guardianproject/ChatSecureAndroid/commit/6ae9dfca4504793dc7c9db972e1a8bb4dd52ee19,https://github.com/guardianproject/ChatSecureAndroid/commit/ba1ae1840930282bd2bb0353f184981e1ef26046,"public void testIOData() throws Exception {
        byte[] source = new byte[] { 1, 1, 1, 1 };
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeData(source);


        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        byte[] result = ois.readData();


        assertTrue(java.util.Arrays.equals(source, result));
    }","public void testIOData() throws Exception {
        byte[] source = new byte[] { 1, 1, 1, 1 };

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeData(source);
        oos.close();

        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        byte[] result = ois.readData();
        ois.close();

        assertTrue(java.util.Arrays.equals(source, result));
    }",no,no,"No
Leaky Resources:
None

Explanation: The code does not seem to have any resource leaks. Both `ByteArrayOutputStream` and `ByteArrayInputStream` do not need to be explicitly closed. They will be garbage collected when there are no more references to them. The `OtrOutputStream` and `OtrInputStream` are not standard Java classes, so without more information about them, it's impossible to say for sure, but if they are just wrappers around the byte array streams, they probably don't need to be closed either.","No
Leaky Resources:
None

Explanation: The code snippet does not have any resource leaks. Both the OtrOutputStream and OtrInputStream are properly closed after use on lines 7 and 14 respectively."
ChatSecure,java.io.OtrInputStream,6ae9dfca45,ba1ae18409,testIOBigInt() @line 87,IOTest.java,Pull 591,yes,yes,n/a,no,,yes,n/a,n/a,,,yes,n/a,no,,yes,n/a,n/a,,,,no,complete leak,,https://github.com/guardianproject/ChatSecureAndroid,src/net/java/otr4j/test/io/IOTest.java,https://github.com/guardianproject/ChatSecureAndroid/commit/6ae9dfca4504793dc7c9db972e1a8bb4dd52ee19,https://github.com/guardianproject/ChatSecureAndroid/commit/ba1ae1840930282bd2bb0353f184981e1ef26046,"public void testIOBigInt() throws Exception {
        KeyPair pair = new OtrCryptoEngineImpl().generateDHKeyPair();
        BigInteger source = ((DHPublicKey) pair.getPublic()).getY();
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeBigInt(source);


        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        BigInteger result = ois.readBigInt();


        assertTrue(source.compareTo(result) == 0);
    }","public void testIOBigInt() throws Exception {

        KeyPair pair = new OtrCryptoEngineImpl().generateDHKeyPair();
        BigInteger source = ((DHPublicKey) pair.getPublic()).getY();

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeBigInt(source);
        oos.close();

        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        BigInteger result = ois.readBigInt();
        ois.close();

        assertTrue(source.compareTo(result) == 0);
    }",no,no,"Yes
Leaky Resources:
- ByteArrayOutputStream
- OtrOutputStream
- ByteArrayInputStream
- OtrInputStream","No
Leaky Resources:
None"
ChatSecure,java.io.OtrInputStream,6ae9dfca45,ba1ae18409,testIODHPublicKey() @line 105,IOTest.java,Pull 591,yes,yes,n/a,no,,yes,n/a,n/a,,,yes,n/a,no,,yes,n/a,n/a,,,,no,complete leak,,https://github.com/guardianproject/ChatSecureAndroid,src/net/java/otr4j/test/io/IOTest.java,https://github.com/guardianproject/ChatSecureAndroid/commit/6ae9dfca4504793dc7c9db972e1a8bb4dd52ee19,https://github.com/guardianproject/ChatSecureAndroid/commit/ba1ae1840930282bd2bb0353f184981e1ef26046,"public void testIODHPublicKey() throws Exception {
        KeyPair pair = new OtrCryptoEngineImpl().generateDHKeyPair();
        DHPublicKey source = (DHPublicKey) pair.getPublic();
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeDHPublicKey(source);


        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        DHPublicKey result = ois.readDHPublicKey();


        assertTrue(source.getY().compareTo(result.getY()) == 0);
    }","public void testIODHPublicKey() throws Exception {
        KeyPair pair = new OtrCryptoEngineImpl().generateDHKeyPair();

        DHPublicKey source = (DHPublicKey) pair.getPublic();

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeDHPublicKey(source);
        oos.close();

        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        DHPublicKey result = ois.readDHPublicKey();
        ois.close();

        assertTrue(source.getY().compareTo(result.getY()) == 0);
    }",no,no,"No
Leaky Resources:
None","No
Leaky Resources:
None"
ChatSecure,java.io.OtrOutputStream,6ae9dfca45,ba1ae18409,toByteArray() @line 72,SerializationUtils.java,Pull 591,yes,yes,n/a,no,,yes,n/a,n/a,,,yes,n/a,no,,yes,n/a,n/a,,,,no,complete leak,,https://github.com/guardianproject/ChatSecureAndroid,src/net/java/otr4j/io/SerializationUtils.java,https://github.com/guardianproject/ChatSecureAndroid/commit/6ae9dfca4504793dc7c9db972e1a8bb4dd52ee19,https://github.com/guardianproject/ChatSecureAndroid/commit/ba1ae1840930282bd2bb0353f184981e1ef26046,"    public static byte[] toByteArray(MysteriousT t) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeMysteriousT(t);
        byte[] b = out.toByteArray();
        out.close();

        return b;
    }","    public static byte[] toByteArray(SignatureX x) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeMysteriousX(x);
        byte[] b = out.toByteArray();
        oos.close();
        return b;
    }
",no,no,"No
Leaky Resources:
None","No
Leaky Resources:
None"
ChatSecure,java.io.OtrOutputStream,6ae9dfca45,ba1ae18409,writeData() @line 82,SerializationUtils.java,Pull 591,yes,yes,n/a,no,,yes,n/a,n/a,,,yes,n/a,no,,yes,n/a,n/a,,,,no,complete leak,,https://github.com/guardianproject/ChatSecureAndroid,src/net/java/otr4j/io/SerializationUtils.java,https://github.com/guardianproject/ChatSecureAndroid/commit/6ae9dfca4504793dc7c9db972e1a8bb4dd52ee19,https://github.com/guardianproject/ChatSecureAndroid/commit/ba1ae1840930282bd2bb0353f184981e1ef26046," public static byte[] writeData(byte[] b) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeData(b);
        byte[] otrb = out.toByteArray();
        out.close();
        return otrb;
    }","    public static byte[] writeData(byte[] b) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeData(b);
        byte[] otrb = out.toByteArray();
        out.close();
        oos.close();
        return otrb;
    }
",no,no,"No
Leaky Resources:
None

The code snippet does not have any resource leaks. Both the ByteArrayOutputStream and OtrOutputStream are closed properly.","No
Leaky Resources:
None"
ChatSecure,java.io.OtrOutputStream,6ae9dfca45,ba1ae18409,testIOShort() @line 47,IOTest.java,Pull 591,yes,yes,n/a,no,,yes,n/a,n/a,,,yes,n/a,no,,yes,n/a,n/a,,,,no,complete leak,,https://github.com/guardianproject/ChatSecureAndroid,src/net/java/otr4j/test/io/IOTest.java,https://github.com/guardianproject/ChatSecureAndroid/commit/6ae9dfca4504793dc7c9db972e1a8bb4dd52ee19,https://github.com/guardianproject/ChatSecureAndroid/commit/ba1ae1840930282bd2bb0353f184981e1ef26046,"public void testIOShort() throws Exception {
        int source = 10;
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeShort(source);


        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        int result = ois.readShort();


        assertEquals(source, result);
    }","public void testIOShort() throws Exception {
        int source = 10;

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeShort(source);
        oos.close();

        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        int result = ois.readShort();
        ois.close();

        assertEquals(source, result);
    }",no,no,"Yes
Leaky Resources:
OtrOutputStream, OtrInputStream

Explanation: The OtrOutputStream and OtrInputStream are not closed after use. This can lead to resource leaks as the system resources allocated to these streams are not released. It's a good practice to close streams in a finally block or use a try-with-resources statement to ensure they are closed even if exceptions occur.","No
Leaky Resources: None

The code snippet provided does not have any resource leaks. Both the OtrOutputStream and OtrInputStream are properly closed after use, which prevents memory leaks."
ChatSecure,java.io.OtrOutputStream,6ae9dfca45,ba1ae18409,testIOData() @line 63,IOTest.java,Pull 591,yes,yes,n/a,no,,yes,n/a,n/a,,,yes,n/a,no,,yes,n/a,n/a,,,,no,complete leak,,https://github.com/guardianproject/ChatSecureAndroid,src/net/java/otr4j/test/io/IOTest.java,https://github.com/guardianproject/ChatSecureAndroid/commit/6ae9dfca4504793dc7c9db972e1a8bb4dd52ee19,https://github.com/guardianproject/ChatSecureAndroid/commit/ba1ae1840930282bd2bb0353f184981e1ef26046,"public void testIOData() throws Exception {
        byte[] source = new byte[] { 1, 1, 1, 1 };
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeData(source);


        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        byte[] result = ois.readData();


        assertTrue(java.util.Arrays.equals(source, result));
    }","public void testIOData() throws Exception {
        byte[] source = new byte[] { 1, 1, 1, 1 };

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeData(source);
        oos.close();

        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        byte[] result = ois.readData();
        ois.close();

        assertTrue(java.util.Arrays.equals(source, result));
    }",no,no,"No
Leaky Resources:
None

Explanation: The code provided does not seem to have any resource leaks. Both the ByteArrayOutputStream and ByteArrayInputStream do not need to be explicitly closed. The OtrOutputStream and OtrInputStream are not standard Java classes, so without additional information about these classes, it's impossible to definitively say whether they need to be closed or not. However, if they are similar to ObjectOutputStream and ObjectInputStream, they would need to be closed to prevent potential resource leaks. But in this code snippet, there is no evidence of resource leaks.","No
Leaky Resources:
None

Explanation: The code snippet does not have any resource leaks. Both the OtrOutputStream and OtrInputStream are properly closed after use, which is the correct way to handle these resources. The ByteArrayOutputStream and ByteArrayInputStream do not need to be closed because they do not hold any system resources. They are just byte arrays in memory and will be garbage collected when they are no longer referenced."
ChatSecure,java.io.OtrOutputStream,6ae9dfca45,ba1ae18409,testIOBigInt() @line 81,IOTest.java,Pull 591,yes,yes,n/a,no,,yes,n/a,n/a,,,yes,n/a,no,,yes,n/a,n/a,,,,no,complete leak,,https://github.com/guardianproject/ChatSecureAndroid,src/net/java/otr4j/test/io/IOTest.java,https://github.com/guardianproject/ChatSecureAndroid/commit/6ae9dfca4504793dc7c9db972e1a8bb4dd52ee19,https://github.com/guardianproject/ChatSecureAndroid/commit/ba1ae1840930282bd2bb0353f184981e1ef26046,"public void testIOBigInt() throws Exception {
        KeyPair pair = new OtrCryptoEngineImpl().generateDHKeyPair();
        BigInteger source = ((DHPublicKey) pair.getPublic()).getY();
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeBigInt(source);


        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        BigInteger result = ois.readBigInt();

        assertTrue(source.compareTo(result) == 0);
    }","public void testIOBigInt() throws Exception {

        KeyPair pair = new OtrCryptoEngineImpl().generateDHKeyPair();
        BigInteger source = ((DHPublicKey) pair.getPublic()).getY();

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeBigInt(source);
        oos.close();

        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        BigInteger result = ois.readBigInt();
        ois.close();

        assertTrue(source.compareTo(result) == 0);
    }",no,no,"Yes
Leaky Resources:
1. ByteArrayOutputStream
2. OtrOutputStream
3. ByteArrayInputStream
4. OtrInputStream

The streams are opened but never closed, which can lead to resource leaks.","No
Leaky Resources:
None"
ChatSecure,java.io.OtrOutputStream,6ae9dfca45,ba1ae18409,testIODHPublicKey() @line 99,IOTest.java,Pull 591,yes,yes,n/a,no,,yes,n/a,n/a,,,yes,n/a,no,,yes,n/a,n/a,,,,no,complete leak,,https://github.com/guardianproject/ChatSecureAndroid,src/net/java/otr4j/test/io/IOTest.java,https://github.com/guardianproject/ChatSecureAndroid/commit/6ae9dfca4504793dc7c9db972e1a8bb4dd52ee19,https://github.com/guardianproject/ChatSecureAndroid/commit/ba1ae1840930282bd2bb0353f184981e1ef26046,"public void testIODHPublicKey() throws Exception {
        KeyPair pair = new OtrCryptoEngineImpl().generateDHKeyPair();
        DHPublicKey source = (DHPublicKey) pair.getPublic();
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeDHPublicKey(source);

        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        DHPublicKey result = ois.readDHPublicKey();

        assertTrue(source.getY().compareTo(result.getY()) == 0);
    }","public void testIODHPublicKey() throws Exception {
        KeyPair pair = new OtrCryptoEngineImpl().generateDHKeyPair();

        DHPublicKey source = (DHPublicKey) pair.getPublic();

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        OtrOutputStream oos = new OtrOutputStream(out);
        oos.writeDHPublicKey(source);
        oos.close();

        byte[] converted = out.toByteArray();

        ByteArrayInputStream bin = new ByteArrayInputStream(converted);
        OtrInputStream ois = new OtrInputStream(bin);
        DHPublicKey result = ois.readDHPublicKey();
        ois.close();

        assertTrue(source.getY().compareTo(result.getY()) == 0);
    }",no,no,"No
Leaky Resources:
None","No
Leaky Resources:
None"
K-9 Mail,java.io.InputStream,7e1501499f,acd18291f2,CheckOutgoing(),AccountSetupCheckSettings.java,Pull 1199,yes,no,n/a,no,,no,n/a,n/a,,,no,n/a,no,,no,n/a,n/a,,,,no,leak on exceptional paths ,,https://github.com/k9mail/k-9,k9mail/src/main/java/com/fsck/k9/activity/setup/AccountSetupCheckSettings.java,https://github.com/k9mail/k-9/commit/7e1501499f5425dc955fee650f0bbb907b957b02,https://github.com/k9mail/k-9/commit/acd18291f2ded8f176beb074415f8c42ca829966,"private void checkOutgoing() throws MessagingException {
            if (!(account.getRemoteStore() instanceof WebDavStore)) {
                publishProgress(R.string.account_setup_check_settings_check_outgoing_msg);
            }
            Transport transport = Transport.getInstance(K9.app, account);
            transport.close();
            transport.open();
            transport.close();
           
        }","private void checkOutgoing() throws MessagingException {
            if (!(account.getRemoteStore() instanceof WebDavStore)) {
                publishProgress(R.string.account_setup_check_settings_check_outgoing_msg);
            }
            Transport transport = Transport.getInstance(K9.app, account);
            transport.close();
          
            try {
                transport.open();
            } finally {
                transport.close();
            }
        }",no,no,"Yes
Leaky Resources:
Transport Instance","No
Leaky Resources:
None"
K-9 Mail,java.io.InputStream,2df436e7bc,1596ddfaab,getPreviewIcon(),AttachmentView.java,,yes,no,n/a,no,,no,n/a,n/a,,,no,n/a,no,,no,n/a,n/a,,,,yes,complete leak,,https://github.com/k9mail/k-9,src/com/fsck/k9/view/AttachmentView.java,https://github.com/k9mail/k-9/commit/2df436e7bcff44e0a22efef52cea32248902c359,https://github.com/k9mail/k-9/commit/1596ddfaaba40ba751aa4170d813a7ea3841a6e2,"private Bitmap getPreviewIcon() {
        try {
            return BitmapFactory.decodeStream(
                       mContext.getContentResolver().openInputStream(
                           AttachmentProvider.getAttachmentThumbnailUri(mAccount,
                                   part.getAttachmentId(),
                                   62,
                                   62)));
        } catch (Exception e) {
            /*
             * We don't care what happened, we just return null for the preview icon.
             */
            return null;
        }
    }","private Bitmap getPreviewIcon() {
        Bitmap icon = null;
        try {
            InputStream input = mContext.getContentResolver().openInputStream(
                           AttachmentProvider.getAttachmentThumbnailUri(mAccount,
                                   part.getAttachmentId(),
                                   62,
                                   62));
            icon = BitmapFactory.decodeStream(input);
            input.close();
        } catch (Exception e) {
            /*
             * We don't care what happened, we just return null for the preview icon.
             */
        }
        return icon;
    }",no,no,"Yes
Leaky Resources:
InputStream","Yes
Leaky Resources:
InputStream

Explanation: The InputStream 'input' is opened at line 4 but it is only closed at line 10. If an exception is thrown before line 10, the 'input' stream will not be closed, causing a resource leak. The 'input.close()' should be placed in a finally block to ensure it is always executed regardless of whether an exception is thrown or not."
K-9 Mail,java.io.InputStream,0e03f262b3,378acbd313,getAttachmentInputStream(),LocalStore.java,,yes,no,n/a,no,,no,n/a,n/a,,,no,n/a,no,,no,n/a,n/a,,,,yes,complete leak,,https://github.com/k9mail/k-9,k9mail/src/main/java/com/fsck/k9/mailstore/LocalStore.java,https://github.com/k9mail/k-9/commit/0e03f262b3bb8c1d09d56f6b16fd1e4309356dd0,https://github.com/k9mail/k-9/commit/378acbd313ace01f89ea460a04c957c2c5267e60,"public InputStream getAttachmentInputStream(final String attachmentId) throws MessagingException {
        return database.execute(false, new DbCallback<InputStream>() {
            @Override
            public InputStream doDbWork(final SQLiteDatabase db) throws WrappedException {
                Cursor cursor = db.query(""message_parts"",
                        new String[] { ""data_location"", ""data"", ""encoding"" },
                        ""id = ?"",
                        new String[] { attachmentId },
                        null, null, null);
                try {
                    if (!cursor.moveToFirst()) {
                        return null;
                    }

                    int location = cursor.getInt(0);
                    String encoding = cursor.getString(2);

                    InputStream rawInputStream = getRawAttachmentInputStream(cursor, location, attachmentId);
                    return getDecodingInputStream(rawInputStream, encoding);
                } finally {
                    cursor.close();
                }
            }
        });
    }","public InputStream getAttachmentInputStream(final String attachmentId) throws MessagingException {
        return database.execute(false, new DbCallback<InputStream>() {
            @Override
            public InputStream doDbWork(final SQLiteDatabase db) throws WrappedException {
                Cursor cursor = db.query(""message_parts"",
                        new String[] { ""data_location"", ""data"", ""encoding"" },
                        ""id = ?"",
                        new String[] { attachmentId },
                        null, null, null);
                try {
                    if (!cursor.moveToFirst()) {
                        return null;
                    }

                    int location = cursor.getInt(0);
                    String encoding = cursor.getString(2);

                    InputStream rawInputStream = getRawAttachmentInputStream(cursor, location, attachmentId);
                    return getDecodingInputStream(rawInputStream, encoding);
                } finally {
                    cursor.close();
                }
            }
        });
    }",no,no,"Yes
Leaky Resources:
Cursor","Yes
Leaky Resources:
Cursor"
Terminal,java.io.InputStream,ef9c1b1ff9,7ede276096,finish(),TermSession.java,Pull 113,yes,no,n/a,no,,no,n/a,n/a,,,no,n/a,no,,no,n/a,n/a,,,,yes,leak on certain normal paths,,https://github.com/jackpal/Android-Terminal-Emulator,libraries/emulatorview/src/jackpal/androidterm/emulatorview/TermSession.java,https://github.com/jackpal/Android-Terminal-Emulator/commit/ef9c1b1ff9fe7e9bb8f65dede31cc924ca853e63,https://github.com/jackpal/Android-Terminal-Emulator/commit/7ede27609622f99b0b7cb7baf0c02a46945381ed,"    public void finish() {
        mIsRunning = false;
        mTranscriptScreen.finish();
        if (mFinishCallback != null) {
            mFinishCallback.onSessionFinish(this);
        }
    }
","    public void finish() {
        mIsRunning = false;
        mTranscriptScreen.finish();

        // Stop the reader and writer threads, and close the I/O streams
        mWriterHandler.sendEmptyMessage(FINISH);
        try {
            mTermIn.close();
            mTermOut.close();
        } catch (IOException e) {
            // We don't care if this fails
        }

        if (mFinishCallback != null) {
            mFinishCallback.onSessionFinish(this);
        }
    }
",no,no,"No
Leaky Resources:
None","No
Leaky Resources:
None"
Hacker News,java.io.ObjectInputStream,5d9f87fde3,3491bef7d1,getLastHNFeed(),FileUtil.java,,yes,yes,n/a,yes,,n/a,n/a,n/a,,,yes,n/a,no,,n/a,n/a,n/a,,,,no,complete leak,,https://github.com/manmal/hn-android,src/com/manuelmaly/hn/util/FileUtil.java,https://github.com/manmal/hn-android/commit/5d9f87fde321804475b91510de20ecf091c2f049,https://github.com/manmal/hn-android/commit/3491bef7d139fa25669936c87dacbd1fc9c345f8,"    public static HNFeed getLastHNFeed() {
        try {
            ObjectInputStream obj = new ObjectInputStream(new FileInputStream(getLastHNFeedFilePath()));
            Object rawHNFeed = obj.readObject();
            if (rawHNFeed instanceof HNFeed)
                return (HNFeed) rawHNFeed;
        } catch (Exception e) {
            Log.e(TAG, ""Could not get last HNFeed from file :("", e);
        }
        return null;
    }
","    public static HNFeed getLastHNFeed() {
    	ObjectInputStream obj = null;
        try {
            obj = new ObjectInputStream(new FileInputStream(getLastHNFeedFilePath()));
            Object rawHNFeed = obj.readObject();
            if (rawHNFeed instanceof HNFeed)
                return (HNFeed) rawHNFeed;
        } catch (Exception e) {
            Log.e(TAG, ""Could not get last HNFeed from file :("", e);
        } finally {
        	if (obj!=null){
        		try {
					obj.close();
				} catch (IOException e) {
		            Log.e(TAG, ""Couldn't close last NH feed file :("", e);
				}
        	}
        }
        return null;
    }
",no,no,"Yes
Leaky Resources:
ObjectInputStream, FileInputStream","No
Leaky Resources:
None

The code snippet provided does not have any resource leaks. The ObjectInputStream 'obj' is properly closed in the 'finally' block, ensuring that the resource is released regardless of whether an exception is thrown or not."
Hacker News,java.io.ObjectInputStream,5d9f87fde3,3491bef7d1,getLastHNPostComments(),FileUtil.java,,yes,yes,n/a,yes,,n/a,n/a,n/a,,,yes,n/a,no,,n/a,n/a,n/a,,,,no,complete leak,,https://github.com/manmal/hn-android,src/com/manuelmaly/hn/util/FileUtil.java,https://github.com/manmal/hn-android/commit/5d9f87fde321804475b91510de20ecf091c2f049,https://github.com/manmal/hn-android/commit/3491bef7d139fa25669936c87dacbd1fc9c345f8,"    public static HNPostComments getLastHNPostComments(String postID) {
        try {
            ObjectInputStream obj = new ObjectInputStream(new FileInputStream(getLastHNPostCommentsPath(postID)));
            Object rawHNComments = obj.readObject();
            if (rawHNComments instanceof HNPostComments)
                return (HNPostComments) rawHNComments;
        } catch (Exception e) {
            Log.e(TAG, ""Could not get last HNPostComments from file :("", e);
        }
        return null;
    }
","    public static HNPostComments getLastHNPostComments(String postID) {
    	ObjectInputStream obj = null;
        try {
            obj = new ObjectInputStream(new FileInputStream(getLastHNPostCommentsPath(postID)));
            Object rawHNComments = obj.readObject();
            if (rawHNComments instanceof HNPostComments)
                return (HNPostComments) rawHNComments;
        } catch (Exception e) {
            Log.e(TAG, ""Could not get last HNPostComments from file :("", e);
        } finally {
        	if (obj!=null){
        		try {
					obj.close();
				} catch (IOException e) {
		            Log.e(TAG, ""Couldn't close last NH comments file :("", e);
				}
        	}
        }
        return null;
    }
",no,no,"Yes
Leaky Resources:
ObjectInputStream, FileInputStream","No
Leaky Resources:
None"
Hacker News,java.io.ObjectOutputStream,5d9f87fde3,3491bef7d1,setLastHNFeed(),FileUtil.java,,yes,yes,n/a,yes,,n/a,n/a,n/a,,,yes,n/a,no,,n/a,n/a,n/a,,,,no,complete leak,,https://github.com/manmal/hn-android,src/com/manuelmaly/hn/util/FileUtil.java,https://github.com/manmal/hn-android/commit/5d9f87fde321804475b91510de20ecf091c2f049,https://github.com/manmal/hn-android/commit/3491bef7d139fa25669936c87dacbd1fc9c345f8,"    public static void setLastHNFeed(HNFeed hnFeed) {
        try {
            ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(getLastHNFeedFilePath()));
            os.writeObject(hnFeed);
        } catch (Exception e) {
            Log.e(TAG, ""Could not save last HNFeed to file :("", e);
        }
    }
","    public static void setLastHNFeed(HNFeed hnFeed) {
    	ObjectOutputStream os = null;
        try {
            os = new ObjectOutputStream(new FileOutputStream(getLastHNFeedFilePath()));
            os.writeObject(hnFeed);
        } catch (Exception e) {
            Log.e(TAG, ""Could not save last HNFeed to file :("", e);
        } finally {
        	if (os!=null){
        		try {
					os.close();
				} catch (IOException e) {
		            Log.e(TAG, ""Couldn't close last NH feed file :("", e);
		        }
        	}
        }
    }
",no,no,"Yes
Leaky Resources:
ObjectOutputStream, FileOutputStream","No
Leaky Resources:
None"
Hacker News,java.io.ObjectOutputStream,5d9f87fde3,3491bef7d1,setLastHNPostComments(),FileUtil.java,,yes,yes,n/a,yes,,n/a,n/a,n/a,,,yes,n/a,no,,n/a,n/a,n/a,,,,no,complete leak,,https://github.com/manmal/hn-android,src/com/manuelmaly/hn/util/FileUtil.java,https://github.com/manmal/hn-android/commit/5d9f87fde321804475b91510de20ecf091c2f049,https://github.com/manmal/hn-android/commit/3491bef7d139fa25669936c87dacbd1fc9c345f8,"    public static void setLastHNPostComments(HNPostComments comments, String postID) {
        try {
            ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(getLastHNPostCommentsPath(postID)));
            os.writeObject(comments);
        } catch (Exception e) {
            Log.e(TAG, ""Could not save last HNPostComments to file :("", e);
        }
    }
","    public static void setLastHNPostComments(HNPostComments comments, String postID) {
    	ObjectOutputStream os = null;
        try {
            os = new ObjectOutputStream(new FileOutputStream(getLastHNPostCommentsPath(postID)));
            os.writeObject(comments);
        } catch (Exception e) {
            Log.e(TAG, ""Could not save last HNPostComments to file :("", e);
        } finally {
        	if (os!=null){
        		try {
					os.close();
				} catch (IOException e) {
		            Log.e(TAG, ""Couldn't close last NH comments file :("", e);
		        }
        	}
        }
    }
",no,no,"Yes
Leaky Resources:
ObjectOutputStream, FileOutputStream","No
Leaky Resources:
None"
K-9 Mail,java.io.OutputStream,7e1501499f,acd18291f2,CheckOutgoing(),AccountSetupCheckSettings.java,Pull 1199,yes,no,n/a,no,,no,n/a,n/a,,,no,n/a,no,,no,n/a,n/a,,,,no,leak on exceptional paths ,,https://github.com/k9mail/k-9,k9mail/src/main/java/com/fsck/k9/activity/setup/AccountSetupCheckSettings.java,https://github.com/k9mail/k-9/commit/7e1501499f5425dc955fee650f0bbb907b957b02,https://github.com/k9mail/k-9/commit/acd18291f2ded8f176beb074415f8c42ca829966,"private void checkOutgoing() throws MessagingException {
            if (!(account.getRemoteStore() instanceof WebDavStore)) {
                publishProgress(R.string.account_setup_check_settings_check_outgoing_msg);
            }
            Transport transport = Transport.getInstance(K9.app, account);
            transport.close();
            transport.open();
            transport.close();
        }","private void checkOutgoing() throws MessagingException {
            if (!(account.getRemoteStore() instanceof WebDavStore)) {
                publishProgress(R.string.account_setup_check_settings_check_outgoing_msg);
            }
            Transport transport = Transport.getInstance(K9.app, account);
            transport.close();
            try {
                transport.open();
            } finally {
                transport.close();
            }
        }",no,no,"No
Leaky Resources:
None","No
Leaky Resources:
None

The code snippet provided does not seem to have any resource leaks. The Transport resource is properly closed in a finally block, ensuring it gets closed whether an exception is thrown or not."
Terminal,java.io.OutputStream,ef9c1b1ff9,7ede276096,finish(),TermSession.java,Pull 113,yes,no,n/a,no,,no,n/a,n/a,,,no,n/a,no,,no,n/a,n/a,,,,yes,leak on certain normal paths,,https://github.com/jackpal/Android-Terminal-Emulator,libraries/emulatorview/src/jackpal/androidterm/emulatorview/TermSession.java,https://github.com/jackpal/Android-Terminal-Emulator/commit/ef9c1b1ff9fe7e9bb8f65dede31cc924ca853e63,https://github.com/jackpal/Android-Terminal-Emulator/commit/7ede27609622f99b0b7cb7baf0c02a46945381ed,"    public void finish() {
        mIsRunning = false;
        mTranscriptScreen.finish();
        if (mFinishCallback != null) {
            mFinishCallback.onSessionFinish(this);
        }
    }
","    public void finish() {
        mIsRunning = false;
        mTranscriptScreen.finish();

        // Stop the reader and writer threads, and close the I/O streams
        mWriterHandler.sendEmptyMessage(FINISH);
        try {
            mTermIn.close();
            mTermOut.close();
        } catch (IOException e) {
            // We don't care if this fails
        }

        if (mFinishCallback != null) {
            mFinishCallback.onSessionFinish(this);
        }
    }
",no,no,"No
Leaky Resources:
None

The provided code snippet does not contain any obvious resource leaks. It does not open or create any resources such as files, database connections, or network connections that it fails to close.","No
Leaky Resources:
None"
K-9 Mail,java.io.PipedOutputStream,3077e6a2d7,0a07250417,run() @line 189,MessageCryptoHelper.java,Pull 1,yes,yes,n/a,n/a,,yes,n/a,n/a,,,yes,n/a,n/a,,yes,n/a,n/a,,,,yes,complete leak,,https://github.com/k9mail/k-9,k9mail/src/main/java/com/fsck/k9/ui/messageview/MessageCryptoHelper.java,https://github.com/k9mail/k-9/commit/3077e6a2d7c280a4d7af3bc20cec2b7b3eea4e16,https://github.com/k9mail/k-9/commit/0a0725041773e2e6bc17355580d6d12fa8326292,"@Override
            public void run() {
                try {
                    Multipart multipartEncryptedMultipart = (Multipart) currentlyDecrypringOrVerifyingPart.getBody();
                    BodyPart encryptionPayloadPart = multipartEncryptedMultipart.getBodyPart(1);
                    Body encryptionPayloadBody = encryptionPayloadPart.getBody();
                    encryptionPayloadBody.writeTo(out);
                } catch (Exception e) {
                    Log.e(K9.LOG_TAG, ""Exception while writing message to crypto provider"", e);
                }
            }","@Override
            public void run() {
                try {
                    Multipart multipartSignedMultipart = (Multipart) currentlyDecrypringOrVerifyingPart.getBody();
                    BodyPart signatureBodyPart = multipartSignedMultipart.getBodyPart(0);
                    Log.d(K9.LOG_TAG, ""signed data type: "" + signatureBodyPart.getMimeType());
                    signatureBodyPart.writeTo(out);
                } catch (Exception e) {
                    Log.e(K9.LOG_TAG, ""Exception while writing message to crypto provider"", e);
                } finally {
                    try {
                        out.close();
                    } catch (IOException e) {
                        // don't care
                    }
                }
            }",no,no,"No
Leaky Resources:
None","No
Leaky Resources:
None"
K-9 Mail,java.io.PipedOutputStream,3077e6a2d7,0a07250417,run() @line 210,MessageCryptoHelper.java,Pull 1,yes,yes,n/a,n/a,,yes,n/a,n/a,,,yes,n/a,n/a,,yes,n/a,n/a,,,,yes,complete leak,,https://github.com/k9mail/k-9,k9mail/src/main/java/com/fsck/k9/ui/messageview/MessageCryptoHelper.java,https://github.com/k9mail/k-9/commit/3077e6a2d7c280a4d7af3bc20cec2b7b3eea4e16,https://github.com/k9mail/k-9/commit/0a0725041773e2e6bc17355580d6d12fa8326292,"@Override
            public void run() {
                try {
                    Multipart multipartSignedMultipart = (Multipart) currentlyDecrypringOrVerifyingPart.getBody();
                    BodyPart signatureBodyPart = multipartSignedMultipart.getBodyPart(0);
                    Log.d(K9.LOG_TAG, ""signed data type: "" + signatureBodyPart.getMimeType());
                    signatureBodyPart.writeTo(out);
                } catch (Exception e) {
                    Log.e(K9.LOG_TAG, ""Exception while writing message to crypto provider"", e);
               
                }
            }","@Override
            public void run() {
                try {
                    Multipart multipartSignedMultipart = (Multipart) currentlyDecrypringOrVerifyingPart.getBody();
                    BodyPart signatureBodyPart = multipartSignedMultipart.getBodyPart(0);
                    Log.d(K9.LOG_TAG, ""signed data type: "" + signatureBodyPart.getMimeType());
                    signatureBodyPart.writeTo(out);
                } catch (Exception e) {
                    Log.e(K9.LOG_TAG, ""Exception while writing message to crypto provider"", e);
                } finally {
                    try {
                        out.close();
                    } catch (IOException e) {
                        // don't care
                    }
                }
            }",no,no,"No
Leaky Resources:
None","No
Leaky Resources:
None"
K-9 Mail,java.net.Socket,7e1501499f,acd18291f2,CheckOutgoing(),AccountSetupCheckSettings.java,Pull 1199,yes,no,n/a,n/a,,no,n/a,n/a,,,no,n/a,n/a,,no,n/a,n/a,,,,no,leak on exceptional paths ,,https://github.com/k9mail/k-9,k9mail/src/main/java/com/fsck/k9/activity/setup/AccountSetupCheckSettings.java,https://github.com/k9mail/k-9/commit/7e1501499f5425dc955fee650f0bbb907b957b02,https://github.com/k9mail/k-9/commit/acd18291f2ded8f176beb074415f8c42ca829966,"private void checkOutgoing() throws MessagingException {
            if (!(account.getRemoteStore() instanceof WebDavStore)) {
                publishProgress(R.string.account_setup_check_settings_check_outgoing_msg);
            }
            Transport transport = Transport.getInstance(K9.app, account);
            transport.close();
            transport.open();
            transport.close();
         
        }","private void checkOutgoing() throws MessagingException {
            if (!(account.getRemoteStore() instanceof WebDavStore)) {
                publishProgress(R.string.account_setup_check_settings_check_outgoing_msg);
            }
            Transport transport = Transport.getInstance(K9.app, account);
            transport.close();

            try {
                transport.open();
            } finally {
                transport.close();
            }
        }",no,no,"No
Leaky Resources:
None","No
Leaky Resources: None

The code snippet provided does not seem to have any resource leaks. The Transport resource is properly closed in a finally block, ensuring it gets closed whether an exception is thrown or not."
IRCCloud,java.net.Socket,827b5e1b2b,b8eddb5746,run(),GingerbreadImageProxy.java,,yes,no,n/a,n/a,,yes,n/a,n/a,,,no,n/a,n/a,,no,n/a,n/a,,,,yes,complete leak,,https://github.com/irccloud/android,src/com/irccloud/android/GingerbreadImageProxy.java,https://github.com/irccloud/android/commit/827b5e1b2b19865caf1d5c955b692795a4f22aa9,https://github.com/irccloud/android/commit/b8eddb57468125854ababac393d0331085376067,"    public void run() {
        while (isRunning) {
            try {
                Socket client = socket.accept();
                if (client == null) {
                    continue;
                }
                HttpRequest request = readRequest(client);
                if (isRunning)
                    processRequest(request, client);
            } catch (SocketTimeoutException e) {
                // Do nothing
            } catch (IOException e) {
                Log.e(LOG_TAG, ""Error connecting to client"", e);
            }
        }
    }
","    public void run() {
        while (isRunning) {
            try {
                Socket client = socket.accept();
                if (client == null) {
                    continue;
                }
                HttpRequest request = readRequest(client);
                if (isRunning)
                    processRequest(request, client);
                client.close();
            } catch (SocketTimeoutException e) {
                // Do nothing
            } catch (IOException e) {
                Log.e(LOG_TAG, ""Error connecting to client"", e);
            }
        }
    }
",no,no,"Yes
Leaky Resources:
Socket","Yes
Leaky Resources:
Socket

Explanation:
In the provided code snippet, a Socket resource is created in line 4. However, if an exception occurs in line 8 or line 10 before the socket is closed in line 11, the socket will not be closed, leading to a resource leak. This is because the socket.close() method is not in a finally block, which would ensure it is executed regardless of whether an exception is thrown."
Bitcoin-wallet,java.util.concurrent.Semaphore,0efaa79fe3,6388d3c75e,onChainDownloadStarted(),DownloadListener.java,,yes,n/a,n/a,n/a,,n/a,n/a,n/a,,,n/a,n/a,n/a,,n/a,n/a,n/a,,,,yes,leak on certain normal paths,,https://github.com/bitcoin-wallet/bitcoin-wallet,src/com/google/bitcoin/core/DownloadListener.java,https://github.com/bitcoin-wallet/bitcoin-wallet/commit/0efaa79fe37d0ad86946ece7f031d0cadd997a45,https://github.com/bitcoin-wallet/bitcoin-wallet/commit/6388d3c75e861f8d0cf1359b9ef67b9f99796d2c,"    @Override
    public void onChainDownloadStarted(Peer peer, int blocksLeft) {
        startDownload(blocksLeft);
        originalBlocksLeft = blocksLeft;
    }
","@Override
    public void onChainDownloadStarted(Peer peer, int blocksLeft) {
        startDownload(blocksLeft);
        originalBlocksLeft = blocksLeft;
        if (blocksLeft == 0) {
            doneDownload();
            done.release();
        }
    }",no,no,"No
Leaky Resources:
None

The provided code snippet does not contain any resource leaks. It does not open any resources such as files, database connections, or network connections that would need to be closed.","No
Leaky Resources:
None

The provided code snippet does not show any resource leaks. It does not open any resources that it does not close."
Ushahidi,java.util.concurrent.Semaphore,52525168b5,d578c72309,onReceive(),OpenGeoSMSSender.java,Issue 95,yes,n/a,n/a,n/a,,n/a,n/a,n/a,,,n/a,n/a,n/a,,n/a,n/a,n/a,,,,yes,leak on exceptional paths ,,https://github.com/ushahidi/Ushahidi_Android,Core/src/com/ushahidi/android/app/opengeosms/OpenGeoSMSSender.java,https://github.com/ushahidi/Ushahidi_Android/commit/52525168b598e0323985c58801b396bbb762801c,https://github.com/ushahidi/Ushahidi_Android/commit/d578c723098ade734119a11b81ae91b93548507f,"@Override
		public void onReceive(Context context, Intent intent) {
			if (getResultCode() != Activity.RESULT_OK) {
				mRecvRetVal = false;
				context.unregisterReceiver(this);
				mSem.release();
				return;
			}
			mPendingIntents.remove(mPendingIntents.size() - 1);
			if (mPendingIntents.isEmpty()) {
				mRecvRetVal = true;
				context.unregisterReceiver(this);
				mSem.release();
			}
		}","@Override
		public void onReceive(Context context, Intent intent) {
			if (getResultCode() != Activity.RESULT_OK) {
				mRecvRetVal = false;
				context.unregisterReceiver(this);
				mSem.release();
				return;
			}

			// Fix for a potential null object here
			if (mPendingIntents != null) {
				mPendingIntents.remove(mPendingIntents.size() - 1);
				if (mPendingIntents.isEmpty()) {
					mRecvRetVal = true;
					context.unregisterReceiver(this);
					mSem.release();
				}
			}
		}",no,no,"No
Leaky Resources:
None","No
Leaky Resources:
None"
Bitcoin-wallet,java.util.Formatter,06b9048809,c33b6525df,appendReport() @line 291,ErrorReporter.java,,yes,yes,n/a,n/a,,yes,n/a,n/a,,,yes,n/a,n/a,,no,n/a,n/a,,,,no,complete leak,,https://github.com/bitcoin-wallet/bitcoin-wallet,wallet/src/de/schildbach/wallet/util/ErrorReporter.java,https://github.com/bitcoin-wallet/bitcoin-wallet/commit/06b9048809443aeeb2e4a5e7fa7945e70f3197f8,https://github.com/bitcoin-wallet/bitcoin-wallet/commit/c33b6525df3cbcb1da78414461062b028f8307b8,"private static void appendReport(final StringBuilder report, final File file, final int indent)
 {
  final Formatter formatter = new Formatter(report);

  for (int i = 0; i < indent; i++)
   report.append(""  - "");


  formatter.format(""%tF %tT  %s  [%d]\n"", file.lastModified(), file.lastModified(), file.getName(), file.length());


  if (file.isDirectory())
   for (final File f : file.listFiles())
    appendReport(report, f, indent + 1);
 }","private static void appendReport(final StringBuilder report, final File file, final int indent)
 {

  for (int i = 0; i < indent; i++)
   report.append(""  - "");

  final Formatter formatter = new Formatter(report);
  formatter.format(""%tF %tT  %s  [%d]\n"", file.lastModified(), file.lastModified(), file.getName(), file.length());
  formatter.close();

  if (file.isDirectory())
   for (final File f : file.listFiles())
    appendReport(report, f, indent + 1);
 }",no,no,"Yes
Leaky Resources:
Formatter","No
Leaky Resources:
None"
Osmand,java.util.logging.FileHandler,c586357631,88ea34e8c0,generateIndex() @line 497,IndexBatchCreator.java,,yes,n/a,n/a,n/a,,n/a,n/a,n/a,,,n/a,n/a,n/a,,n/a,n/a,n/a,,,,yes,complete leak,,https://github.com/osmandapp/Osmand,DataExtractionOSM/src/net/osmand/data/index/IndexBatchCreator.java,https://github.com/osmandapp/Osmand/commit/c58635763128604de66956e71d85ac42fe7ea07b,https://github.com/osmandapp/Osmand/commit/88ea34e8c0193ea87973683e6e56c51ca7a1e6ac,"protected void generateIndex(File f, String rName, RegionSpecificData regionSpecificData, Set<String> alreadyGeneratedFiles, Set<String> alreadyUploadedFiles) {
		if (!generateIndexes) {
			return;
		}
		try {
			// be independent of previous results
			RTree.clearCache();
			
			String regionName = f.getName();
			log.warn(""-------------------------------------------"");
			log.warn(""----------- Generate "" + f.getName() + ""\n\n\n"");
			int i = f.getName().indexOf('.');
			if (i > -1) {
				regionName = Algoritms.capitalizeFirstLetterAndLowercase(f.getName().substring(0, i));
			}
			if(Algoritms.isEmpty(rName)){
				rName = regionName;
			} else {
				rName = Algoritms.capitalizeFirstLetterAndLowercase(rName);
			}
			
			IndexCreator indexCreator = new IndexCreator(workDir);
			indexCreator.setIndexAddress(indexAddress);
			indexCreator.setIndexPOI(indexPOI);
			indexCreator.setIndexTransport(indexTransport);
			indexCreator.setIndexMap(indexMap);
			indexCreator.setLastModifiedDate(f.lastModified());
			indexCreator.setNormalizeStreets(true);
			indexCreator.setSaveAddressWays(true);
			indexCreator.setRegionName(rName);
			if (regionSpecificData != null && regionSpecificData.cityAdminLevel != null) {
				indexCreator.setCityAdminLevel(regionSpecificData.cityAdminLevel);
			}
			if(zoomWaySmoothness != null){
				indexCreator.setZoomWaySmothness(zoomWaySmoothness);
			}

			String poiFileName = regionName + ""_"" + IndexConstants.POI_TABLE_VERSION + IndexConstants.POI_INDEX_EXT;
			indexCreator.setPoiFileName(poiFileName);
			String mapFileName = regionName + ""_"" + IndexConstants.BINARY_MAP_VERSION + IndexConstants.BINARY_MAP_INDEX_EXT;
			indexCreator.setMapFileName(mapFileName);
			try {
				alreadyGeneratedFiles.add(f.getName());
				Log warningsAboutMapData = null;
				FileHandler fh = null;
				// configure log path
				try {
					fh = new FileHandler(new File(workDir, mapFileName+"".gen.log"").getAbsolutePath(), 5000000, 1, true);
					fh.setFormatter(new SimpleFormatter());
					fh.setLevel(Level.ALL);
					Jdk14Logger jdk14Logger = new Jdk14Logger(""tempLogger"");
		                        jdk14Logger.getLogger().setLevel(Level.ALL);
		                        jdk14Logger.getLogger().setUseParentHandlers(false);
		                        jdk14Logger.getLogger().addHandler(fh);
		                        warningsAboutMapData = jdk14Logger;												
				} catch (SecurityException e1) {
					e1.printStackTrace();
				} catch (IOException e1) {
					e1.printStackTrace();
				}
				if(fh != null) {
					LogManager.getLogManager().getLogger("""").addHandler(fh);
				}
				
				indexCreator.generateIndexes(f, new ConsoleProgressImplementation(3),  null, mapZooms, types, warningsAboutMapData);
				
				File generated = new File(workDir, mapFileName);
				File ready = new File(indexDirFiles, mapFileName);
				generated.renameTo(ready);
				// Do not upload poi files any more
				if (indexMap || indexAddress || indexTransport || indexPOI) {
					uploadIndex(ready, alreadyUploadedFiles);
				}
				if(fh != null) {
					LogManager.getLogManager().getLogger("""").removeHandler(fh);
				}
			} catch (Exception e) {
				log.error(""Exception generating indexes for "" + f.getName(), e); //$NON-NLS-1$ 
			}
		} catch (OutOfMemoryError e) {
			System.gc();
			log.error(""OutOfMemory"", e);

		}
		System.gc();
	}","protected void generateIndex(File f, String rName, RegionSpecificData regionSpecificData, Set<String> alreadyGeneratedFiles, Set<String> alreadyUploadedFiles) {
		if (!generateIndexes) {
			return;
		}
		try {
			// be independent of previous results
			RTree.clearCache();
			
			String regionName = f.getName();
			log.warn(""-------------------------------------------"");
			log.warn(""----------- Generate "" + f.getName() + ""\n\n\n"");
			int i = f.getName().indexOf('.');
			if (i > -1) {
				regionName = Algoritms.capitalizeFirstLetterAndLowercase(f.getName().substring(0, i));
			}
			if(Algoritms.isEmpty(rName)){
				rName = regionName;
			} else {
				rName = Algoritms.capitalizeFirstLetterAndLowercase(rName);
			}
			
			IndexCreator indexCreator = new IndexCreator(workDir);
			indexCreator.setIndexAddress(indexAddress);
			indexCreator.setIndexPOI(indexPOI);
			indexCreator.setIndexTransport(indexTransport);
			indexCreator.setIndexMap(indexMap);
			indexCreator.setLastModifiedDate(f.lastModified());
			indexCreator.setNormalizeStreets(true);
			indexCreator.setSaveAddressWays(true);
			indexCreator.setRegionName(rName);
			if (regionSpecificData != null && regionSpecificData.cityAdminLevel != null) {
				indexCreator.setCityAdminLevel(regionSpecificData.cityAdminLevel);
			}
			if(zoomWaySmoothness != null){
				indexCreator.setZoomWaySmothness(zoomWaySmoothness);
			}

			String poiFileName = regionName + ""_"" + IndexConstants.POI_TABLE_VERSION + IndexConstants.POI_INDEX_EXT;
			indexCreator.setPoiFileName(poiFileName);
			String mapFileName = regionName + ""_"" + IndexConstants.BINARY_MAP_VERSION + IndexConstants.BINARY_MAP_INDEX_EXT;
			indexCreator.setMapFileName(mapFileName);
			try {
				alreadyGeneratedFiles.add(f.getName());
				Log warningsAboutMapData = null;
				FileHandler fh = null;
				// configure log path
				try {
					fh = new FileHandler(new File(workDir, mapFileName+"".gen.log"").getAbsolutePath(), 5000000, 1, true);
					fh.setFormatter(new SimpleFormatter());
					fh.setLevel(Level.ALL);
					Jdk14Logger jdk14Logger = new Jdk14Logger(""tempLogger"");
		                        jdk14Logger.getLogger().setLevel(Level.ALL);
		                        jdk14Logger.getLogger().setUseParentHandlers(false);
		                        jdk14Logger.getLogger().addHandler(fh);
		                        warningsAboutMapData = jdk14Logger;												
				} catch (SecurityException e1) {
					e1.printStackTrace();
				} catch (IOException e1) {
					e1.printStackTrace();
				}
				if(fh != null) {
					LogManager.getLogManager().getLogger("""").addHandler(fh);
				}
				
				indexCreator.generateIndexes(f, new ConsoleProgressImplementation(3),  null, mapZooms, types, warningsAboutMapData);
				
				File generated = new File(workDir, mapFileName);
				File ready = new File(indexDirFiles, mapFileName);
				generated.renameTo(ready);
				// Do not upload poi files any more
				if (indexMap || indexAddress || indexTransport || indexPOI) {
					uploadIndex(ready, alreadyUploadedFiles);
				}
				if(fh != null) {
					LogManager.getLogManager().getLogger("""").removeHandler(fh);
					fh.close();
				}
			} catch (Exception e) {
				log.error(""Exception generating indexes for "" + f.getName(), e); //$NON-NLS-1$ 
			}
		} catch (OutOfMemoryError e) {
			System.gc();
			log.error(""OutOfMemory"", e);

		}
		System.gc();
	}",no,no,"Yes
Leaky Resources:
File Handler","No
Leaky Resources:"
Cgeo,java.util.Scanner,ea04b619e0,8987674ab4,getFileContent(),AbstractResourceInstrumentationTestCase.java,,yes,yes,n/a,n/a,,yes,n/a,n/a,,,yes,n/a,n/a,,no,n/a,n/a,,,,no,complete leak,,https://github.com/cgeo/cgeo,tests/src/cgeo/geocaching/test/AbstractResourceInstrumentationTestCase.java,https://github.com/cgeo/cgeo/commit/ea04b619e00a71a9b5a443511b28a82fe37dcead,https://github.com/cgeo/cgeo/commit/8987674ab4882f7684c773fc181f5a3fac5f8f12,"    protected String getFileContent(int resourceId) {
        final InputStream ins = getResourceStream(resourceId);
        final String result = new Scanner(ins).useDelimiter(""\\A"").next();
        try {
            ins.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return result;
    }
","    protected String getFileContent(int resourceId) {
        Scanner scanner = null;
        try {
            final InputStream ins = getResourceStream(resourceId);
            scanner = new Scanner(ins);
            return scanner.useDelimiter(""\\A"").next();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (scanner != null) {
                scanner.close();
            }
        }
        return null;
    }
",no,no,"Yes
Leaky Resources:
InputStream

Explanation:
The InputStream 'ins' is opened but not properly closed in a finally block or using try-with-resources. If an exception is thrown before line 5, the InputStream will not be closed, leading to a resource leak.","Yes
Leaky Resources:
InputStream"
Cgeo,java.util.Scanner,fb2d9a3a57,e2c320b5f9,getRawResourceString(),AboutActivity.java,Issue 5035,yes,yes,n/a,n/a,,no,n/a,n/a,,,yes,n/a,n/a,,no,n/a,n/a,,,,no,leak on exceptional paths ,,https://github.com/cgeo/cgeo,main/src/cgeo/geocaching/AboutActivity.java,https://github.com/cgeo/cgeo/commit/fb2d9a3a5754dff5f7d62d97b176aba1996ed797,https://github.com/cgeo/cgeo/commit/e2c320b5f906d5781791fd736be7d1aa719cc7c2,"private String getRawResourceString(final int resourceId) {
            InputStream ins = null;
            Scanner scanner = null;
            try {
                ins = res.openRawResource(resourceId);
                scanner = new Scanner(ins, CharEncoding.UTF_8);
                return scanner.useDelimiter(""\\A"").next();
            } finally {
                IOUtils.closeQuietly(scanner);
                IOUtils.closeQuietly(ins);
            }
        }","private String getRawResourceString(final int resourceId) {
            InputStream ins = null;
            Scanner scanner = null;
            try {
                ins = res.openRawResource(resourceId);
                scanner = new Scanner(ins, CharEncoding.UTF_8);
                return scanner.useDelimiter(""\\A"").next();
            } finally {
                IOUtils.closeQuietly(ins);
                // Scanner does not implement Closeable on Android 4.1, so closeQuietly leads to crash there
                if (scanner != null) {
                    scanner.close();
                }
            }
        }",no,no,"No
Leaky Resources:
None

The code snippet provided is correctly handling the closing of resources. Both the InputStream and Scanner are being closed in the finally block, which ensures that they are closed regardless of whether an exception occurs. This prevents resource leaks.","No
Leaky Resources:
None"
Bankdroid,org.apache.http.impl.client.DefaultHttpClient,2655094aa4,2b0345b5c2,doInBackground() @line 142,AccountActivity.java,,yes,n/a,n/a,n/a,,n/a,n/a,n/a,,,n/a,n/a,n/a,,n/a,n/a,n/a,,,,yes,complete leak,,https://github.com/liato/android-bankdroid,src/com/liato/bankdroid/AccountActivity.java,https://github.com/liato/android-bankdroid/commit/2655094aa465c8b3fa0b871d77a160b4a0c73d4a,https://github.com/liato/android-bankdroid/commit/2b0345b5c2b01670346307461bc45a676e3a55d5,"		protected Void doInBackground(final String... args) {
			try {
				Log.d(TAG, ""Updating ""+bank);
				bank.update();
				bank.updateAllTransactions();
				Log.d(TAG, ""Saving ""+bank);
				bank.save();
				Log.d(TAG, ""Disabled: ""+bank.isDisabled());
			} 
			catch (BankException e) {
				this.exc = e;
			} catch (LoginException e) {
				this.exc = e;
			}
			return null;
		}
","		protected Void doInBackground(final String... args) {
			try {
				Log.d(TAG, ""Updating ""+bank);
				bank.update();
				bank.updateAllTransactions();
				bank.closeConnection();
				Log.d(TAG, ""Saving ""+bank);
				bank.save();
				Log.d(TAG, ""Disabled: ""+bank.isDisabled());
			} 
			catch (BankException e) {
				this.exc = e;
			} catch (LoginException e) {
				this.exc = e;
			}
			return null;
		}
",no,no,"No
Leaky Resources:
None

The provided code snippet does not show any explicit resource leaks. It does not open any files, database connections, or network connections that it fails to close. However, without the full context of the code, it's impossible to say for certain. For example, if the `update`, `updateAllTransactions`, or `save` methods on the `bank` object open resources without properly closing them, there could be a resource leak. But based on the provided snippet alone, there are no visible resource leaks.","No
Leaky Resources:
None

The provided code snippet does not show any obvious resource leaks. The connection to the bank is properly closed on line 6. However, without the full context of the code, it's impossible to say for certain. For example, if the `update`, `updateAllTransactions`, or `save` methods open resources without closing them, there could be a leak. But based on the provided snippet, there are no visible resource leaks."
Bankdroid,org.apache.http.impl.client.DefaultHttpClient,2655094aa4,bf136c7b0a,doInBackground() @line 203,BankdroidWidgetProvider.java,,yes,n/a,n/a,n/a,,n/a,n/a,n/a,,,n/a,n/a,n/a,,n/a,n/a,n/a,,,,no,complete leak,,https://github.com/liato/android-bankdroid,src/com/liato/bankdroid/BankdroidWidgetProvider.java,https://github.com/liato/android-bankdroid/commit/2655094aa465c8b3fa0b871d77a160b4a0c73d4a,https://github.com/liato/android-bankdroid/commit/bf136c7b0a92771418d1c44ae6d1326dee556c01,"@Override
			protected Void doInBackground(Void... params) {
				String accountId = WidgetConfigureActivity.getAccountId(context, appWidgetId);
				if (accountId == null) {
					Log.d(""WidgetService"", ""Widget not found in db: ""+appWidgetId);
					return null;
				}
				String bankId = accountId.split(""_"")[0];
				Bank bank = BankFactory.bankFromDb(new Long(bankId), context, false);
				if (bank == null) {
					return null;
				}

				try {
					if (!bank.isDisabled()) {
						bank.update();
						bank.save();
					}
					else {
						Log.d(""BankdroidWidgetProvider"", ""Bank is disabled, skipping refresh on ""+bank.getDbId());
					}
				} 
				catch (BankException e) {
    				Log.d(TAG, ""Error while updating bank '""+bank.getDbId()+""'; ""+e.getMessage());
				} catch (LoginException e) {
					Log.d("""", ""Disabling bank: ""+bank.getDbId());
					bank.disable();
				}

				BankdroidWidgetProvider.updateAppWidget(context, appWidgetManager, appWidgetId);
				return null;
			}","@Override
			protected Void doInBackground(Void... params) {
				String accountId = WidgetConfigureActivity.getAccountId(context, appWidgetId);
				if (accountId == null) {
					Log.d(""WidgetService"", ""Widget not found in db: ""+appWidgetId);
					return null;
				}
				String bankId = accountId.split(""_"")[0];
				Bank bank = BankFactory.bankFromDb(new Long(bankId), context, false);
				if (bank == null) {
					return null;
				}

				try {
					if (!bank.isDisabled()) {
						bank.update();
						bank.closeConnection();
						bank.save();
					}
					else {
						Log.d(""BankdroidWidgetProvider"", ""Bank is disabled, skipping refresh on ""+bank.getDbId());
					}
				} 
				catch (BankException e) {
    				Log.d(TAG, ""Error while updating bank '""+bank.getDbId()+""'; ""+e.getMessage());
				} catch (LoginException e) {
					Log.d("""", ""Disabling bank: ""+bank.getDbId());
					bank.disable();
				}

				BankdroidWidgetProvider.updateAppWidget(context, appWidgetManager, appWidgetId);
				return null;
			}",no,no,"No
Leaky Resources: None

The provided code snippet does not appear to have any resource leaks. It does not open any files, database connections, or network connections that it fails to close.","No
Leaky Resources: None

The provided code snippet does not seem to have any resource leaks. The connection to the bank is properly closed in line 17. There are no open file or database connections, or any other resources that are not properly closed or released."
